/* LOCOMOTIVE CLASSES
 * 
 * Used a a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  LocomotiveSimulator - defines the behaviour, ie physics, motion, power generated etc
 *  LocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCarSimulator - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */
/// COPYRIGHT 2009 by the Open Rails project.
/// This code is provided to enable you to contribute improvements to the open rails program.  
/// Use of the code for any other purpose or distribution of the code to anyone else
/// is prohibited without specific written permission from admin@openrails.org.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MSTS;
using System.Xml;
using Microsoft.Xna.Framework.Content;
using System.Text;
using ORTS.Popups;



namespace ORTS
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////


    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public partial class MSTSLocomotive: MSTSWagon
    {
        // simulation parameters
        public bool Horn = false;
        public bool AlerterSnd = false;
        public bool VigilanceMonitor = false;
        public bool Bell = false;
        public bool Sander = false;  
        public bool Wiper = false;
        public bool BailOff = false;
        public float MaxPowerW;
        public float MaxForceN;
        public float MaxSpeedMpS = 1e3f;
        public float MainResPressurePSI = 130;
        public bool CompressorOn = false;
        public float AverageForceN = 0;
        public bool PowerOn = false;
        public float PowerOnDelay = 0.0f;
        // by GeorgeS
        public bool CabLightOn = false;
        public bool ShowCab = true;

        bool AlerterIsActive = false;

        // wag file data
        public string CabSoundFileName = null;
        public string CVFFileName = null;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeFT3 = 10;
        public float CompressorRestartPressurePSI = 110;
        public float MainResChargingRatePSIpS = .4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = .003f;
        public float BrakeServiceTimeFactorS = 1.009f;
        public float BrakeEmergencyTimeFactorS = .1f;
        public float BrakePipeChargingRatePSIpS;
        public Interpolator2D TractiveForceCurves = null;
        public Interpolator2D DynamicBrakeForceCurves = null;
        public float DynamicBrakeSpeed1 = 3;
        public float DynamicBrakeSpeed2 = 18;
        public float DynamicBrakeSpeed3 = 23;
        public float DynamicBrakeSpeed4 = 35;
        public float MaxDynamicBrakeForceN = 0;
        public bool DynamicBrakeAutoBailOff = false;
        bool CabFlipped = false;

        public bool HasCombCtrl = false;
        public bool HasStepCtrl = false;
        public bool HasCombThrottleTrainBreak = false;
        public bool HasDefectiveComboDynamicBreak = false;
        public bool HasSmoothStruc = false;
        public int  ComboCtrlCrossOver = 5;

        public float MaxContinuousForceN;
        public float ContinuousForceTimeFactor = 1800;
        public float NumWheels = 4;
        public bool AntiSlip = false;
        public float SanderSpeedEffectUpToMpS = 0.0f;
        public float SanderSpeedOfMpS = 30.0f;
        public string EngineOperatingProcedures;

        public bool EmergencyCausesPowerDown = false;
        public bool EmergencyCausesThrottleDown = false;
        public bool EmergencyEngagesHorn = false;
        public bool WheelslipCausesThrottleDown = false;

        public Dictionary<string, List<ParticleEmitterData>> EffectData = new Dictionary<string,List<ParticleEmitterData>>();

        public CVFFile CVFFile = null;
        public ExtendedCVF ExCVF = null;

        public MSTSNotchController  ThrottleController;
        public MSTSBrakeController  TrainBrakeController;
        public MSTSBrakeController  EngineBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController  DynamicBrakeController;
        
        public Axle LocomotiveAxle;
        public IIRFilter CurrentFilter;
        public IIRFilter AdhesionFilter;
        
        public float FilteredMotiveForceN = 0.0f;

        

        public MSTSLocomotive(Simulator simulator, string wagPath, TrainCar previousCar)
            : base(simulator, wagPath, previousCar)
        {
			BrakePipeChargingRatePSIpS = simulator.Settings.BrakePipeChargingRate;

            LocomotiveAxle = new Axle();
            LocomotiveAxle.DriveType = AxleDriveType.ForceDriven;
            LocomotiveAxle.DampingNs = MassKG / 1000.0f;
            LocomotiveAxle.AdhesionK = AdhesionK;
            LocomotiveAxle.CurtiusKnifflerA = Curtius_KnifflerA;
            LocomotiveAxle.CurtiusKnifflerB = Curtius_KnifflerB;
            LocomotiveAxle.CurtiusKnifflerC = Curtius_KnifflerC;
            LocomotiveAxle.StabilityCorrection = true;
            CurrentFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.5f),0.001f);
            AdhesionFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.1f), 0.001f);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void InitializeFromWagFile(string wagFilePath)
        {
            TrainBrakeController = new MSTSBrakeController(Simulator);
            EngineBrakeController = new MSTSBrakeController(Simulator);
            DynamicBrakeController = new MSTSNotchController();
            base.InitializeFromWagFile(wagFilePath);

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            // Some engine files want continuous, but specify a notch
            if (ThrottleController.NotchCount() > 1)
                HasStepCtrl = true;

            // Is Alerter option checked in menu
            if (Program.Simulator.Settings.Alerter)
            {
                int startTime = (int)Simulator.ClockTime;
                if (VigilanceMonitor)
                    AlerterStartUp();
            }

            if (CVFFileName != null)
            {
                var cvfBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW");
                var cvfFilePath = Path.Combine(cvfBasePath, CVFFileName);
                if (File.Exists(cvfFilePath))
                {
                    CVFFile = new CVFFile(cvfFilePath, cvfBasePath);

                    // Set up camera locations for the cab views
                    for (int i = 0; i < CVFFile.Locations.Count; ++i)
                    {
                        if (i >= CVFFile.Locations.Count || i >= CVFFile.Directions.Count)
                        {
                            Trace.TraceWarning("Skipped cab view camera {1} missing Position and Direction in {0}", cvfFilePath, i);
                            break;
                        }
                        ViewPoint viewPoint = new ViewPoint();
                        viewPoint.Location = CVFFile.Locations[i];
                        viewPoint.StartDirection = CVFFile.Directions[i];
                        viewPoint.RotationLimit = new Vector3(0, 0, 0);  // cab views have a fixed head position
                        FrontCabViewpoints.Add(viewPoint);
                        if (i == 0 && (CVFFile.Directions[i].Y < -90 || CVFFile.Directions[i].Y > 90))
                            CabFlipped = true;
                    }

                    ExCVF = null;

                    if (ExCVF == null && !(this is MSTSSteamLocomotive))
                    {
                        ExCVF = new ExtendedCVF();
                        InitializeFromORTSSpecific(cvfFilePath, ExCVF);
                    }
                }
                else
                {
                    Trace.TraceWarning("{0} locomotive's CabView references non-existant {1}", wagFilePath, cvfFilePath);
                }
            }

            IsDriveable = true;
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new MSTSBrakeController(Simulator); //create a blank one
            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    Trace.TraceInformation("Smooth Dynamic Brake may have inaccurate display");
                    HasSmoothStruc = true;
                }
            }
            if (!DynamicBrakeController.IsValid())
                DynamicBrakeController = null;
            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new Interpolator2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(4);
                interp[DynamicBrakeSpeed1] = 0;
                interp[DynamicBrakeSpeed2] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        protected void ParseEffects(string lowercasetoken, STFReader stf)
        {
            stf.MustMatch("(");
            string s;

            while ((s = stf.ReadItem()) != ")")
            {
                ParticleEmitterData data = new ParticleEmitterData(stf);
                if (!EffectData.ContainsKey(s))
                {
                    EffectData.Add(s, new List<ParticleEmitterData>());
                }

                EffectData[s].Add(data);
            }
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            if (lowercasetoken.StartsWith("engine(trainbrakescontroller"))
                TrainBrakeController.ParseBrakeValue(lowercasetoken.Substring(28), stf);
            if (lowercasetoken.StartsWith("engine(enginebrakescontroller"))
                EngineBrakeController.ParseBrakeValue(lowercasetoken.Substring(29), stf);
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabview": CVFFileName = stf.ReadStringBlock(null); break;
                case "engine(maxpower": MaxPowerW = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforce": MaxForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxvelocity": MaxSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;

                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(brake_train": TrainBrakeController.Parse(stf); break;
                case "engine(enginecontrollers(brake_engine": EngineBrakeController.Parse(stf); break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(stf); break;

                //case "engine(enginecontrollers(combined_control": HasCombCtrl = true; break;
                //case "engine(enginecontrollers(combined_control": ParseCombData(lowercasetoken, stf); break;
                case "engine(vigilancemonitor": VigilanceMonitor = true; break;
                case "engine(enginecontrollers(combined_control": HasCombCtrl = true; if (!DynamicBrakeController.IsValid()) DynamicBrakeController = new MSTSNotchController(0, 1, .05f); break;

                case "engine(airbrakesmainresvolume": MainResVolumeFT3 = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(mainreschargingrate": MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(enginebrakereleaserate": EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(enginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakepipetimefactor": BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakeservicetimefactor": BrakeServiceTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakeemergencytimefactor": BrakeEmergencyTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakepipechargingrate": BrakePipeChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(maxtractiveforcecurves": TractiveForceCurves = new Interpolator2D(stf); break;
                case "engine(dynamicbrakeforcecurves": DynamicBrakeForceCurves = new Interpolator2D(stf); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(dynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true); break;
                case "engine(continuousforcetimefactor": ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(numwheels": NumWheels = stf.ReadFloatBlock(STFReader.UNITS.Any, null); if (NumWheels < 1) STFException.TraceWarning(stf, "NumWheels is less than 1, parts of the simulation may not function correctly"); break;
                case "engine(antislip": AntiSlip = stf.ReadBoolBlock(false); break;
                case "engine(engineoperatingprocedures": EngineOperatingProcedures = stf.ReadStringBlock(""); break;
                case "engine(headout": HeadOutViewpoints.Add(new ViewPoint() { Location = stf.ReadVector3Block(STFReader.UNITS.None, Vector3.Zero) }); break;
                case "engine(sanding": SanderSpeedOfMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, 30.0f); break;
                case "engine(orts(sanderspeedeffectupto": SanderSpeedEffectUpToMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(orts(powerondelay": PowerOnDelay = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(orts(emergencycausespowerdown": EmergencyCausesPowerDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(emergencycausesthrottledown": EmergencyCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(emergencyengageshorn": EmergencyEngagesHorn = stf.ReadBoolBlock(false); break;
                case "engine(orts(wheelslipcausesthrottledown": WheelslipCausesThrottleDown = stf.ReadBoolBlock(false); break;
                    

                default: base.Parse(lowercasetoken, stf); break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void InitializeFromCopy(MSTSWagon copy)
        {
            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CVFFile = locoCopy.CVFFile;
            CabFlipped = locoCopy.CabFlipped;
            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;
            NumWheels = locoCopy.NumWheels;
            AntiSlip = locoCopy.AntiSlip;
            EffectData = locoCopy.EffectData;
            SanderSpeedEffectUpToMpS = locoCopy.SanderSpeedEffectUpToMpS;
            SanderSpeedOfMpS = locoCopy.SanderSpeedOfMpS;
            PowerOnDelay = locoCopy.PowerOnDelay;

            EmergencyCausesPowerDown = locoCopy.EmergencyCausesPowerDown;
            EmergencyCausesThrottleDown = locoCopy.EmergencyCausesThrottleDown;
            EmergencyEngagesHorn = locoCopy.EmergencyEngagesHorn;

            WheelslipCausesThrottleDown = locoCopy.WheelslipCausesThrottleDown;

            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            TrainBrakeController = (MSTSBrakeController)locoCopy.TrainBrakeController.Clone();
            EngineBrakeController = locoCopy.EngineBrakeController != null ? (MSTSBrakeController)locoCopy.EngineBrakeController.Clone() : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;

            base.InitializeFromCopy(copy);  // each derived level initializes its own variables
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(Wiper);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorOn);
            outf.Write(AverageForceN);
            outf.Write(LocomotiveAxle.AxleSpeedMpS);
            outf.Write( CabLightOn );
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);            
            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            if (inf.ReadBoolean()) SignalEvent(EventID.BellOn);
            if (inf.ReadBoolean()) SignalEvent(EventID.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(EventID.WiperOn);
            MainResPressurePSI = inf.ReadSingle();
            CompressorOn = inf.ReadBoolean();
            AverageForceN = inf.ReadSingle();
            LocomotiveAxle.Reset(inf.ReadSingle());
            CabLightOn = inf.ReadBoolean();
            ThrottleController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            TrainBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            EngineBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            DynamicBrakeController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            AdhesionFilter.Reset(0.5f);
            
            base.Restore(inf);
        }

        private void ParseCombData(string lowercasetoken, STFReader stf)
        {
            HasCombCtrl = true;

            stf.MustMatch("(");
            string comboBrakeType = "train";
            string s;
            int i = 0;
            float value = 0.5f;

            while ((s = stf.ReadItem()) != ")")
            {
                if (i == 1)
                {
                    value = stf.ReadFloat(STFReader.UNITS.Any, null);
                    ComboCtrlCrossOver = (int)(value * 10);
                }
                if (comboBrakeType == s)
                    HasCombThrottleTrainBreak = true;
                i++;
            }

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    // cancel smooth dynamic control, keyboard hud display only
                    //HasDefectiveComboDynamicBreak = true;
                    HasSmoothStruc = true;
                    Trace.TraceInformation("Smooth Dynamic Brake may have inaccurate display");
                }
            }
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }


        /// <summary>
        /// Create a viewer for this locomotive.   Viewers are only attached
        /// while the locomotive is in viewing range.
        /// </summary>
        public override TrainCarViewer GetViewer(Viewer3D viewer)
        {
            return new MSTSLocomotiveViewer(viewer, this);
        }
        /// <summary>
        /// Sets controler settings from other engine for cab switch
        /// </summary>
        /// <param name="other"></param>
        public override void CopyControllerSettings(TrainCar other)
        {
            base.CopyControllerSettings(other);
            if (ThrottleController != null)
                ThrottleController.SetValue(other.ThrottlePercent / 100);
            if (DynamicBrakeController != null)
                DynamicBrakeController.SetValue(other.DynamicBrakePercent / 100);
            if (TrainBrakeController != null)
                TrainBrakeController.SetValue(0);
            if (EngineBrakeController != null)
                EngineBrakeController.SetValue(0);
        }

		public bool controlUpdated = false;
		public bool notificationReceived = false;

        /// <summary>
        /// This is a periodic update to calculate physics 
        /// parameters and update the base class's MotiveForceN 
        /// and FrictionForceN values based on throttle settings
        /// etc for the locomotive.
        /// </summary>
        public override void Update(float elapsedClockSeconds)
        {
            TrainBrakeController.Update(elapsedClockSeconds);
            if (TrainBrakeController.UpdateValue != 0.0)
            {
                Simulator.Confirmer.Message(CabControl.TrainBrake, GetTrainBrakeStatus());
            }

            if (EngineBrakeController != null)
                EngineBrakeController.Update(elapsedClockSeconds);

            if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0))
            {
                if (this.IsLeadLocomotive())
                    DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                else
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive())
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
            else
                ThrottleController.Update(elapsedClockSeconds);
#if INDIVIDUAL_CONTROL

			//this train is remote controlled, with mine as a helper, so I need to send the controlling information, but not the force.
			if (MultiPlayer.MPManager.IsMultiPlayer() && this.Train.TrainType == Train.TRAINTYPE.REMOTE && this == Program.Simulator.PlayerLocomotive)
			{
				//cannot control train brake as it is the remote's job to do so
				if ((EngineBrakeController != null && EngineBrakeController.UpdateValue != 0.0) || (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0) || ThrottleController.UpdateValue != 0.0)
				{
					controlUpdated = true;
				}
				ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
				if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0)) DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
				return; //done, will go back and send the message to the remote train controller
			}

			if (MultiPlayer.MPManager.IsMultiPlayer() && this.notificationReceived == true)
			{
				ThrottlePercent = ThrottleController.CurrentValue * 100.0f;
				this.notificationReceived = false;
			}
#endif
            // TODO  this is a wild simplification for electric and diesel electric
            float t = ThrottlePercent / 100f;
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float currentWheelSpeedMpS = Math.Abs(WheelSpeedMpS);
            //Only if a power is "ON" - pantograph up or diesel is running
            if (PowerOn)
            {
                if (TractiveForceCurves == null)
                {
                    float maxForceN = MaxForceN * t;
                    float maxPowerW = MaxPowerW * t * t;
                    if (!this.Simulator.UseAdvancedAdhesion)
                        currentWheelSpeedMpS = currentSpeedMpS;
                    if (maxForceN * currentWheelSpeedMpS > maxPowerW)
                        maxForceN = maxPowerW / currentWheelSpeedMpS;
                    if (currentSpeedMpS > MaxSpeedMpS)
                        maxForceN = 0;
                    MotiveForceN = maxForceN;
                }
                else
                {
                    MotiveForceN = TractiveForceCurves.Get(t, currentWheelSpeedMpS);
                    if (MotiveForceN < 0)
                        MotiveForceN = 0;
                }
            }


            if (MaxForceN > 0 && MaxContinuousForceN > 0)
            {
                MotiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN;
                float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * MotiveForceN;
            }

            if (this.IsLeadLocomotive())
            {
                switch (Direction)
                {
                    case Direction.Forward:
                        //MotiveForceN *= 1;     //Not necessary
                        break;
                    case Direction.Reverse:
                        MotiveForceN *= -1;
                        break;
                    case Direction.N:
                    default:
                        MotiveForceN *= 0;
                        break;
                }
            }
            else
            {
                int carCount = 0;
                int controlEngine = -1;

                // When not LeadLocomotive; check if lead is in Neutral
                // if so this loco will have no motive force
                var LeadLocomotive = Program.Simulator.PlayerLocomotive.Train;

                foreach (TrainCar car in LeadLocomotive.Cars)
                {
                    if (car.IsDriveable)
                        if (controlEngine == -1)
                        {
                            controlEngine = carCount;
                            if (car.Direction == Direction.N)
                                MotiveForceN *= 0;
                            else
                            {
                                switch (Direction)
                                {
                                    case Direction.Forward:
                                        MotiveForceN *= 1;     //Not necessary
                                        break;
                                    case Direction.Reverse:
                                        MotiveForceN *= -1;
                                        break;
                                    case Direction.N:
                                    default:
                                        MotiveForceN *= 0;
                                        break;
                                }
                            }
                        }
                    break;
                } // foreach
            } // end when not lead loco

            // Variable1 is wheel rotation in m/sec for steam locomotives
            //Variable2 = Math.Abs(MotiveForceN) / MaxForceN;   // force generated
            Variable1 = ThrottlePercent / 100f;   // throttle setting
            //Variable2 = Math.Abs(WheelSpeedMpS);
            Variable3 = DynamicBrakePercent / 100f;

            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null)
            {
                float f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, currentSpeedMpS);
                if (f > 0)
                    MotiveForceN -= (SpeedMpS > 0 ? 1 : -1) * f;
            }


            switch (this.Train.TrainType)
            {
                case Train.TRAINTYPE.AI:
                    if (!PowerOn)
                    {
                        PowerOn = true;
                        Pan = true;
                        AftPanUp = true;
                    }
                    break;
                case Train.TRAINTYPE.STATIC:
                    break;
                case Train.TRAINTYPE.PLAYER:
                case Train.TRAINTYPE.REMOTE:
                    // For notched throttle controls (e.g. Dash 9 found on Marias Pass) UpdateValue is always 0.0
                    if (ThrottleController.UpdateValue != 0.0)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                            ThrottleController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            ThrottleController.CurrentValue * 100);
                    }
                    LimitMotiveForce(elapsedClockSeconds);

                    if (WheelslipCausesThrottleDown && WheelSlip)
                        ThrottleController.SetValue(0.0f);
                    //Force to display
                    FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    break;
                default:
                    break;
                
            }          

            if (MainResPressurePSI < CompressorRestartPressurePSI && !CompressorOn)
                SignalEvent(EventID.CompressorOn);
            else if (MainResPressurePSI > MaxMainResPressurePSI && CompressorOn)
                SignalEvent(EventID.CompressorOff);
            if (CompressorOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;

            base.Update(elapsedClockSeconds);
        } // End Method Update

        /// <summary>
        /// Calls the Update method in the parent class MSTSWagon.
        /// </summary>
        /// <param name="elapsedClockSeconds"></param>
        protected void UpdateParent(float elapsedClockSeconds)
        {
            base.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public void LimitMotiveForce(float elapsedClockSeconds)
        {
            if (NumWheels <= 0)
                return;

            //Curtius-Kniffler computation for the basic model
            float currentSpeedMpS = Math.Abs(SpeedMpS);

            float max0 = 1.0f;  //Ahesion conditions [N]
            float max1 = MassKG * 9.81f * Adhesion2;

            if ((Simulator.UseAdvancedAdhesion)&&(!Simulator.Paused)&&(!AntiSlip))
            {
                //Set the weather coeff
                if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
                {
                    if (Train.SlipperySpotDistanceM < 0)
                    {
                        Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                        Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                    }
                    if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                        max0 = .8f;
                    if (Program.Simulator.Weather == WeatherType.Rain)
                        max0 = 0.6f;
                    else
                        max0 = 0.4f;
                }
                else
                    max0 = 1.0f;
                //add sander
                if (Math.Abs(SpeedMpS) < SanderSpeedOfMpS)
                {
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (Math.Abs(SpeedMpS) < SanderSpeedEffectUpToMpS))
                            max0 *= 2.0f - 1.0f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS);
                    }
                    else
                        if(Sander)
                            max0 *= 1.5f;
                }

                //Set adhesion coeff to the model
                    //Pure condition
                    //LocomotiveAxle.AdhesionConditions = max0;
                    //Filtered condition
                    //LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0, elapsedClockSeconds);
                //Filtered random condition
                LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0 + (float)(0.2*Program.Random.NextDouble()),elapsedClockSeconds);
                //LocomotiveAxle.AdhesionConditions = max0;
                //Set axle inertia (this should be placed within the ENG parser)
                // but make sure the value is sufficietn
                //if (MaxPowerW < 200000.0f)
                //{
                //    if (NumWheels > 4.0f)
                //        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheels * 4000.0f;
                //    else
                //        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                //}
                //else
                //{
                //    if (NumWheels > 4.0f)
                //        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheels * MaxPowerW / 500.0f;
                //    else
                //        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                //}

                //Compute axle inertia from parameters if possible
                if (AxleInertiaKgm2 > 10000.0f)
                {
                    LocomotiveAxle.InertiaKgm2 = AxleInertiaKgm2;
                }
                else
                {
                    if (WheelAxles.Count > 0 && DriverWheelRadiusM > 0)
                    {
                    float upperLimit = 2.0f * WheelAxles.Count * (15000.0f * DriverWheelRadiusM - 2900.0f);
                        upperLimit = upperLimit < 100.0f ? 100.0f : upperLimit;

                        float lowerLimit = WheelAxles.Count * (9000.0f * DriverWheelRadiusM - 1750.0f);
                        lowerLimit = lowerLimit < 100.0f ? 100.0f : lowerLimit;

                        LocomotiveAxle.InertiaKgm2 = (upperLimit - lowerLimit) / (5000000.0f) * MaxPowerW + lowerLimit;
                    }
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }
                //Limit the inertia to 40000 kgm2
                LocomotiveAxle.InertiaKgm2 = LocomotiveAxle.InertiaKgm2 > 40000.0f ? 40000.0f : LocomotiveAxle.InertiaKgm2;

                LocomotiveAxle.AxleRevolutionsInt.MinStep = LocomotiveAxle.InertiaKgm2 / MaxPowerW / 5.0f;
                

                //Set axle model parameters
                
                //LocomotiveAxle.BrakeForceN = FrictionForceN;
                LocomotiveAxle.BrakeForceN = BrakeForceN;
                LocomotiveAxle.AxleWeightN = 9.81f * MassKG;        //will be computed each time considering the tilting
                LocomotiveAxle.DriveForceN = MotiveForceN;           //Developed force
                LocomotiveAxle.TrainSpeedMpS = SpeedMpS;            //Set the train speed of the axle model

                LocomotiveAxle.Update(elapsedClockSeconds);         //Main updater of the axle model
                
                MotiveForceN = LocomotiveAxle.AxleForceN;           //Get the Axle force and use it for the motion
                WheelSlip = LocomotiveAxle.IsWheelSlip;             //Get the wheelslip indicator
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;
            }
            else
            {
                LimitMotiveForce();
            }
        }
        public void LimitMotiveForce()
        {
            if (NumWheels <= 0)
                return;
            //float max0 = MassKG * 9.8f * Adhesion3 / NumWheels;   //Not used

            //Curtius-Kniffler computation
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float uMax = (7.5f / (currentSpeedMpS * 3.6f + 44.0f) + 0.161f); // Curtius - Kniffler equation
            float adhesionUtil = 0.95f;   //Adhesion utilization

            float max0 = MassKG * 9.81f * adhesionUtil * uMax;  //Ahesion limit in [N]
            float max1;

            if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= .8f;
                if (Program.Simulator.Weather == WeatherType.Rain)
                    max0 *= .8f;
                else
                    max0 *= .7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = (Sander ? 1.5f : 1.0f) * max0; //Increase adhesion when sander is on
            WheelSlip = false;

            if (MotiveForceN > max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }
        }

        public override bool GetSanderOn()
        {
            return Sander;
        }

        public void SetDirection( Direction direction )
        {
            // Direction Control
            if ( Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                if (direction == Direction.Forward)
                {
                    SignalEvent(EventID.Forward);
                    Train.MUReverserPercent = 100;
                }
                else
                {
                    SignalEvent(EventID.Reverse);
                    Train.MUReverserPercent = -100;
                }
            }

            if (direction == Direction.N)
            {
                Program.Simulator.AI.Dispatcher.ReleasePlayerAuthorization();
            }
            else
            {
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization(false);
            }
        }

        public void StartReverseIncrease()
        {
            AlerterReset();
            if (this.IsLeadLocomotive())
            {
                {
                    switch( Direction ) {
                        case Direction.Reverse: SetDirection( Direction.N ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Neutral ); break;
                        case Direction.N: SetDirection( Direction.Forward ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.On ); break;
                        case Direction.Forward: SetDirection( Direction.Forward ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.On ); break;
                    }
                }
            }
        }

        public void StartReverseDecrease()
        {
            AlerterReset();
            if (this.IsLeadLocomotive())
            {
                {
                    switch( Direction )
                    {
                        case Direction.Reverse: SetDirection( Direction.Reverse ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Off ); break;
                        case Direction.N: SetDirection( Direction.Reverse ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Off ); break;
                        case Direction.Forward: SetDirection( Direction.N ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Neutral ); break;
                    }
                }
            }
        }

        public void StartThrottleIncrease()
        {
            AlerterReset();
            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return;

            if (HasCombCtrl && HasStepCtrl && !HasCombThrottleTrainBreak)
            {
                if ((DynamicBrakePercent == -1 || DynamicBrakePercent >= 0) && ThrottlePercent == 0)
                {
                    StartDynamicBrakeDecrease();
                    if (!HasSmoothStruc)
                        StopDynamicBrakeDecrease();
                }
                if (DynamicBrakePercent == -1)
                {
                    ThrottleController.StartIncrease();
                    ThrottleController.StopIncrease();
                    Simulator.Confirmer.ConfirmWithPerCent( CabControl.Throttle, ThrottleController.CurrentValue * 100 );
                }
            } else if( !HasCombCtrl && HasStepCtrl ) {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
                Simulator.Confirmer.ConfirmWithPerCent( CabControl.Throttle, ThrottleController.CurrentValue * 100 );
                //SignalEvent( EventID.Reverse );
            } else {
                ThrottleController.StartIncrease();
                Simulator.Confirmer.ConfirmWithPerCent( CabControl.Regulator, CabSetting.Increase, ThrottleController.CurrentValue * 100 );
            }
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.PowerHandler);
        }

        public void StopThrottleIncrease()
        {
            AlerterReset();
            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return;
            ThrottleController.StopIncrease();

            if (HasCombCtrl && HasStepCtrl && !HasCombThrottleTrainBreak)
            {
                if ((DynamicBrakePercent == -1 || DynamicBrakePercent >= 0) && ThrottlePercent == 0)
                {

                    StopDynamicBrakeIncrease();
                }
            }
        }

        public void StartThrottleDecrease()
        {
            AlerterReset();
            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return;

            if (HasCombCtrl && HasStepCtrl && !HasCombThrottleTrainBreak)
            {
                if ((DynamicBrakePercent == -1 || DynamicBrakePercent >= 0) && ThrottlePercent == 0)
                {

                        StartDynamicBrakeIncrease();
                        if (!HasSmoothStruc)
                            StopDynamicBrakeIncrease();
                }
                if (DynamicBrakePercent == -1)
                {
                    ThrottleController.StartDecrease();
                    ThrottleController.StopDecrease();
                    Simulator.Confirmer.ConfirmWithPerCent( CabControl.Throttle, ThrottleController.CurrentValue * 100 );
                }
            } else if( !HasCombCtrl && HasStepCtrl ) {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
                Simulator.Confirmer.ConfirmWithPerCent( CabControl.Throttle, ThrottleController.CurrentValue * 100 );
                //SignalEvent( EventID.Reverse );
            } else {
                ThrottleController.StartDecrease();
                Simulator.Confirmer.ConfirmWithPerCent( CabControl.Regulator, CabSetting.Decrease, ThrottleController.CurrentValue * 100 );
            }
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.PowerHandler);
        }

        public void StopThrottleDecrease()
        {
            AlerterReset();

            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return;

            ThrottleController.StopDecrease();

            if (HasCombCtrl && HasStepCtrl && !HasCombThrottleTrainBreak)
            {
                if ((DynamicBrakePercent == -1 || DynamicBrakePercent >= 0) && ThrottlePercent == 0)
                {

                    StopDynamicBrakeIncrease();
                }
            }
        }

        public void SetThrottlePercent(float percent)
        {
            ThrottlePercent = ThrottleController.SetRDPercent(percent);
        }

        public void StartTrainBrakeIncrease()
        {
            AlerterReset();
            Simulator.Confirmer.Confirm( CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus() );
            TrainBrakeController.StartIncrease();
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.TrainBrakeSet);
        }

        public void StopTrainBrakeIncrease()
        {
            AlerterReset();
            TrainBrakeController.StopIncrease();
        }

        public void StartTrainBrakeDecrease()
        {
            AlerterReset();
            Simulator.Confirmer.Confirm( CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus() );
            TrainBrakeController.StartDecrease();
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.TrainBrakeSet);
        }

        public void StopTrainBrakeDecrease()
        {
            AlerterReset();
            TrainBrakeController.StopDecrease();
        }

        public void SetTrainBrakePercent(float percent)
        {
            TrainBrakeController.SetRDPercent(percent);
        }

        public void SetEmergency()
        {
            if (TrainBrakeController.GetIsEmergency())
                return;
            if(EmergencyCausesThrottleDown) ThrottleController.SetValue(0.0f);
            if (EmergencyCausesPowerDown) { SignalEvent(EventID.Pantograph1Down); SignalEvent(EventID.Pantograph2Down); }
            if (EmergencyEngagesHorn) SignalEvent(EventID.HornOn);
            TrainBrakeController.SetEmergency();
            SignalEvent(EventID.TrainBrakeEmergency);
        }

        public override string GetTrainBrakeStatus()
        {            
            string s = TrainBrakeController.GetStatus();
            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetFullStatus(lastCar.BrakeSystem);
            return s;
        }

        public void StartEngineBrakeIncrease()
        {
            AlerterReset();
            if (EngineBrakeController == null)
                return;
            Simulator.Confirmer.Confirm( CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus() );
            EngineBrakeController.StartIncrease();
        }

        public void StopEngineBrakeIncrease()
        {
            AlerterReset();
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.StopIncrease();
        }

        public void StartEngineBrakeDecrease()
        {
            AlerterReset();
            if (EngineBrakeController == null)
                return;
            Simulator.Confirmer.Confirm( CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus() );
            EngineBrakeController.StartDecrease();
        }

        public void StopEngineBrakeDecrease()
        {
            AlerterReset();
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.StopDecrease();
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetRDPercent(percent);
        }
  
        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");
        }

        public void SetBailOff(bool bailOff)
        {
            BailOff = bailOff;
        }

        private bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null && DynamicBrakeForceCurves != null
                && ThrottlePercent == 0 && !HasDefectiveComboDynamicBreak);
        }

        public void StartDynamicBrakeIncrease()
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;
            

            if (DynamicBrakePercent < 0)
            {
                //activate it
                DynamicBrakePercent = 0;
                return;
            }
            else
            {
                DynamicBrakeController.StartIncrease();
                if (!HasSmoothStruc)
                    StopDynamicBrakeIncrease();
            }
        }

        public void StopDynamicBrakeIncrease()
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakeController.StopIncrease();
            Simulator.Confirmer.Message(CabControl.DynamicBrake, GetDynamicBrakeStatus());
        }

        public void StartDynamicBrakeDecrease()
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0)
                DynamicBrakePercent = -1;
            else
            {
                DynamicBrakeController.StartDecrease();
                if (!HasSmoothStruc)
                    StopDynamicBrakeDecrease();
            }
        }

        public void StopDynamicBrakeDecrease()
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakeController.StopDecrease();
            Simulator.Confirmer.Message(CabControl.DynamicBrake, GetDynamicBrakeStatus());
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakePercent = DynamicBrakeController.SetRDPercent(percent);
            if (percent < 0)
                DynamicBrakePercent = percent;
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            if (DynamicBrakePercent < 0)
                return string.Empty;
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }
        public override bool GetCabFlipped()
        {
            return CabFlipped;
        }

        public class Alerter
        {
            int AlerterStartTime;
            int AlerterAlarmTime;
            public bool AlerterIsEnabled = false;
            public bool AlerterResetReceived = false;

            public void AlerterEnableSetup(int alarmStart, int alarmEnd)
            {
                AlerterStartTime = alarmStart;
                AlerterAlarmTime = alarmEnd;
            }

            public void AlerterEnableSet()
            {
                AlerterIsEnabled = true;
            }

            public void AlerterDisAble()
            {
                AlerterIsEnabled = false;
            }

            public void AlerterReset()
            {
                if (AlerterResetReceived)
                    AlerterResetReceived = false;
                else
                    AlerterResetReceived = true;
            }
            
            public bool AlerterTimerTrigger(int clockTime)
            {
                if (AlerterIsEnabled && clockTime >= AlerterAlarmTime)
                    return true;
                else
                    return false;
            }
        } //End Class Alerter

        Alerter timerAlerter1 = new Alerter();
        Alerter timerAlerter2 = new Alerter();
        //bool alarm1Fired = false;
        //bool alarm2Fired = false;

        public void AlerterStartUp()
        {
            AlerterEnableGetTime();
            timerAlerter1.AlerterEnableSet();
            timerAlerter2.AlerterEnableSet();
            AlerterIsActive = true;
        }

        public void AlerterEnableGetTime()
        {
            int startTime = (int)Simulator.ClockTime;
            int alterterAlarm = startTime + 30;
            int penaltyAlarm = startTime + 49;
            timerAlerter1.AlerterEnableSetup(startTime, alterterAlarm);
            timerAlerter2.AlerterEnableSetup(startTime, penaltyAlarm);
            //SignalEvent(EventID.AlerterSndOff);
        }

        public void AlerterReset()
        {
            if (AlerterIsActive)
            {
                AlerterEnableGetTime();
            }
        }

        public void AlerterResetExternal()
        {
            timerAlerter1.AlerterReset();
            timerAlerter2.AlerterReset();
            AlerterEnableGetTime();
        }

        /// <summary>
        /// Used when someone want to notify us of an event
        /// </summary>
        public override void SignalEvent(EventID eventID)
        {
            do  // Like 'switch' (i.e. using 'break' is more efficient than a sequence of 'if's) but doesn't need constant EventID.<values>
            {
                if( eventID == EventID.AlerterSndOn ) { AlerterSnd = true; Simulator.Confirmer.Confirm( CabControl.Alerter, CabSetting.On ); break; }
                if( eventID == EventID.AlerterSndOff ) { AlerterSnd = false; Simulator.Confirmer.Confirm( CabControl.Alerter, CabSetting.Off ); break; }
                if( eventID == EventID.BellOn ) { Bell = true; Simulator.Confirmer.Confirm( CabControl.Bell, CabSetting.On ); break; }
                if( eventID == EventID.BellOff ) { Bell = false; Simulator.Confirmer.Confirm( CabControl.Bell, CabSetting.Off ); break; }
                if( eventID == EventID.HornOn ) {
                    Horn = true;
                    if( this != Program.Simulator.PlayerLocomotive ) break;
                    if( this is MSTSSteamLocomotive ) {
                        Simulator.Confirmer.Confirm( CabControl.Whistle, CabSetting.On );
                    } else {
                        Simulator.Confirmer.Confirm( CabControl.Horn, CabSetting.On );
                    }
                    break;
                }
                if( eventID == EventID.HornOff ) {
                    Horn = false;
                    if( this != Program.Simulator.PlayerLocomotive ) break;
                    if( this is MSTSSteamLocomotive ) {
                        Simulator.Confirmer.Confirm( CabControl.Whistle, CabSetting.Off );
                    } else {
                        Simulator.Confirmer.Confirm( CabControl.Horn, CabSetting.Off );
                    }
                    break;
                }
                if( eventID == EventID.SanderOn ) { Sander = true; if( this.IsLeadLocomotive() ) Simulator.Confirmer.Confirm( CabControl.Sander, CabSetting.On ); break; }
                if( eventID == EventID.SanderOff ) { Sander = false; if( this.IsLeadLocomotive() ) Simulator.Confirmer.Confirm( CabControl.Sander, CabSetting.Off ); break; }
                if( eventID == EventID.WiperOn ) { Wiper = true; if( this == Program.Simulator.PlayerLocomotive ) Simulator.Confirmer.Confirm( CabControl.Wipers, CabSetting.On ); break; }
                if( eventID == EventID.WiperOff ) { Wiper = false; if( this == Program.Simulator.PlayerLocomotive )  Simulator.Confirmer.Confirm( CabControl.Wipers, CabSetting.Off ); break; }

                // <CJ Comment> The "H" key doesn't call these SignalEvents yet. </CJ Comment>
                if( eventID == EventID.HeadlightOff ) { Headlight = 0; break; }
                if( eventID == EventID.HeadlightDim ) { Headlight = 1; break; }
                if( eventID == EventID.HeadlightOn ) { Headlight = 2; break; }

                if( eventID == EventID.CompressorOn ) { CompressorOn = true; break; }
                if( eventID == EventID.CompressorOff ) { CompressorOn = false; break; }
                if( eventID == EventID.ResetWheelSlip ) { LocomotiveAxle.Reset( SpeedMpS ); ThrottleController.SetValue( 0.0f ); break; }
			} while (false);  // Never repeats

            base.SignalEvent(eventID );
        }

        /// <summary>
        /// Gets the Locomotive data needed by the Cab View Control
        /// Check here for Signal display
        /// </summary>
        /// <param name="cvc">The Cab View Control</param>
        /// <returns>The data converted to the requested unit</returns>
        /// 

        public void CheckVigilance()
        {

            {
                bool alarm1Fired = false;
                bool alarm2Fired = false;

                if (timerAlerter1.AlerterIsEnabled)
                {
                    if (timerAlerter1.AlerterTimerTrigger((int)Simulator.ClockTime))
                        alarm1Fired = true;
                    //SignalEvent(EventID.AlerterOn);
                }

                if (timerAlerter2.AlerterIsEnabled)
                {
                    if (timerAlerter2.AlerterTimerTrigger((int)Simulator.ClockTime))
                    {
                        alarm2Fired = true;
                        SetEmergency();
                    }
                }

                if (alarm1Fired)
                {
                    if( ! AlerterSnd ) {
                        SignalEvent( EventID.AlerterSndOn );
                    }
                }
                else
                {
                    if( AlerterSnd ) {
                        SignalEvent( EventID.AlerterSndOff );
                    }
                }
            }
        }

        public virtual float GetDataOf(CabViewControl cvc)
        {
            if( Simulator.Settings.Alerter ) CheckVigilance();
            float data = 0;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        //data = SpeedMpS;
                        if (Simulator.UseAdvancedAdhesion && (!AntiSlip))
                            data = WheelSpeedMpS;
                        else
                            data = SpeedMpS;

                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.AMMETER:
                case CABViewControlTypes.LOAD_METER:
                case CABViewControlTypes.TRACTION_BRAKING:
                    {
                        if (LocomotiveAxle != null)
                        {
                            data = 0.0f;
                            if (ThrottlePercent > 0)
                            {
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxForceN * (float)cvc.MaxValue;
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxForceN * (float)cvc.MaxValue;
                                data = Math.Abs(data);
                            }
                            if (DynamicBrakePercent > 0)
                            {
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxDynamicBrakeForceN * (float)cvc.MaxValue;
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxDynamicBrakeForceN * (float)cvc.MaxValue;
                                data = -Math.Abs(data);
                            }
                            break;
                        }
                        data = this.MotiveForceN / MaxForceN * (float)cvc.MaxValue;
                        break;
                    }
                //case CABViewControlTypes.LOAD_METER:
                //    {
                //        if (LocomotiveAxle != null)
                //        {
                //            if (FilteredMotiveForceN != 0)
                //                data = this.FilteredMotiveForceN / MaxForceN * (float)cvc.MaxValue;
                //            else
                //                data = this.LocomotiveAxle.AxleForceN / MaxForceN * (float)cvc.MaxValue;
                //            break;
                //        }
                //        data = this.MotiveForceN / MaxForceN * (float)cvc.MaxValue;
                //        break;
                //    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = this.MainResPressurePSI;
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                case CABViewControlTypes.EQ_RES:
                    {
                        data = this.BrakeSystem.BrakeLine1PressurePSI;
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        data = BrakeSystem.GetCylPressurePSI();
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.RPM:
                    {
                        if (((MSTSDieselLocomotive)this).EngineRPM != null)
                            data = ((MSTSDieselLocomotive)this).EngineRPM;
                        break;
                    }
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                case CABViewControlTypes.CPH_DISPLAY:
                    {
                        data = ThrottlePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        data = (EngineBrakeController == null) ? 0.0f : EngineBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.FRICTION_BRAKING:
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        data = (TrainBrakeController == null) ? 0.0f : TrainBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                //case CABViewControlTypes.CP_HANDLE:
                    {
                        data = DynamicBrakePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        data = Wiper ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HORN:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.RESET:
                    {
                        if (timerAlerter1.AlerterResetReceived)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
 
                case CABViewControlTypes.ALERTER_DISPLAY:
                    {
                        if( Simulator.Settings.Alerter ) {
                            bool alarm1Fired = false;
                            bool alarm2Fired = false;

                            if (timerAlerter1.AlerterIsEnabled)
                            {
                                if (timerAlerter1.AlerterTimerTrigger((int)Simulator.ClockTime))
                                    alarm1Fired = true;
                            }

                            if (timerAlerter2.AlerterIsEnabled)
                            {
                                if (timerAlerter2.AlerterTimerTrigger((int)Simulator.ClockTime))
                                {
                                    alarm2Fired = true;
                                }
                            }

                            if (alarm1Fired)
                            {
                                data = 1;
                                if( ! AlerterSnd ) {
                                    SignalEvent( EventID.AlerterSndOn );
                                }
                            }
                            else if (alarm2Fired)
                                data = 2;
                            else
                            {
                                data = 0;
                                if( AlerterSnd ) {
                                    SignalEvent( EventID.AlerterSndOff );
                                }
                            }
                        }
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.CLOCK:
                    {
                        data = 0;
                        break;
                    }

                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        data = Headlight;
                        break;
                    }
                case CABViewControlTypes.WHEELSLIP:
                    {
                        data = LocomotiveAxle.IsWheelSlipWarning ? 1 : 0;
                        break;
                    }
    
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        if (Direction == Direction.Forward)
                            data = 2;
                        else if (Direction == Direction.Reverse)
                            data = 0;
                        else
                            data = 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (Train.CABAspect)
                        {
                            case SignalHead.SIGASP.STOP:
                                {
                                    data = 0;
                                    break;
                                }
                            case SignalHead.SIGASP.STOP_AND_PROCEED:
                                {
                                    data = 1;
                                    break;
                                }
                            case SignalHead.SIGASP.RESTRICTING:
                                {
                                    data = 2;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_1:
                                {
                                    data = 3;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_2:
                                {
                                    data = 4;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_3:
                                {
                                    data = 5;
                                    break;
                                }
                            case SignalHead.SIGASP.CLEAR_1:
                            case SignalHead.SIGASP.CLEAR_2:
                                {
                                    data = 6;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                case CABViewControlTypes.SPEEDLIM_DISPLAY:
                    {
                        data = 0;
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        if (this.Train != null && this.Train.SignalObjectItems != null)
                        foreach(ObjectItemInfo oi in this.Train.SignalObjectItems)
                        {
                            if (this.Train.CABAspect == SignalHead.SIGASP.STOP ||
                                this.Train.CABAspect == SignalHead.SIGASP.STOP_AND_PROCEED)
                            {
                                data = 0;
                                break;
                            }
                            if (oi.ObjectType == ObjectItemInfo.ObjectItemType.SPEEDLIMIT)
                            {
                                continue;
                            }
                            if (oi.speed_passenger == -1)
                            {
                                data = MpS.FromMpS(this.Train.RouteMaxSpeedMpS, metric);
                                break;
                            }
                            else
                            {
                                data = MpS.FromMpS(oi.speed_passenger, metric);
                                break;
                            }
                        }
                        break;
                    }
                default:
                    {
                        data = 0;
                        break;
                    }
            }
            return data;
        }

    } // End Class MSTSLocomotive

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    [ORTSPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        [ORTSPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        public Vector4 Light1Position;

        [ORTSPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        public Color Light1Color;

        [ORTSPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        public Vector4 Light2Position;

        [ORTSPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        public Color Light2Color;

    } // End Class ExtendedCVF

    ///////////////////////////////////////////////////
    ///   3D VIEW
    ///////////////////////////////////////////////////

    /// <summary>
    /// Adds animation for wipers to the basic TrainCar
    /// </summary>
    public class MSTSLocomotiveViewer : MSTSWagonViewer
    {
        MSTSLocomotive Locomotive;

        protected Dictionary<string, List<ParticleEmitterDrawer>> ParticleDrawers = new Dictionary<string, List<ParticleEmitterDrawer>>();
        List<int> WiperPartIndexes = new List<int>();

        float WiperAnimationKey = 0;

        protected MSTSLocomotive MSTSLocomotive { get { return (MSTSLocomotive)Car; } }

        private bool _hasCabRenderer = false;
        private CabRenderer _CabRenderer = null;

        public MSTSLocomotiveViewer(Viewer3D viewer, MSTSLocomotive car)
            : base(viewer, car)
        {
            Locomotive = car;

            foreach (KeyValuePair<string, List<ParticleEmitterData>> pair in Locomotive.EffectData)
            {
                ParticleDrawers.Add(pair.Key, new List<ParticleEmitterDrawer>());

                foreach (ParticleEmitterData data in pair.Value)
                {
                    ParticleDrawers[pair.Key].Add(new ParticleEmitterDrawer(viewer, data));
                }                
            }

            //if (car.CVFFile != null && car.CVFFile.TwoDViews.Count > 0)
            //    _CabRenderer = new CabRenderer(viewer, Locomotive);

            // Find the animated parts
            if (TrainCarShape.SharedShape.Animations != null)
            {
				for (int iMatrix = 0; iMatrix < TrainCarShape.SharedShape.MatrixNames.Count; ++iMatrix)
                {
                    string matrixName = TrainCarShape.SharedShape.MatrixNames[iMatrix].ToUpper();
                    switch (matrixName)
                    {
                        case "WIPERARMLEFT1":
                        case "WIPERBLADELEFT1":
                        case "WIPERARMRIGHT1":
                        case "WIPERBLADERIGHT1":
                            if (TrainCarShape.SharedShape.Animations[0].FrameCount > 1)  // ensure shape file is properly animated for wipers
                                WiperPartIndexes.Add(iMatrix);
                            break;
                        case "MIRRORARMLEFT1":
                        case "MIRRORLEFT1":
                        case "MIRRORARMRIGHT1":
                        case "MIRRORRIGHT1":
                            // TODO
                            break;
                    }
                }
            }

            string wagonFolderSlash = Path.GetDirectoryName(Locomotive.WagFilePath) + "\\";
            if (Locomotive.CabSoundFileName != null) LoadCarSound(wagonFolderSlash, Locomotive.CabSoundFileName);

        }

        bool SwapControl()
        {
            if (Locomotive.HasCombThrottleTrainBreak)
                return true;
            else
                return false;
        }

        void StartThrottleIncrease()
        {
            if (!SwapControl()) // tests for CombThrottleTrainBreak
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn );
                    return; 
                } else
                    Locomotive.StartThrottleIncrease();
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                //if (trainBreakPercent > 0)
                if (throttlePercent == 0 && trainBreakPercent > 0)
                {
                    Locomotive.StartTrainBrakeDecrease();
                    Locomotive.StopThrottleIncrease();
                }
            }
        }

        void StopThrottleIncrease()
        {
            if (!SwapControl()) // tests for CombThrottleTrainBreak
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn );
                    return;
                } else
                    Locomotive.StopThrottleIncrease();
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                if (throttlePercent == 0 && trainBreakPercent > 0)
                {
                    Locomotive.StopTrainBrakeDecrease();
                }
                else
                {
                    Locomotive.StartThrottleIncrease();
                    Locomotive.StopThrottleIncrease();
                }
            }
        }

        void StartThrottleDecrease()
        {
            if (!SwapControl())
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn );
                    return;
                } else
                    Locomotive.StartThrottleDecrease();
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                if (throttlePercent == 0 && trainBreakPercent >= 0)
                {
                    Locomotive.StartTrainBrakeIncrease();
                    Locomotive.StopThrottleDecrease();
                }
                else
                    Locomotive.StartThrottleDecrease();
            }
        }

        void StopThrottleDecrease()
        {
            if (!SwapControl()) // tests for CombThrottleTrainBrea
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn );
                    return;
                } else
                    Locomotive.StopThrottleDecrease();
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                if (throttlePercent == 0 && trainBreakPercent >= 0)
                    Locomotive.StopTrainBrakeIncrease();
            }
        }

        protected virtual void ReverserControlForwards()
        {
            if( Locomotive.Direction != Direction.Forward ) {
                if( Locomotive.ThrottlePercent < 1 )
                    Locomotive.StartReverseIncrease();
                else
                    Viewer.Simulator.Confirmer.Warning( CabControl.Reverser, CabSetting.Warn );
            } else {
                Locomotive.StartReverseIncrease();
            }
        }

        protected virtual void ReverserControlBackwards()
        {
            if( Locomotive.Direction != Direction.Reverse ) {
                if( Locomotive.ThrottlePercent < 1 )
                    Locomotive.StartReverseDecrease();
                else
                    Viewer.Simulator.Confirmer.Warning( CabControl.Reverser, CabSetting.Warn );
            } else {
                Locomotive.StartReverseDecrease();
            }
        }

        /// <summary>
        /// A keyboard or mouse click has occurred. Read the UserInput
        /// structure to determine what was pressed.
        /// </summary>
        public override void HandleUserInput(ElapsedTime elapsedTime)
        {
            if (UserInput.IsPressed(UserCommands.ControlForwards)) ReverserControlForwards();
            if (UserInput.IsPressed(UserCommands.ControlBackwards)) ReverserControlBackwards();

            if (UserInput.IsPressed(UserCommands.ControlThrottleIncrease)) StartThrottleIncrease();
            if (UserInput.IsReleased(UserCommands.ControlThrottleIncrease)) StopThrottleIncrease();
            if (UserInput.IsPressed(UserCommands.ControlThrottleDecrease)) StartThrottleDecrease();
            if (UserInput.IsReleased(UserCommands.ControlThrottleDecrease)) StopThrottleDecrease();

			if (UserInput.IsPressed(UserCommands.ControlTrainBrakeIncrease)) Locomotive.StartTrainBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlTrainBrakeIncrease)) Locomotive.StopTrainBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlTrainBrakeDecrease)) Locomotive.StartTrainBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlTrainBrakeDecrease)) Locomotive.StopTrainBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlEngineBrakeIncrease)) Locomotive.StartEngineBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlEngineBrakeIncrease)) Locomotive.StopEngineBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlEngineBrakeDecrease)) Locomotive.StartEngineBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlEngineBrakeDecrease)) Locomotive.StopEngineBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlDynamicBrakeIncrease)) Locomotive.StartDynamicBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlDynamicBrakeIncrease)) Locomotive.StopDynamicBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlDynamicBrakeDecrease)) Locomotive.StartDynamicBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlDynamicBrakeDecrease)) Locomotive.StopDynamicBrakeDecrease();

            if( UserInput.IsPressed( UserCommands.ControlBailOff ) ) {
                // <CJ Comment> Don't see why this is coded differently from Horn, Bell or Retainers </CJ Comment>
                Locomotive.SetBailOff( true );
                Viewer.Simulator.Confirmer.Confirm( CabControl.BailOff, CabSetting.On );
            }
            if( UserInput.IsReleased( UserCommands.ControlBailOff ) ) {
                Locomotive.SetBailOff( false );
                Viewer.Simulator.Confirmer.Confirm( CabControl.BailOff, CabSetting.Off );
            }

			if (UserInput.IsPressed(UserCommands.ControlInitializeBrakes)) Locomotive.Train.InitializeBrakes();
            if( UserInput.IsPressed( UserCommands.ControlHandbrakeNone ) ) {
                Locomotive.Train.SetHandbrakePercent( 0 );
                Viewer.Simulator.Confirmer.Confirm( CabControl.Handbrake,  CabSetting.Off );
            }
			if (UserInput.IsPressed(UserCommands.ControlHandbrakeFull)) {
                Locomotive.Train.SetHandbrakePercent(100);
                Viewer.Simulator.Confirmer.Confirm( CabControl.Handbrake, CabSetting.On );
            }
            if( UserInput.IsPressed( UserCommands.ControlRetainersOff ) ) {
                Locomotive.Train.SetRetainers( false );
                Viewer.Simulator.Confirmer.Confirm( CabControl.Retainers, CabSetting.Off );
            }
			if (UserInput.IsPressed(UserCommands.ControlRetainersOn)) {
                Locomotive.Train.SetRetainers(true);
                Viewer.Simulator.Confirmer.ConfirmWithPerCent( CabControl.Retainers, CabSetting.Increase, Locomotive.Train.RetainerPercent, (int)CabSetting.Range1 + (int)Locomotive.Train.RetainerSetting );
                //Viewer.Simulator.Confirmer.ConfirmWithPerCent( CabControl.Retainers, CabSetting.Increase, Locomotive.Train.RetainerPercent );
            }
			if (UserInput.IsPressed(UserCommands.ControlBrakeHoseConnect)) {
                Locomotive.Train.ConnectBrakeHoses();
                Viewer.Simulator.Confirmer.Confirm( CabControl.BrakeHose, CabSetting.On );
            }
            if( UserInput.IsPressed( UserCommands.ControlBrakeHoseDisconnect ) ) {
                Locomotive.Train.DisconnectBrakes();
                Viewer.Simulator.Confirmer.Confirm( CabControl.BrakeHose, CabSetting.Off );
            }
            if( UserInput.IsPressed( UserCommands.ControlEmergency ) ) {
                Locomotive.SetEmergency();
                Viewer.Simulator.Confirmer.Confirm( CabControl.EmergencyBrake, CabSetting.On );
            }

            // <CJ Comment> Some inputs calls their method directly, other via a SignalEvent. 
            // Probably because a signal can then be handled more than once, 
            // e.g. by every locomotive on the train or every car in the consist.
            // The signals are distributed through the parent class MSTSWagon:SignalEvent </CJ Comment>
			if (UserInput.IsPressed(UserCommands.ControlSander)) Locomotive.Train.SignalEvent(Locomotive.Sander ? EventID.SanderOff : EventID.SanderOn);
			if (UserInput.IsPressed(UserCommands.ControlWiper)) Locomotive.SignalEvent(Locomotive.Wiper ? EventID.WiperOff : EventID.WiperOn);
			if (UserInput.IsPressed(UserCommands.ControlHorn)) Locomotive.SignalEvent(EventID.HornOn);
			if (UserInput.IsReleased(UserCommands.ControlHorn)) Locomotive.SignalEvent(EventID.HornOff);
            if( UserInput.IsPressed( UserCommands.ControlBell ) ) Locomotive.SignalEvent( Locomotive.Bell ? EventID.BellOff : EventID.BellOn );

            if (UserInput.IsPressed(UserCommands.ControlAlerter)) Locomotive.AlerterResetExternal();        // z
            //<CJ Comment> Why reset on both press and release? Disabled. </CJ Comment>
            //if (UserInput.IsReleased(UserCommands.ControlAlerter)) Locomotive.AlerterResetExternal();       //z


			if (UserInput.IsPressed(UserCommands.ControlHeadlightDecrease))
            {
                switch ((Locomotive.Headlight))
                {
                    case 1: Locomotive.Headlight = 0; Program.Simulator.Confirmer.Confirm( CabControl.Headlight, CabSetting.Off ); break;
                    case 2: Locomotive.Headlight = 1; Program.Simulator.Confirmer.Confirm( CabControl.Headlight, CabSetting.Neutral ); break;
                }
                // By GeorgeS
                if (EventID.IsMSTSBin)
                     Locomotive.SignalEvent(EventID.LightSwitchToggle);
            }
			else if (UserInput.IsPressed(UserCommands.ControlHeadlightIncrease))
            {
                switch ((Locomotive.Headlight))
                {
                    case 0: Locomotive.Headlight = 1; Program.Simulator.Confirmer.Confirm( CabControl.Headlight, CabSetting.Neutral ); break;
                    case 1: Locomotive.Headlight = 2; Program.Simulator.Confirmer.Confirm( CabControl.Headlight, CabSetting.On ); break;
                }
                // By GeorgeS
                if (EventID.IsMSTSBin)
                    Locomotive.SignalEvent(EventID.LightSwitchToggle);
            }
            if (UserInput.IsPressed(UserCommands.DebugForcePlayerAuthorization))
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization(true);

            // By GeorgeS
            if (UserInput.IsPressed(UserCommands.ControlLight)) { 
                Locomotive.CabLightOn = !Locomotive.CabLightOn;     // Changes the light in the cab
                Locomotive.SignalEvent(EventID.LightSwitchToggle);  // Makes a switching sound ?
            }
            if (UserInput.IsPressed(UserCommands.CameraToggleShowCab)) Locomotive.ShowCab = !Locomotive.ShowCab;

            // By Matej Pacha
            if (UserInput.IsPressed(UserCommands.DebugResetWheelSlip)) { Locomotive.Train.SignalEvent(EventID.ResetWheelSlip); }
            if (UserInput.IsPressed(UserCommands.DebugToggleAdvancedAdhesion)) { Locomotive.Train.SignalEvent(EventID.ResetWheelSlip); Locomotive.Simulator.UseAdvancedAdhesion = !Locomotive.Simulator.UseAdvancedAdhesion; }


            if (UserInput.RDState != null)
            {
                if (UserInput.RDState.BailOff) {
                    Locomotive.SetBailOff(true);
                    Viewer.Simulator.Confirmer.Confirm( CabControl.BailOff, CabSetting.On );
                }   
                if (UserInput.RDState.Changed)
                {
                    Locomotive.SetThrottlePercent(UserInput.RDState.ThrottlePercent);
                    Locomotive.SetTrainBrakePercent(UserInput.RDState.TrainBrakePercent);
                    Locomotive.SetEngineBrakePercent(UserInput.RDState.EngineBrakePercent);
                    Locomotive.SetDynamicBrakePercent(UserInput.RDState.DynamicBrakePercent);
                    if (UserInput.RDState.DirectionPercent > 50)
                        Locomotive.SetDirection(Direction.Forward);
                    else if (UserInput.RDState.DirectionPercent < -50)
                        Locomotive.SetDirection(Direction.Reverse);
                    else
                        Locomotive.SetDirection(Direction.N);
                    if( UserInput.RDState.Emergency ) {
                        Locomotive.SetEmergency();
                        Viewer.Simulator.Confirmer.Confirm( CabControl.EmergencyBrake, CabSetting.On );
                    }
                    if (UserInput.RDState.Wipers == 1 && Locomotive.Wiper)
                        Locomotive.SignalEvent(EventID.WiperOff);
                    if (UserInput.RDState.Wipers != 1 && !Locomotive.Wiper)
                        Locomotive.SignalEvent(EventID.WiperOn);
                    // changing Headlight more than one step at a time doesn't work for some reason
                    if (Locomotive.Headlight < UserInput.RDState.Lights - 1)
                        Locomotive.Headlight++;
                    if (Locomotive.Headlight > UserInput.RDState.Lights - 1)
                        Locomotive.Headlight--;
                }
            }

			base.HandleUserInput(elapsedTime);
        }

        /// <summary>
        /// We are about to display a video frame.  Calculate positions for 
        /// animated objects, and add their primitives to the RenderFrame list.
        /// </summary>
        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
        {
            float elapsedClockSeconds = elapsedTime.ClockSeconds;

            foreach (List<ParticleEmitterDrawer> drawers in ParticleDrawers.Values)
            {
                foreach (ParticleEmitterDrawer drawer in drawers)
                {
                    drawer.WorldPosition = Locomotive.WorldPosition;
                    drawer.PrepareFrame(frame, elapsedTime);
                }
            }

            // Wiper animation
            if (WiperPartIndexes.Count > 0)  // skip this if there are no wipers
            {
                if (Locomotive.Wiper) // on
                {
                    // Wiper Animation
                    // Compute the animation key based on framerate etc
                    // ie, with 8 frames of animation, the key will advance from 0 to 8 at the specified speed.
                    // <CJ Comment> Divisor set to 18f to match MSTS rate, but don't like magic numbers. Where does this one come from?
                    // See also pantograph animation. </CJ Comment>
                    WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 18f) * elapsedClockSeconds;
                    while (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey -= TrainCarShape.SharedShape.Animations[0].FrameCount;
                    while (WiperAnimationKey < -0.00001) WiperAnimationKey += TrainCarShape.SharedShape.Animations[0].FrameCount;
                    foreach (int iMatrix in WiperPartIndexes)
                        TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                }
                else // off
                {
                    if (WiperAnimationKey > 0.001)  // park the blades
                    {
                        // <CJ Comment> Divisor set to 18f to match MSTS rate, but don't like magic numbers. Where does this one come from?
                        // See also pantograph animation. </CJ Comment>
                        WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 18f) * elapsedClockSeconds;
                        if (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey = 0;
                        foreach (int iMatrix in WiperPartIndexes)
                            TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                    }
                }
            }

            // Draw 2D CAB View - by GeorgeS
            if (Viewer.Camera.AttachedCar == this.MSTSWagon &&
                Viewer.Camera.Style == Camera.Styles.Cab)
            {

                if (_CabRenderer != null)
                    _CabRenderer.PrepareFrame(frame);
            }

            base.PrepareFrame( frame, elapsedTime );
        }

        internal override void LoadForPlayer()
        {
            if (!_hasCabRenderer)
            {
                _hasCabRenderer = true;
                if (Locomotive.CVFFile != null && Locomotive.CVFFile.TwoDViews.Count > 0)
                    _CabRenderer = new CabRenderer(Viewer, Locomotive);
            }
        }

        internal override void Mark()
        {
            foreach (var pdl in ParticleDrawers.Values)
                foreach (var pd in pdl)
                    pd.Mark();
            if (_CabRenderer != null)
                _CabRenderer.Mark();
            base.Mark();
        }

        /// <summary>
        /// This doesn't function yet.
        /// </summary>
        public override void Unload()
        {
            base.Unload();
        }

    } // Class LocomotiveViewer

    // By GeorgeS
    /// <summary>
    /// Manages all CAB View textures - light conditions and texture parts
    /// </summary>
    public static class CABTextureManager
    {
        private static Dictionary<string, Texture2D> DayTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> NightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> LightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D[]> PDayTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PNightTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PLightTextures = new Dictionary<string, Texture2D[]>();

        /// <summary>
        /// Loads a texture, day night and cablight
        /// </summary>
        /// <param name="viewer">Viver3D</param>
        /// <param name="FileName">Name of the Texture</param>
        public static void LoadTextures(Viewer3D viewer, string FileName)
        {
            if (string.IsNullOrEmpty(FileName))
                return;

            if (DayTextures.Keys.Contains(FileName))
                return;

            if (File.Exists(FileName))
                DayTextures.Add(FileName, viewer.TextureManager.Get(FileName));
            else
                DayTextures.Add(FileName, SharedMaterialManager.MissingTexture);

            var nightpath = Path.Combine(Path.Combine(Path.GetDirectoryName(FileName), "night"), Path.GetFileName(FileName));
            if (File.Exists(nightpath))
                NightTextures.Add(FileName, viewer.TextureManager.Get(nightpath));
            else
                NightTextures.Add(FileName, SharedMaterialManager.MissingTexture);

            var lightpath = Path.Combine(Path.Combine(Path.GetDirectoryName(FileName), "cablight"), Path.GetFileName(FileName));
            if (File.Exists(lightpath))
                LightTextures.Add(FileName, viewer.TextureManager.Get(lightpath));
            else
                LightTextures.Add(FileName, SharedMaterialManager.MissingTexture);
        }

        static Texture2D[] Disassemble(GraphicsDevice graphicsDevice, Texture2D texture, Point controlSize, int frameCount, Point frameGrid, string fileName)
        {
            if (frameGrid.X < 1 || frameGrid.Y < 1 || frameCount < 1)
            {
                Trace.TraceWarning("Cab control has invalid frame data {1}*{2}={3} (no frames will be shown) for {0}", fileName, frameGrid.X, frameGrid.Y, frameCount);
                return new Texture2D[0];
            }

            var frameSize = new Point(texture.Width / frameGrid.X, texture.Height / frameGrid.Y);
            var frames = new Texture2D[frameCount];
            var frameIndex = 0;

            if (controlSize.X < frameSize.X || controlSize.Y < frameSize.Y)
                Trace.TraceWarning("Cab control size {1}x{2} is smaller than frame size {3}x{4} (frames may be cut-off) for {0}", fileName, controlSize.X, controlSize.Y, frameSize.X, frameSize.Y);

            if (frameCount > frameGrid.X * frameGrid.Y)
                Trace.TraceWarning("Cab control frame count {1} is larger than the number of frames {2}*{3}={4} (some frames will be blank) for {0}", fileName, frameCount, frameGrid.X, frameGrid.Y, frameGrid.X * frameGrid.Y);

            if (texture.Format != SurfaceFormat.Color && texture.Format != SurfaceFormat.Dxt1)
            {
                Trace.TraceWarning("Cab control texture {0} has unsupported format {1}; only Color and Dxt1 are supported.", fileName, texture.Format);
            }
            else
            {
                var copySize = new Point(Math.Min(controlSize.X, frameSize.X), Math.Min(controlSize.Y, frameSize.Y));
                if (texture.Format == SurfaceFormat.Dxt1)
                {
                    var textureSize = new Point((int)Math.Ceiling((float)controlSize.X / 4) * 4, (int)Math.Ceiling((float)controlSize.Y / 4) * 4);
                    var buffer = new byte[copySize.X * copySize.Y / 2];
                    frameIndex = DisassembleFrames(graphicsDevice, texture, controlSize, frameCount, frameGrid, frames, frameSize, copySize, textureSize, buffer);
                }
                else
                {
                    var buffer = new Color[copySize.X * copySize.Y];
                    frameIndex = DisassembleFrames(graphicsDevice, texture, controlSize, frameCount, frameGrid, frames, frameSize, copySize, controlSize, buffer);
                }
            }

            while (frameIndex < frameCount)
                frames[frameIndex++] = SharedMaterialManager.MissingTexture;

            return frames;
        }

        static int DisassembleFrames<T>(GraphicsDevice graphicsDevice, Texture2D texture, Point controlSize, int frameCount, Point frameGrid, Texture2D[] frames, Point frameSize, Point copySize, Point textureSize, T[] buffer) where T : struct
        {
            //Trace.TraceInformation("Disassembling {0} {11} frames in {1}x{2}; control {3}x{4}, frame {5}x{6}, copy {7}x{8}, texture {9}x{10}. {12}", frameCount, frameGrid.X, frameGrid.Y, controlSize.X, controlSize.Y, frameSize.X, frameSize.Y, copySize.X, copySize.Y, textureSize.X, textureSize.Y, texture.Format, controlSize == frameSize && frameSize == copySize && copySize == textureSize ? "" : "VARIABLE");
            var frameIndex = 0;
            for (var y = 0; y < frameGrid.Y; y++)
            {
                for (var x = 0; x < frameGrid.X; x++)
                {
                    if (frameIndex < frameCount)
                    {
                        texture.GetData(0, new Rectangle(x * frameSize.X, y * frameSize.Y, copySize.X, copySize.Y), buffer, 0, buffer.Length);
                        var frame = frames[frameIndex++] = new Texture2D(graphicsDevice, textureSize.X, textureSize.Y, 1, TextureUsage.None, texture.Format);
                        frame.SetData(0, new Rectangle(0, 0, copySize.X, copySize.Y), buffer, 0, buffer.Length, SetDataOptions.None);
                    }
                }
            }
            return frameIndex;
        }
        
        /// <summary>
        /// Disassembles all compound textures into parts
        /// </summary>
        /// <param name="graphicsDevice">The GraphicsDevice</param>
        /// <param name="fileName">Name of the Texture to be disassembled</param>
        /// <param name="width">Width of the Cab View Control</param>
        /// <param name="height">Height of the Cab View Control</param>
        /// <param name="frameCount">Number of frames</param>
        /// <param name="framesX">Number of frames in the X dimension</param>
        /// <param name="framesY">Number of frames in the Y direction</param>
        public static void DisassembleTexture(GraphicsDevice graphicsDevice, string fileName, int width, int height, int frameCount, int framesX, int framesY)
        {
            var controlSize = new Point(width, height);
            var frameGrid = new Point(framesX, framesY);

            PDayTextures[fileName] = null;
            if (DayTextures.ContainsKey(fileName))
            {
                var texture = DayTextures[fileName];
                if (texture != SharedMaterialManager.MissingTexture)
                {
                    PDayTextures[fileName] = Disassemble(graphicsDevice, texture, controlSize, frameCount, frameGrid, fileName + ":day");
                }
            }

            PNightTextures[fileName] = null;
            if (NightTextures.ContainsKey(fileName))
            {
                var texture = NightTextures[fileName];
                if (texture != SharedMaterialManager.MissingTexture)
                {
                    PNightTextures[fileName] = Disassemble(graphicsDevice, texture, controlSize, frameCount, frameGrid, fileName + ":night");
                }
            }

            PLightTextures[fileName] = null;
            if (LightTextures.ContainsKey(fileName))
            {
                var texture = LightTextures[fileName];
                if (texture != SharedMaterialManager.MissingTexture)
                {
                    PLightTextures[fileName] = Disassemble(graphicsDevice, texture, controlSize, frameCount, frameGrid, fileName + ":light");
                }
            }
        }

        /// <summary>
        /// Gets a Texture from the given array
        /// </summary>
        /// <param name="arr">Texture array</param>
        /// <param name="indx">Index</param>
        /// <param name="FileName">Name of the file to report</param>
        /// <returns>The given Texture</returns>
        private static Texture2D SafeGetAt(Texture2D[] arr, int indx, string FileName)
        {
            if (arr == null)
            {
                Trace.TraceWarning("Passed null Texture[] for accessing {0}", FileName);
                return SharedMaterialManager.MissingTexture;
            }
            
            if (arr.Length < 1)
            {
                Trace.TraceWarning("Disassembled texture invalid for {0}", FileName);
                return SharedMaterialManager.MissingTexture;
            }
            
            indx = (int)MathHelper.Clamp(indx, 0, arr.Length - 1);

            try
            {
                return arr[indx];
            }
            catch (IndexOutOfRangeException)
            {
                Trace.TraceWarning("Index {1} out of range for array length {2} while accessing texture for {0}", FileName, indx, arr.Length);
                return SharedMaterialManager.MissingTexture;
            }
        }

        /// <summary>
        /// Returns the compound part of a Texture previously disassembled
        /// </summary>
        /// <param name="FileName">Name of the disassembled Texture</param>
        /// <param name="indx">Index of the part</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <param name="isNightTexture"></param>
        /// <returns>The Texture represented by its index</returns>
        public static Texture2D GetTextureByIndexes(string FileName, int indx, bool isDark, bool isLight, out bool isNightTexture)
        {
            Texture2D retval = SharedMaterialManager.MissingTexture;
            Texture2D[] tmp = null;

            isNightTexture = false;

            if (string.IsNullOrEmpty(FileName) || !PDayTextures.Keys.Contains(FileName))
                return SharedMaterialManager.MissingTexture;

            if (isDark)
            {
                if (isLight)
                {
                    //tmp = PLightTextures[FileName];
                    tmp = PDayTextures[FileName];
                    if (tmp != null)
                    {
                        retval = SafeGetAt(tmp, indx, FileName);
                        isNightTexture = false;
                    }
                }

                if (retval == SharedMaterialManager.MissingTexture)
                {
                    tmp = PNightTextures[FileName];
                    if (tmp != null)
                    {
                        retval = SafeGetAt(tmp, indx, FileName);
                        isNightTexture = true;
                    }
                }
            }

            if (retval == SharedMaterialManager.MissingTexture)
            {
                tmp = PDayTextures[FileName];
                if (tmp != null)
                {
                    retval = SafeGetAt(tmp, indx, FileName);
                    isNightTexture = false;
                }
            }
            return retval;
        }

        /// <summary>
        /// Returns a Texture by its name
        /// </summary>
        /// <param name="FileName">Name of the Texture</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <param name="isNightTexture"></param>
        /// <returns>The Texture</returns>
        public static Texture2D GetTexture(string FileName, bool isDark, bool isLight, out bool isNightTexture)
        {
            Texture2D retval = SharedMaterialManager.MissingTexture;
            isNightTexture = false;

            if (string.IsNullOrEmpty(FileName) || !DayTextures.Keys.Contains(FileName))
                return retval;

            if (isDark)
            {
                if (isLight)
                {
                    //retval = LightTextures[FileName];
                    retval = DayTextures[FileName];
                    isNightTexture = false;
                }

                if (retval == SharedMaterialManager.MissingTexture)
                {
                    retval = NightTextures[FileName];
                    isNightTexture = true;
                }
            }

            if (retval == SharedMaterialManager.MissingTexture)
            {
                retval = DayTextures[FileName];
                isNightTexture = false;
            }

            return retval;
        }

        [CallOnThread("Loader")]
        public static void Mark(Viewer3D viewer)
        {
            foreach (var texture in DayTextures.Values)
                viewer.TextureManager.Mark(texture);
            foreach (var texture in NightTextures.Values)
                viewer.TextureManager.Mark(texture);
            foreach (var texture in LightTextures.Values)
                viewer.TextureManager.Mark(texture);
            foreach (var textureList in PDayTextures.Values)
                if (textureList != null)
                    foreach (var texture in textureList)
                        viewer.TextureManager.Mark(texture);
            foreach (var textureList in PNightTextures.Values)
                if (textureList != null)
                    foreach (var texture in textureList)
                        viewer.TextureManager.Mark(texture);
            foreach (var textureList in PLightTextures.Values)
                if (textureList != null)
                    foreach (var texture in textureList)
                        viewer.TextureManager.Mark(texture);
        }
    }

    public class CabRenderer : RenderPrimitive
    {
        private SpriteBatchMaterial _Sprite2DCabView; 
        private Rectangle _CabRect = new Rectangle();
        private Matrix _Scale = Matrix.Identity;
        private Texture2D _CabTexture;
        private CabShader _Shader;

        private Point _PrevScreenSize;

        private CabViewControls CabViewControls;
        private List<CabViewControlRenderer> CabViewControlRenderers = new List<CabViewControlRenderer>();

        private Viewer3D _Viewer;
        private MSTSLocomotive _Locomotive;
        private int _Location;
        private bool _isNightTexture;

        public CabRenderer(Viewer3D viewer, MSTSLocomotive car)
        {
			//Sequence = RenderPrimitiveSequence.CabView;
            _Sprite2DCabView = (SpriteBatchMaterial)viewer.MaterialManager.Load("SpriteBatch");
            _Viewer = viewer;
            _Locomotive = car;

            // _Viewer.DisplaySize intercepted to adjust cab view height
            Point DisplaySize = _Viewer.DisplaySize;
            DisplaySize.Y = _Viewer.CabHeightPixels;

            if (_Locomotive.ExCVF != null)
            {
                _Shader = new CabShader( viewer.GraphicsDevice, viewer.RenderProcess.Content,
                    _Locomotive.ExCVF.TranslatedPosition( _Locomotive.ExCVF.Light1Position, DisplaySize ),
                    _Locomotive.ExCVF.TranslatedPosition( _Locomotive.ExCVF.Light2Position, DisplaySize ),
                    _Locomotive.ExCVF.TranslatedColor( _Locomotive.ExCVF.Light1Color ),
                    _Locomotive.ExCVF.TranslatedColor( _Locomotive.ExCVF.Light2Color ) );
            }
            _PrevScreenSize = DisplaySize;

            // Loading ACE files, skip displaying ERROR messages
            foreach (string cabfile in car.CVFFile.TwoDViews)
            {
                CABTextureManager.LoadTextures(viewer, cabfile);
            }

            #region Create Control renderers
            CabViewControls = car.CVFFile.CabViewControls;
            if (CabViewControls != null)
            {
                foreach (CabViewControl cvc in CabViewControls)
                {
                    CVCDial dial = cvc as CVCDial;
                    if (dial != null)
                    {
                        CabViewDialRenderer cvcr = new CabViewDialRenderer(dial, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvcr);
                        continue;
                    }
                    CVCGauge gauge = cvc as CVCGauge;
                    if (gauge != null)
                    {
                        CabViewGaugeRenderer cvgr = new CabViewGaugeRenderer(gauge, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvgr);
                        continue;
                    }
                    CVCSignal asp = cvc as CVCSignal;
                    if (asp != null)
                    {
                        CabViewDiscreteRenderer aspr = new CabViewDiscreteRenderer(asp, viewer, car, _Shader);
                        CabViewControlRenderers.Add(aspr);
                        continue;
                    }
                    CVCMultiStateDisplay multi = cvc as CVCMultiStateDisplay;
                    if (multi != null)
                    {
                        CabViewDiscreteRenderer mspr = new CabViewDiscreteRenderer(multi, viewer, car, _Shader);
                        CabViewControlRenderers.Add(mspr);
                        continue;
                    }
                    CVCDiscrete disc = cvc as CVCDiscrete;
                    if (disc != null)
                    {
                        CabViewDiscreteRenderer cvdr = new CabViewDiscreteRenderer(disc, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvdr);
                        continue;
                    }
                    CVCDigital digital = cvc as CVCDigital;
                    if (digital != null)
                    {
                        CabViewDigitalRenderer cvdr = new CabViewDigitalRenderer(digital, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvdr);
                        continue;
                    }
                }
            }
            #endregion
        }

        public void PrepareFrame(RenderFrame frame)
        {
            if (!_Locomotive.ShowCab)
                return;

            bool Dark = _Viewer.MaterialManager.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            CabCamera cbc = _Viewer.Camera as CabCamera;
            if (cbc != null)
            {
                _Location = cbc.SideLocation;
            }
            else
            {
                _Location = 0;
            }

            _CabTexture = CABTextureManager.GetTexture(_Locomotive.CVFFile.TwoDViews[_Location], Dark, CabLight, out _isNightTexture);

            if (_CabTexture == SharedMaterialManager.MissingTexture)
                return;

            // Cab view height adjusted to allow for clip or stretch
            _CabRect.Width = _Viewer.DisplaySize.X;
            _CabRect.Height = _Viewer.CabHeightPixels;

            if (_PrevScreenSize != _Viewer.DisplaySize && _Shader != null)
            {
                _PrevScreenSize = _Viewer.DisplaySize;
                _Shader.SetLightPositions(
                    _Locomotive.ExCVF.TranslatedPosition(_Locomotive.ExCVF.Light1Position, _Viewer.DisplaySize),
                    _Locomotive.ExCVF.TranslatedPosition(_Locomotive.ExCVF.Light2Position, _Viewer.DisplaySize));
            }

            frame.AddPrimitive(_Sprite2DCabView, this, RenderPrimitiveGroup.Cab, ref _Scale);
            //frame.AddPrimitive(Materials.SpriteBatchMaterial, this, RenderPrimitiveGroup.Cab, ref _Scale);

            if (_Location == 0)
            {
                foreach (CabViewControlRenderer cvcr in CabViewControlRenderers)
                {
                    cvcr.PrepareFrame(frame);
                }
            }
        }
        
        public override void Draw(GraphicsDevice graphicsDevice)
        {
            // Cab view vertical position adjusted to allow for clip or stretch.
            Rectangle stretchedCab = new Rectangle( _CabRect.Left, _CabRect.Top + _Viewer.CabYOffsetPixels, _CabRect.Width, _CabRect.Height );
            
            if( _Location == 0 && _Shader != null )
            {
                _Shader.SetData(_Viewer.MaterialManager.sunDirection,
                    _isNightTexture, _Locomotive.CabLightOn, _Viewer.World.Sky.overcast);

                _Shader.SetTexData( stretchedCab.Left, stretchedCab.Top, stretchedCab.Width, stretchedCab.Height );
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }

            _Sprite2DCabView.SpriteBatch.Draw( _CabTexture, stretchedCab, Color.White );
            //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_CabTexture, _CabRect, Color.White);

            if (_Location == 0 && _Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }

        internal void Mark()
        {
            _Viewer.TextureManager.Mark(_CabTexture);
            foreach (var cvcr in CabViewControlRenderers)
                cvcr.Mark();
        }
    }

    /// <summary>
    /// Base class for rendering Cab Controls
    /// </summary>
    public class CabViewControlRenderer : RenderPrimitive
    {
        protected CabViewControl _CabViewControl;
        protected SpriteBatchMaterial _Sprite2DCtlView;
        protected Matrix _Matrix = Matrix.Identity;
        protected Texture2D _Texture;
        protected Viewer3D _Viewer;
        protected MSTSLocomotive _Locomotive;

        protected Vector2 _Position = new Vector2();
        
        protected bool _isNightTexture;
        protected CabShader _Shader;

        public CabViewControlRenderer(CabViewControl cvc, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
        {
            _CabViewControl = cvc;
            _Shader = shader;
            _Sprite2DCtlView = (SpriteBatchMaterial)viewer.MaterialManager.Load("SpriteBatch");

            CABTextureManager.LoadTextures(viewer, _CabViewControl.ACEFile);

            _Viewer = viewer;
            _Locomotive = car;
        }

        /// <summary>
        /// Gets the requested Locomotive data and translates it into percents by Min and Max values
        /// </summary>
        /// <returns>Percent of real data by Min and Max values</returns>
        public float TranslateToPercent()
        {
            float data = _Locomotive.GetDataOf(_CabViewControl);
            if (data < _CabViewControl.MinValue)
                return 0;
            if (data > _CabViewControl.MaxValue)
                return 1;

            if (_CabViewControl.MaxValue == _CabViewControl.MinValue)
                return 0;

            return (float)((data - _CabViewControl.MinValue) / (_CabViewControl.MaxValue - _CabViewControl.MinValue));
        }

        public float TranslateToPercentLoadMeter()
        {
            int minValuePos = 0;
            float data = _Locomotive.GetDataOf(_CabViewControl);
            if (data >= 0)
            {
                
                if (data < minValuePos)
                    return 0;

                if (data > _CabViewControl.MaxValue)
                    return 1;

                return (float)((data - minValuePos) / (_CabViewControl.MaxValue - minValuePos));
            }
            else    // Dynamic Break
            {
                if (data > minValuePos)
                    return 0;
                if (data < _CabViewControl.MinValue)
                    return -1;

                return (float) - ((Math.Abs(data) - minValuePos) / (Math.Abs(_CabViewControl.MinValue) - minValuePos));
            }
        }

        public virtual void PrepareFrame(RenderFrame frame)
        {
            frame.AddPrimitive(_Sprite2DCtlView, this, RenderPrimitiveGroup.Cab, ref _Matrix);
            //frame.AddPrimitive(Materials.SpriteBatchMaterial, this, RenderPrimitiveGroup.Cab, ref _Matrix);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
        }

        internal void Mark()
        {
            _Viewer.TextureManager.Mark(_Texture);
        }
    }

    /// <summary>
    /// Dial Cab Control Renderer
    /// Problems with aspect ratio
    /// </summary>
    public class CabViewDialRenderer : CabViewControlRenderer
    {
        private float _Rotation = 0f;
        private float _ScaleToScreen = 1f;
        private Vector2 _Origin;
        private CVCDial _Dial;
        protected float _Scale = 1f;

        public CabViewDialRenderer(CVCDial dial, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base (dial, viewer, car, shader)
        {
            _Dial = dial;
            _Origin = new Vector2((float)(_Dial.Width / 2), _Dial.Center);

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, false, false, out _isNightTexture);
            _Scale = (float)(_Dial.Height / _Texture.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = _Viewer.MaterialManager.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, Dark, CabLight, out _isNightTexture);

            if (_Texture == SharedMaterialManager.MissingTexture)
                return;

            base.PrepareFrame(frame);

			// Cab view height and vertical position adjusted to allow for clip or stretch.
            _Position.X = (float)_Viewer.DisplaySize.X / 640 * ((float)_CabViewControl.PositionX + _Origin.X);
            _Position.Y = (float)_Viewer.CabHeightPixels / 480 * ((float)_CabViewControl.PositionY + _Origin.Y) + _Viewer.CabYOffsetPixels;
            _ScaleToScreen = (float)_Viewer.DisplaySize.X / 640 * _Scale;

            float percent = TranslateToPercent();
            float range;

            if ((_Dial.FromDegree > _Dial.ToDegree && _Dial.Direction == 0) ||
                (_Dial.ToDegree > _Dial.FromDegree && _Dial.Direction != 0))
            {
                range = 360 - _Dial.FromDegree + _Dial.ToDegree;
            }
            else
            {
                range = _Dial.ToDegree - _Dial.FromDegree;
            }

            float degree = range * percent;

            if (_Dial.Direction == 0)
                degree = _Dial.FromDegree + degree;
            else
                degree = _Dial.ToDegree - degree;

            _Rotation = MathHelper.ToRadians(degree);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (_Shader != null)
            {
                _Shader.SetTexData(_Position.X, _Position.Y, _Texture.Width * _ScaleToScreen, _Texture.Height * _ScaleToScreen);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }
            _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _Position, null, Color.White, _Rotation, _Origin, _ScaleToScreen, SpriteEffects.None, 0);
            //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _Position, null, Color.White, _Rotation, _Origin, _ScaleToScreen, SpriteEffects.None, 0);
            if (_Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }
    } // End Class CabViewDialRenderer

    /// <summary>
    /// Gauge type renderer
    /// Supports pointer, liquid, solid
    /// Supports Orientation and Direction
    /// </summary>
    public class CabViewGaugeRenderer : CabViewControlRenderer
    {
        protected CVCWithFrames _CVCWithFrames;
        private CVCGauge _Gauge;
        protected Rectangle _SourceRectangle = new Rectangle();
        protected Rectangle _DestRectangle = new Rectangle();
        bool LoadMeterPositive = true;

        public CabViewGaugeRenderer(CVCGauge gauge, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base(gauge, viewer, car, shader)
        {
            _Gauge = gauge;
            _SourceRectangle = _Gauge.Area;
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = _Viewer.MaterialManager.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, Dark, CabLight, out _isNightTexture);

            if (_Texture == SharedMaterialManager.MissingTexture)
                return;

            base.PrepareFrame(frame);

            // Cab view height adjusted to allow for clip or stretch.
            float xratio = (float)_Viewer.DisplaySize.X / 640;
            float yratio = (float)_Viewer.CabHeightPixels / 480;

            float percent;
            if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER)
            {
                // Test numbers
                //percent = -0.25f;
                //percent = 0.25f;
                //percent = -0.5f;
                //percent =  0.5f;
                //percent = -0.75f;
                //percent = -1.0f;
                //percent =  1.0f;

                percent = TranslateToPercentLoadMeter();
                if (percent >= 0)
                {
                    LoadMeterPositive = true;
                    _Gauge.Direction = 0;
                }
                else
                {
                    LoadMeterPositive = false;
                    _Gauge.Direction = 1;
                    Math.Abs(percent);
                }
            }
            else
                percent = TranslateToPercent();

            float xpos = 0;
            float ypos = 0;
            if (_Gauge.Orientation == 0)    // gauge horiz
            {
                ypos = (int)_Gauge.Height;
                if (_Gauge.Direction == 0)  // horiz increasing
                {
                    if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER &&
                        LoadMeterPositive)
                    {
                        // -1200 to + 1800 = 3000 abs 1200/3000 = 0.40 
                        // range 76 x 0.40 = 30.4
                        float adjustGaugeWidth = (float)_Gauge.Width - 30.4f;
                        xpos = (adjustGaugeWidth * percent);
                    }
                    else
                        xpos = ((float)_Gauge.Width * percent);
                }

                if (_Gauge.Direction == 1)  // horiz decreasing
                {
                    if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER &&
                        !LoadMeterPositive)
                    {
                        float adjustGaugeWidth = (float)_Gauge.Width - 45.6f;
                        xpos = (adjustGaugeWidth * Math.Abs(percent));
                    }
                    else
                        xpos = ((float)_Gauge.Width - (float)_Gauge.Width * percent);
                }
            } // end if _Gauge.Orientation
            else                          // gauge vert
            {
                xpos = (int)_Gauge.Width;
                if (_Gauge.Direction == 0)
                {
                    ypos = ((float)_Gauge.Height * percent);
                }
                else
                {
                    ypos = ((float)_Gauge.Height - (float)_Gauge.Height * percent);
                }
            }

            if (_Gauge.ControlStyle == CABViewControlStyles.SOLID || _Gauge.ControlStyle == CABViewControlStyles.LIQUID)
                if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER)
                {
                    _DestRectangle.X = (int)(xratio * _CabViewControl.PositionX);    // left hand start position

                    if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER &&
                        LoadMeterPositive)
                        // gauge width - area  offset to center
                         _DestRectangle.X = (int)(xratio * (_CabViewControl.PositionX + (int)30.4f));
                    
                    if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER &&
                        !LoadMeterPositive)
                    {
                        var centDrec = (int)(xratio * (_CabViewControl.PositionX + (int)30.4f)); 
                        _DestRectangle.X = centDrec - (int)(xratio * xpos);
                    }


                    // Cab view vertical position adjusted to allow for clip or stretch.
                    _DestRectangle.Y = (int)(yratio * _CabViewControl.PositionY) + _Viewer.CabYOffsetPixels;
                    _DestRectangle.Width = (int)(xratio * xpos);
                    _DestRectangle.Height = (int)(yratio * ypos);
                }
                else
                {
                    // Cab view vertical position adjusted to allow for clip or stretch.
                    _DestRectangle.X = (int)(xratio * _CabViewControl.PositionX);
                    _DestRectangle.Y = (int)(yratio * _CabViewControl.PositionY) + _Viewer.CabYOffsetPixels;
                    _DestRectangle.Width = (int)(xratio * xpos);
                    _DestRectangle.Height = (int)(yratio * ypos);
                }


            else    // Is this code ever executed ???
            {
                // Cab view vertical position adjusted to allow for clip or stretch.
                _DestRectangle.X = (int)(xratio * (_CabViewControl.PositionX + xpos));
                _DestRectangle.Y = (int)(yratio * (_CabViewControl.PositionY + ypos)) + _Viewer.CabYOffsetPixels;
                _DestRectangle.Width = (int)(xratio * _Gauge.Area.Width);
                _DestRectangle.Height = (int)(yratio * _Gauge.Area.Height);
            }
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (_Shader != null)
            {
                _Shader.SetTexData(_DestRectangle.Left, _DestRectangle.Top, _DestRectangle.Width, _DestRectangle.Height);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }
            if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER &&
                LoadMeterPositive)
                _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.Green);

            else if (_CabViewControl.ControlType == CABViewControlTypes.LOAD_METER &&
                !LoadMeterPositive)
                //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.Yellow);
                _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.Yellow);
            else if (_CabViewControl.ControlType == CABViewControlTypes.REVERSER_PLATE)
                //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
                _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
            else
                //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.Blue);
                _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.Blue);
            if (_Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }
    } // End Class CabViewGaugeRenderer 

    /// <summary>
    /// Discrete renderer for Lever, Twostate, Tristate, Multistate, Signal
    /// </summary>
    public class CabViewDiscreteRenderer : CabViewControlRenderer
    {
        protected CVCWithFrames _CVCWithFrames;
        protected Rectangle _SourceRectangle;
        protected Rectangle _DestRectangle = new Rectangle();
        
        public CabViewDiscreteRenderer(CVCWithFrames cvc, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base(cvc, viewer, car, shader)
        {
            _CVCWithFrames = cvc;
            CABTextureManager.DisassembleTexture(viewer.GraphicsDevice, _CabViewControl.ACEFile, (int)_CabViewControl.Width, (int)_CabViewControl.Height, _CVCWithFrames.FramesCount, _CVCWithFrames.FramesX, _CVCWithFrames.FramesY);
            _SourceRectangle = new Rectangle(0, 0, (int)_CVCWithFrames.Width, (int)_CVCWithFrames.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = _Viewer.MaterialManager.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            int indx = GetDrawIndex();

            indx = (int)MathHelper.Clamp(indx, 0, _CVCWithFrames.FramesCount - 1);

            _Texture = CABTextureManager.GetTextureByIndexes(_CabViewControl.ACEFile, indx, Dark, CabLight, out _isNightTexture);

            if (_Texture == SharedMaterialManager.MissingTexture)
                return;

            base.PrepareFrame(frame);

            // Cab view height and vertical position adjusted to allow for clip or stretch.
            float xratio = (float)_Viewer.DisplaySize.X / 640;
            float yratio = (float)_Viewer.CabHeightPixels / 480;

            _DestRectangle.X = (int)(xratio * _CabViewControl.PositionX * 1.0001);
            _DestRectangle.Y = (int)(yratio * _CabViewControl.PositionY * 1.0001) + _Viewer.CabYOffsetPixels;
            _DestRectangle.Width = (int)(xratio * _CabViewControl.Width);
            _DestRectangle.Height = (int)(yratio * _CabViewControl.Height);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            //graphicsDevice.SamplerStates[0].MagFilter = TextureFilter.Linear;
            if (_Shader != null)
            {
                _Shader.SetTexData(_DestRectangle.Left, _DestRectangle.Top, _DestRectangle.Width, _DestRectangle.Height);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }
            //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
            _Sprite2DCtlView.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
            if (_Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }

        /// <summary>
        /// Determines the index of the Texture to be drawn
        /// </summary>
        /// <returns>index of the Texture</returns>
        public int GetDrawIndex()
        {
            float data = _Locomotive.GetDataOf(_CabViewControl);
            int indx = 0;
            switch (_CVCWithFrames.ControlType)
            {
                //case CABViewControlTypes.THROTTLE:
                //case CABViewControlTypes.THROTTLE_DISPLAY:
                //case CABViewControlTypes.CPH_DISPLAY:
                case CABViewControlTypes.ENGINE_BRAKE:
                case CABViewControlTypes.TRAIN_BRAKE:
                //case CABViewControlTypes.DYNAMIC_BRAKE:
                //case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    {
                        indx = FromPercent(data);
                        break;
                    }

                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                    {
                        if (_Locomotive.HasStepCtrl)
                            indx = _Locomotive.ThrottleController.CurrentNotch;
                        else
                            indx = FromPercent(data);
                        break;
                    }

                case CABViewControlTypes.FRICTION_BRAKING:
                    {
                        indx = (data > 0) ? 1 : 0;
                        break;
                    }

                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    {
                        float dynBrakePercent = (float)_Locomotive.Train.MUDynamicBrakePercent;
                        if (_Locomotive.DynamicBrakeController != null)
                        {
                            int currentDynamicNotch = _Locomotive.DynamicBrakeController.CurrentNotch;
                            int dynNotchCount = _Locomotive.DynamicBrakeController.NotchCount();

                            if (dynBrakePercent == -1)
                                break;
                            else
                                if (!_Locomotive.HasSmoothStruc)
                                    indx = currentDynamicNotch;
                                else
                                    indx = FromPercent(dynBrakePercent);
                        }
                        else
                        {
                            indx = FromPercent(dynBrakePercent);
                        }
                        break;
                    }

                case CABViewControlTypes.CPH_DISPLAY:
                case CABViewControlTypes.CP_HANDLE:
                    {
                        // if (!_Locomotive.HasStepCtrl) { break; } // break if not diesel loco

                        int currentThrottleNotch = _Locomotive.ThrottleController.CurrentNotch;
                        int throttleNotchCount = _Locomotive.ThrottleController.NotchCount();

                        int currentDynamicNotch = _Locomotive.DynamicBrakeController.CurrentNotch;
                        int dynNotchCount = _Locomotive.DynamicBrakeController.NotchCount();
                        float dynBrakePercent = (float)_Locomotive.Train.MUDynamicBrakePercent;

                            if (dynBrakePercent == -1)
                            {
                                if (currentThrottleNotch == 0)
                                    indx = throttleNotchCount - 1;
                                else
                                    indx = (throttleNotchCount - 1) - currentThrottleNotch;
                            }
                            else // dynamic break enabled
                            {
                                 if (!_Locomotive.HasSmoothStruc)
                                    indx = (dynNotchCount - 1) + currentDynamicNotch;

                                     // This section for dispaly is based on 3DTS smooth controls
                                     // The # of discreet positons for the display is based on how
                                     // MSTS displayed them, so a dummy emulation is supplied here.
                                else
                                 {
                                     indx = IndxFromDummyDyn(dynBrakePercent);
                                     indx += 9;
                                 }



                            if (UserInput.RDState != null)
                            {
                                if (UserInput.RDState.DynamicBrakePercent >= -100f)
                                {
                                    if (currentThrottleNotch == 0)
                                        indx = throttleNotchCount - 1;
                                    else
                                        indx = (throttleNotchCount - 1) - currentThrottleNotch;
                                }

                                if (UserInput.RDState.DynamicBrakePercent >= 0)
                                    indx = (dynNotchCount - 1) + currentDynamicNotch;
                            }
                        } // End Dynamic != null
 
                        if (UserInput.RDState != null)
                        {
                            int currentTrainBrakeNotch = _Locomotive.TrainBrakeController.CurrentNotch;
                            int trainBrakeNotchCount = _Locomotive.TrainBrakeController.NotchCount();
                            float trainBrakePercent = (float)_Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                            int bias = _Locomotive.ComboCtrlCrossOver + 1;  //  needs to picked off eng file (center point)

                            if (trainBrakePercent <= 1)
                            {
                                if (currentThrottleNotch == 0)
                                    indx = throttleNotchCount - 1;
                                else
                                    indx = (throttleNotchCount - 1) - currentThrottleNotch;
                            }
                            else
                                indx = bias + currentTrainBrakeNotch;
                        }

                        break;
                    }

                case CABViewControlTypes.ALERTER_DISPLAY:
                    {
                        indx = (int)data;
                        break;
                    }
                case CABViewControlTypes.RESET:
                    {
                        indx = (int)data;
                        break;
                    }

                case CABViewControlTypes.WIPERS:
                case CABViewControlTypes.HORN:
                case CABViewControlTypes.BELL:
                case CABViewControlTypes.SANDERS:
                case CABViewControlTypes.WHEELSLIP:
                case CABViewControlTypes.FRONT_HLIGHT:
                case CABViewControlTypes.PANTOGRAPH:
                case CABViewControlTypes.PANTO_DISPLAY:
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        indx = (int)data;
                        break;
                    }
            }

            return indx;
        }

        /// <summary>
        /// Translates a percent value to a display index
        /// </summary>
        /// <param name="percent">Percent to be translated</param>
        /// <returns>The calculated display index by the Control's Values</returns>
        public int FromPercent(float percent)
        {
            int indx = 0;

            if (percent > 1) percent /= 100f;
            percent = MathHelper.Clamp(percent, (float)_CVCWithFrames.MinValue, (float)_CVCWithFrames.MaxValue);
            if (_CVCWithFrames.Values.Count > 1)
            {
                double val = _CVCWithFrames.Values.Where(v => v <= percent).Last();
                indx = _CVCWithFrames.Values.IndexOf(val);
            }
            else
            {
                if (_CVCWithFrames.MaxValue != _CVCWithFrames.MinValue)
                {
                    indx = (int)(percent / (_CVCWithFrames.MaxValue - _CVCWithFrames.MinValue) * _CVCWithFrames.FramesCount);
                }
            }

            return indx;
        }

        int IndxFromDummyDyn(float percent)
        {
            //Build a Constant Array
            float[] indxByPercent = new float[]
                { 0.0f,
                   .1111f,
                   .2222f,
                   .3333f,
                   .4444f,
                   .5555f,
                   .6666f,
                   .7777f,
                   .8888f,
                   1.0f
                };

            float v = 0;
            int indx = 0;

            if (percent > 1)
                percent /= 100f;

            for (int i = 0; i < 10; i++)
            {
                v = indxByPercent[i];
                if (percent >= v)
                {
                    indx = i;
                    continue;
                }
                if (percent <= v)
                {
                    //indx = i;
                    break;
                }
            }
            return indx;
        }

    }

    /// <summary>
    /// Digital Cab Control renderer
    /// Uses fonts instead of graphic
    /// Does not support Justification
    /// </summary>
    public class CabViewDigitalRenderer : CabViewControlRenderer
    {
        private float _Num;
        SpriteFont _Font;
        private float _ScaleToScreen = 1f;
        private int _Digits = 1;
        

        public CabViewDigitalRenderer (CVCDigital digital, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base (digital, viewer, car, shader)
        {
            _Font = _Viewer.RenderProcess.Content.Load<SpriteFont>("Arial");

            if (_CabViewControl.ControlType == CABViewControlTypes.CLOCK)
                _Digits = 8;
            else
                _Digits = (int)Math.Log10(_CabViewControl.MaxValue) + 1;
            
        }

        public override void PrepareFrame(RenderFrame frame)
        {
           
            float fontratio = (float)_CabViewControl.Height / 16;
            float fpos = 0.0f;
            //if (_CabViewControl.ControlType == CABViewControlTypes.CLOCK)
            //    fpos = ((float)_CabViewControl.Width) - 7 * _Digits;// * fontratio;
            //else
                fpos = ((float)_CabViewControl.Width) - 7 * _Digits;// * fontratio;

                if (_CabViewControl.ControlType == CABViewControlTypes.CLOCK)
                    _Position.X = (float)_Viewer.DisplaySize.X / 640 * ((float)_CabViewControl.PositionX + fpos);
                else
                    _Position.X = (float)_Viewer.DisplaySize.X / 640 * ((float)_CabViewControl.PositionX + fpos);

            // Cab view height and vertical position adjusted to allow for clip or stretch.
            _Position.Y = (float)_Viewer.DisplaySize.X / 640 * (float)_CabViewControl.PositionY + _Viewer.CabYOffsetPixels;

            base.PrepareFrame(frame);

            _ScaleToScreen = (float)_Viewer.DisplaySize.X / 640 * (fontratio);

            _Num = _Locomotive.GetDataOf(_CabViewControl);
        }

        //Modified by Dionis 26/05/2011 in order to display colors and number formats
        public override void Draw(GraphicsDevice graphicsDevice)
        {
            StringBuilder sbAccuracy = new StringBuilder();
            StringBuilder sbLeadingZeros = new StringBuilder();
            //var  digtalClock =  _Locomotive.clockTime;
            string displayedText = "";
            Color textColor;
            try
            {
                if (((CVCDigital)_CabViewControl).OldValue != 0 && ((CVCDigital)_CabViewControl).OldValue
                        > _Num && ((CVCDigital)_CabViewControl).DecreaseColor.A != 0)
                {
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).Accuracy; i++)
                    {
                        sbAccuracy.Append("0");
                    }

                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).LeadingZeros; i++)
                    {
                        sbLeadingZeros.Append("0");
                    }

                    displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + 
                        (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", Math.Abs(_Num));
                    textColor = new Color { A = (byte)((CVCDigital)_CabViewControl).DecreaseColor.A,
                        B = (byte)((CVCDigital)_CabViewControl).DecreaseColor.B,
                        G = (byte)((CVCDigital)_CabViewControl).DecreaseColor.G,
                        R = (byte)((CVCDigital)_CabViewControl).DecreaseColor.R };

                }

                else if (_Num < 0 && ((CVCDigital)_CabViewControl).NegativeColor.A != 0)
                {
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).Accuracy; i++)
                    {
                        sbAccuracy.Append("0");
                    }
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).LeadingZeros; i++)
                    {
                        sbLeadingZeros.Append("0");
                    }
                    displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + 
                        (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", Math.Abs(_Num));
                    textColor = new Color { A = (byte)((CVCDigital)_CabViewControl).NegativeColor.A,
                        B = (byte)((CVCDigital)_CabViewControl).NegativeColor.B,
                        G = (byte)((CVCDigital)_CabViewControl).NegativeColor.G,
                        R = (byte)((CVCDigital)_CabViewControl).NegativeColor.R };
                }

                else
                {
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).Accuracy; i++)
                    {
                        sbAccuracy.Append("0");
                    }

                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).LeadingZeros; i++)
                    {
                        sbLeadingZeros.Append("0");
                    }

                    if (((CVCDigital)_CabViewControl).PositiveColor.A != 0)
                    {
                        displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + 
                            (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", _Num);
                        textColor = new Color { A = (byte)((CVCDigital)_CabViewControl).PositiveColor.A,
                            B = (byte)((CVCDigital)_CabViewControl).PositiveColor.B,
                            G = (byte)((CVCDigital)_CabViewControl).PositiveColor.G,
                            R = (byte)((CVCDigital)_CabViewControl).PositiveColor.R };
                    }

                    else
                    {
                        displayedText = String.Format("{0:0" + sbLeadingZeros.ToString()
                            + (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", _Num);
                        textColor = Color.White;

                    }
                }

                if (_CabViewControl.ControlType == CABViewControlTypes.CLOCK)
                {
                    int startTime = (int) _Locomotive.Simulator.ClockTime;
                    displayedText = InfoDisplay.FormattedTime(startTime);
                    textColor = Color.White;
                }

                if (_CabViewControl.ControlType == CABViewControlTypes.SPEEDOMETER)
                {
                    textColor = Color.White;
                    if (_Locomotive.Train != null && _Locomotive.GetDataOf(_CabViewControl) > 
                        MpS.FromMpS(_Locomotive.Train.AllowedMaxSpeedMpS, _CabViewControl.Units == CABViewControlUnits.KM_PER_HOUR))
                    {
                        textColor = Color.Yellow;
                    }
                }

                _Sprite2DCtlView.SpriteBatch.DrawString(_Font, displayedText, _Position, textColor, 0f, new Vector2(),
                    _ScaleToScreen, SpriteEffects.None, 0);
                //((CVCDigital)_CabViewControl).OldValue = _Num;
                // The line commente out above is a temporary fix for the flashing AMP on Dash 9
                // commit v837 for a web link describint the details
            }
            catch (Exception error)
            {
                Trace.WriteLine(error);
            }
            finally
            {
                sbAccuracy = null;
                sbLeadingZeros = null;
            }
        }
    }
}
