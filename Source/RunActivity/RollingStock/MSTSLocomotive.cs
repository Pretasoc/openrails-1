/* LOCOMOTIVE CLASSES
 * 
 * Used a a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  LocomotiveSimulator - defines the behaviour, ie physics, motion, power generated etc
 *  LocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCarSimulator - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */
/// COPYRIGHT 2009 by the Open Rails project.
/// This code is provided to enable you to contribute improvements to the open rails program.  
/// Use of the code for any other purpose or distribution of the code to anyone else
/// is prohibited without specific written permission from admin@openrails.org.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MSTS;
using System.Xml;
using Microsoft.Xna.Framework.Content;
using System.Text;



namespace ORTS
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////


    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public class MSTSLocomotive: MSTSWagon
    {
        // simulation parameters
        public bool Horn = false;
        public bool Bell = false;
        public bool Sander = false;  
        public bool Wiper = false;
        public bool BailOff = false;
        public float MaxPowerW;
        public float MaxForceN;
        public float MaxSpeedMpS = 1e3f;
        public float MainResPressurePSI = 130;
        public bool CompressorOn = false;
        public float AverageForceN = 0;
        // by GeorgeS
        public bool CabLightOn = false;
        public bool ShowCab = true;

        // wag file data
        public string CabSoundFileName = null;
        public string CVFFileName = null;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeFT3 = 10;
        public float CompressorRestartPressurePSI = 110;
        public float MainResChargingRatePSIpS = .4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = .003f;
        public float BrakeServiceTimeFactorS = 1.009f;
        public float BrakeEmergencyTimeFactorS = .1f;
        public float BrakePipeChargingRatePSIpS;
        public Interpolator2D TractiveForceCurves = null;
        public Interpolator2D DynamicBrakeForceCurves = null;
        public float DynamicBrakeSpeed1 = 3;
        public float DynamicBrakeSpeed2 = 18;
        public float DynamicBrakeSpeed3 = 23;
        public float DynamicBrakeSpeed4 = 35;
        public float MaxDynamicBrakeForceN = 0;
        public bool DynamicBrakeAutoBailOff = false;
        public float MaxContinuousForceN;
        public float ContinuousForceTimeFactor = 1800;
        public float NumWheels = 4;
        public bool AntiSlip = false;
        public string EngineOperatingProcedures;

        public Dictionary<string, List<ParticleEmitterData>> EffectData = new Dictionary<string,List<ParticleEmitterData>>();

        public CVFFile CVFFile = null;
        public ExtendedCVF ExCVF = null;

        public MSTSNotchController  ThrottleController;
        public MSTSBrakeController  TrainBrakeController;
        public MSTSBrakeController  EngineBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController  DynamicBrakeController;
        
        public Axle LocomotiveAxle;
        public IIRFilter CurrentFilter;
        public IIRFilter AdhesionFilter;
        
        public float FilteredMotiveForceN = 0.0f;

        public MSTSLocomotive(Simulator simulator, string wagPath, TrainCar previousCar)
            : base(simulator, wagPath, previousCar)
        {
			BrakePipeChargingRatePSIpS = simulator.Settings.BrakePipeChargingRate;

            LocomotiveAxle = new Axle();
            LocomotiveAxle.DriveType = AxleDriveType.ForceDriven;
            LocomotiveAxle.DampingNs = 5000.0f;
            LocomotiveAxle.AdhesionK = 0.7f;
            CurrentFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(1.0f),0.001f);
            AdhesionFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.1f), 0.001f);
            UseAdvancedAdhesion = true;
            //LocomotiveAxle.AxleWeightN;
            //Console.WriteLine("loco {0} {1} {2}", MaxPowerW, MaxForceN, MaxSpeedMpS);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void InitializeFromWagFile(string wagFilePath)
        {
            TrainBrakeController = new MSTSBrakeController(Simulator);
            EngineBrakeController = new MSTSBrakeController(Simulator);
            DynamicBrakeController = new MSTSNotchController();
            base.InitializeFromWagFile(wagFilePath);

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            if (CVFFileName != null)
            {
                string CVFFilePath = Path.GetDirectoryName(WagFilePath) + @"\CABVIEW\" + CVFFileName;
                CVFFile = new CVFFile(CVFFilePath);

                // Set up camera locations for the cab views
                for( int i = 0; i < CVFFile.Locations.Count; ++i )
                {
                    if (i >= CVFFile.Locations.Count || i >= CVFFile.Directions.Count)
                    {
                        Trace.TraceError("Position or Direction missing in " + CVFFilePath);
                        break;
                    }
                    ViewPoint viewPoint = new ViewPoint();
                    viewPoint.Location = CVFFile.Locations[i];
                    viewPoint.StartDirection = CVFFile.Directions[i];
                    viewPoint.RotationLimit = new Vector3( 0,0,0 );  // cab views have a fixed head position
                    FrontCabViewpoints.Add(viewPoint);
                }

                string ExtendedCVF = CVFFilePath.Substring(0, CVFFilePath.LastIndexOf('.')) + ".xml";
                ExCVF = null;

                // Commented out until the IntermediateSerializer is changed to XmlReader
                // By GeorgeS
                /*
                if (File.Exists(ExtendedCVF))
                {
                    try
                    {
                        using (XmlReader rd = XmlReader.Create(new FileStream(ExtendedCVF, FileMode.Open)))
                        {
                            ExCVF = IntermediateSerializer.Deserialize<ExtendedCVF>(rd, null);
                        }
                    }
                    catch (Exception ex)
                    {
                        Trace.TraceError(string.Format("Error reading Extended CAB View file {0}", ExtendedCVF));
                        Trace.WriteLine(ex);
                    }
                }
                */

                if (ExCVF == null && !(this is MSTSSteamLocomotive))
                {
                    ExCVF = new ExtendedCVF();
                }
            }

            IsDriveable = true;
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new MSTSBrakeController(Simulator); //create a blank one
            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;
            if (!DynamicBrakeController.IsValid())
                DynamicBrakeController = null;
            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new Interpolator2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(4);
                interp[DynamicBrakeSpeed1] = 0;
                interp[DynamicBrakeSpeed2] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        protected void ParseEffects(string lowercasetoken, STFReader stf)
        {
            stf.MustMatch("(");
            string s;

            while ((s = stf.ReadItem()) != ")")
            {
                ParticleEmitterData data = new ParticleEmitterData(stf);
                if (!EffectData.ContainsKey(s))
                {
                    EffectData.Add(s, new List<ParticleEmitterData>());
                }

                EffectData[s].Add(data);
            }
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            if (lowercasetoken.StartsWith("engine(trainbrakescontroller"))
                TrainBrakeController.ParseBrakeValue(lowercasetoken.Substring(28), stf);
            if (lowercasetoken.StartsWith("engine(enginebrakescontroller"))
                EngineBrakeController.ParseBrakeValue(lowercasetoken.Substring(29), stf);
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabview": CVFFileName = stf.ReadStringBlock(null); break;
                case "engine(maxpower": MaxPowerW = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforce": MaxForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxvelocity": MaxSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(brake_train": TrainBrakeController.Parse(stf); break;
                case "engine(enginecontrollers(brake_engine": EngineBrakeController.Parse(stf); break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(stf); break;
                case "engine(airbrakesmainresvolume": MainResVolumeFT3 = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(mainreschargingrate": MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(enginebrakereleaserate": EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(enginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakepipetimefactor": BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakeservicetimefactor": BrakeServiceTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakeemergencytimefactor": BrakeEmergencyTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakepipechargingrate": BrakePipeChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(maxtractiveforcecurves": TractiveForceCurves = new Interpolator2D(stf); break;
                case "engine(dynamicbrakeforcecurves": DynamicBrakeForceCurves = new Interpolator2D(stf); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(dynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true); break;
                case "engine(continuousforcetimefactor": ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(numwheels": NumWheels = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(antislip": AntiSlip = stf.ReadBoolBlock(false); break;
                case "engine(engineoperatingprocedures": EngineOperatingProcedures = stf.ReadStringBlock(""); break;
                case "engine(headout": HeadOutViewpoints.Add(new ViewPoint() { Location = stf.ReadVector3Block(STFReader.UNITS.None, Vector3.Zero) }); break;
                default: base.Parse(lowercasetoken, stf); break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void InitializeFromCopy(MSTSWagon copy)
        {
            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CVFFile = locoCopy.CVFFile;
            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;
            NumWheels = locoCopy.NumWheels;
            AntiSlip = locoCopy.AntiSlip;
            EffectData = locoCopy.EffectData;

            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            TrainBrakeController = (MSTSBrakeController)locoCopy.TrainBrakeController.Clone();
            EngineBrakeController = locoCopy.EngineBrakeController != null ? (MSTSBrakeController)locoCopy.EngineBrakeController.Clone() : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;

            base.InitializeFromCopy(copy);  // each derived level initializes its own variables
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(Wiper);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorOn);
            outf.Write(AverageForceN);
            outf.Write(LocomotiveAxle.AxleSpeedMpS);
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);            
            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            if (inf.ReadBoolean()) SignalEvent(EventID.BellOn);
            if (inf.ReadBoolean()) SignalEvent(EventID.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(EventID.WiperOn);
            MainResPressurePSI = inf.ReadSingle();
            CompressorOn = inf.ReadBoolean();
            AverageForceN = inf.ReadSingle();
            LocomotiveAxle.Reset(inf.ReadSingle());
            ThrottleController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            TrainBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            EngineBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            DynamicBrakeController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            AdhesionFilter.Reset(0.5f);
            
            base.Restore(inf);
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }


        /// <summary>
        /// Create a viewer for this locomotive.   Viewers are only attached
        /// while the locomotive is in viewing range.
        /// </summary>
        public override TrainCarViewer GetViewer(Viewer3D viewer)
        {
            return new MSTSLocomotiveViewer(viewer, this);
        }

        /// <summary>
        /// This is a periodic update to calculate physics 
        /// parameters and update the base class's MotiveForceN 
        /// and FrictionForceN values based on throttle settings
        /// etc for the locomotive.
        /// </summary>
        public override void Update(float elapsedClockSeconds)
        {
            TrainBrakeController.Update(elapsedClockSeconds);
            if (EngineBrakeController != null)
                EngineBrakeController.Update(elapsedClockSeconds);

            if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0))
            {
                if (this.IsLeadLocomotive())
                    DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                else
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive())
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
            else
                ThrottleController.Update(elapsedClockSeconds);

            // TODO  this is a wild simplification for electric and diesel electric
            float t = ThrottlePercent / 100f;
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            if (TractiveForceCurves == null)
            {
                float maxForceN = MaxForceN * t;
                float maxPowerW = MaxPowerW * t * t;
                if (maxForceN * currentSpeedMpS > maxPowerW)
                    maxForceN = maxPowerW / currentSpeedMpS;
                if (currentSpeedMpS > MaxSpeedMpS)
                    maxForceN= 0;
                MotiveForceN = maxForceN;
            }
            else
            {
                MotiveForceN = TractiveForceCurves.Get(t, currentSpeedMpS);
                if (MotiveForceN < 0)
                    MotiveForceN = 0;
            }

            if (MaxForceN > 0 && MaxContinuousForceN > 0)
            {
                MotiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN;
                float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * MotiveForceN;
            }
            MotiveForceN *= (Direction == Direction.Forward ? 1 : -1);

            // Variable1 is wheel rotation in m/sec for steam locomotives
            //Variable2 = Math.Abs(MotiveForceN) / MaxForceN;   // force generated
            Variable1 = ThrottlePercent / 100f;   // throttle setting
            //Variable2 = Math.Abs(WheelSpeedMpS);

            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null)
            {
                float f= DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, currentSpeedMpS);
                if (f > 0)
                    MotiveForceN -= (SpeedMpS > 0 ? 1 : -1) * f;
            }
            LimitMotiveForce(elapsedClockSeconds);

            //Force to display
            FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);

            if (MainResPressurePSI < CompressorRestartPressurePSI && !CompressorOn)
                SignalEvent(EventID.CompressorOn);
            else if (MainResPressurePSI > MaxMainResPressurePSI && CompressorOn)
                SignalEvent(EventID.CompressorOff);
            if (CompressorOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;

            base.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public void LimitMotiveForce(float elapsedClockSeconds)
        {
            if (NumWheels <= 0)
                return;
            //float max0 = MassKG * 9.8f * Adhesion3 / NumWheels;   //Not used

            //Curtius-Kniffler computation for the basic model
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float uMax = (7.5f / (currentSpeedMpS * 3.6f + 44.0f) + 0.161f); // Curtius - Kniffler equation
            float adhesionUtil = 0.95f;   //Adhesion utilization

            float max0 = MassKG * 9.81f * adhesionUtil * uMax;  //Ahesion limit in [N]
            float max1;

            if ((UseAdvancedAdhesion)&&(!Simulator.Paused))
            {
                //Set the weather coeff
                if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
                {
                    if (Train.SlipperySpotDistanceM < 0)
                    {
                        Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                        Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                    }
                    if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                        max0 = .8f;
                    if (Program.Simulator.Weather == WeatherType.Rain)
                        max0 = .6f;
                    else
                        max0 = .5f;
                }
                else
                    max0 = 1.0f;
                //add sander
                if (Sander)
                    max0 *= 1.5f;
                //Set adhesion coeff to the model
                    //Pure condition
                    //LocomotiveAxle.AdhesionConditions = max0;
                    //Filtered condition
                    //LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0, elapsedClockSeconds);
                //Filtered random condition
                LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0 + (float)(0.2*Program.Random.NextDouble()),elapsedClockSeconds);
                //LocomotiveAxle.AdhesionConditions = max0;
                //Set axle inertia (this should be placed within the ENG parser)
                // but make sure the value is sufficietn
                if (MaxPowerW < 2000000.0f)
                {
                    if (NumWheels > 4.0f)
                        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheels * 4000.0f;
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }
                else
                {
                    if (NumWheels > 4.0f)
                        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheels * MaxPowerW / 500.0f;
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }

                //Set axle model parameters
                
                //LocomotiveAxle.BrakeForceN = FrictionForceN;
                LocomotiveAxle.BrakeForceN = BrakeForceN;
                LocomotiveAxle.AxleWeightN = 9.81f * MassKG;        //will be computed each time considering the tilting
                LocomotiveAxle.DriveForceN = MotiveForceN;           //Developed force
                
                LocomotiveAxle.TrainSpeedMpS = SpeedMpS;            //Set the train speed of the axle model
                MotiveForceN = LocomotiveAxle.AxleForceN;           //Get the Axle force and use it for the motion
                WheelSlip = LocomotiveAxle.IsWheelSlip;             //Get the wheelslip indicator
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;

                LocomotiveAxle.Update(elapsedClockSeconds);         //Main updater of the axle model
            }
            else
            {
                if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
                {
                    if (Train.SlipperySpotDistanceM < 0)
                    {
                        Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                        Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                    }
                    if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                        max0 *= .8f;
                    if (Program.Simulator.Weather == WeatherType.Rain)
                        max0 *= .8f;
                    else
                        max0 *= .7f;
                }
                //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
                max1 = (Sander ? 1.5f : 1.0f) * max0; //Increase adhesion when sander is on
                WheelSlip = false;

                if (MotiveForceN > max1)
                {
                    WheelSlip = true;
                    if (AntiSlip)
                        MotiveForceN = max1;
                    else
                        MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
                }
                else if (MotiveForceN < -max1)
                {
                    WheelSlip = true;
                    if (AntiSlip)
                        MotiveForceN = -max1;
                    else
                        MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
                }
            }
        }
        public void LimitMotiveForce()
        {
            if (NumWheels <= 0)
                return;
            //float max0 = MassKG * 9.8f * Adhesion3 / NumWheels;   //Not used

            //Curtius-Kniffler computation
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float uMax = (7.5f / (currentSpeedMpS * 3.6f + 44.0f) + 0.161f); // Curtius - Kniffler equation
            float adhesionUtil = 0.95f;   //Adhesion utilization

            float max0 = MassKG * 9.81f * adhesionUtil * uMax;  //Ahesion limit in [N]
            float max1;

            if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= .8f;
                if (Program.Simulator.Weather == WeatherType.Rain)
                    max0 *= .8f;
                else
                    max0 *= .7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = (Sander ? 1.5f : 1.0f) * max0; //Increase adhesion when sander is on
            WheelSlip = false;

            if (MotiveForceN > max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }
        }

        public override bool GetSanderOn()
        {
            return Sander;
        }

        public void SetDirection( Direction direction )
        {
            // Direction Control
            if ( Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                if (direction == Direction.Forward)
                {
                    SignalEvent(EventID.Forward);
                    Train.MUReverserPercent = 100;
                }
                else
                {
                    SignalEvent(EventID.Reverse);
                    Train.MUReverserPercent = -100;
                }
            }
        }        

        public void StartThrottleIncrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }
            ThrottleController.StartIncrease();

            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.PowerHandler);
        }

        public void StopThrottleIncrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }

            ThrottleController.StopIncrease();
        }

        public void StartThrottleDecrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }
            ThrottleController.StartDecrease();

            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.PowerHandler);
        }

        public void StopThrottleDecrease()
        {
            if (DynamicBrakePercent >= 0)
            {
                // signal sound
                return;
            }

            ThrottleController.StopDecrease();
        }

        public void SetThrottlePercent(float percent)
        {
            ThrottlePercent = ThrottleController.SetRDPercent(percent);
        }

        public void StartTrainBrakeIncrease()
        {
            TrainBrakeController.StartIncrease();
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.TrainBrakeSet);
        }

        public void StopTrainBrakeIncrease()
        {
            TrainBrakeController.StopIncrease();
        }

        public void StartTrainBrakeDecrease()
        {
            TrainBrakeController.StartDecrease();
            // By GeorgeS
            if (EventID.IsMSTSBin)
                SignalEvent(EventID.TrainBrakeSet);
        }

        public void StopTrainBrakeDecrease()
        {
            TrainBrakeController.StopDecrease();
        }

        public void SetTrainBrakePercent(float percent)
        {
            TrainBrakeController.SetRDPercent(percent);
        }

        public void SetEmergency()
        {
            if (TrainBrakeController.GetIsEmergency())
                return;
            TrainBrakeController.SetEmergency();
            SignalEvent(EventID.TrainBrakeEmergency);
        }

        public override string GetTrainBrakeStatus()
        {            
            string s = TrainBrakeController.GetStatus();
            if (BrakeSystem.GetType() == typeof(AirSinglePipe))
                s += string.Format(" EQ {0:F0} psi", Train.BrakeLine1PressurePSI);
            else
                s += string.Format(" BP {0:F0} psi", Train.BrakeLine1PressurePSI);
            s += " (cars: " + BrakeSystem.GetFullStatus();
            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            if (lastCar != this)
                s += " to " + lastCar.BrakeSystem.GetStatus();
			s += ")";
            return s;
        }

        public void StartEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartIncrease();
        }

        public void StopEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StopIncrease();
        }

        public void StartEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartDecrease();
        }

        public void StopEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StopDecrease();
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetRDPercent(percent);
        }
  
        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");
        }

        public void SetBailOff(bool bailOff)
        {
            BailOff = bailOff;
        }

        private bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null && DynamicBrakeForceCurves != null && ThrottlePercent == 0);
        }

        public void StartDynamicBrakeIncrease()
        {
            if(!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0)
            {
                //activate it
                DynamicBrakePercent = 0;
                return;
            }
            else
                DynamicBrakeController.StartIncrease();
        }

        public void StopDynamicBrakeIncrease()
        {
            if (!CanUseDynamicBrake())
                return;

            DynamicBrakeController.StopIncrease();
        }

        public void StartDynamicBrakeDecrease()
        {
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0)
                DynamicBrakePercent = -1;
            else
            {
                DynamicBrakeController.StartDecrease();
            }
        }

        public void StopDynamicBrakeDecrease()
        {
            if (!CanUseDynamicBrake())
                return;

            DynamicBrakeController.StopDecrease();
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakePercent = DynamicBrakeController.SetRDPercent(percent);
            if (percent < 0)
                DynamicBrakePercent = percent;
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null || DynamicBrakePercent < 0)
                return null;
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }
        
        /// <summary>
        /// Used when someone want to notify us of an event
        /// </summary>
        public override void SignalEvent(EventID eventID)
        {
            // Modified according to replacable IDs - by GeorgeS
            //switch (eventID)
            do
            {
                if (eventID == EventID.BellOn) { Bell = true; break; }
                if (eventID == EventID.BellOff) {  Bell = false; break; }
                if (eventID == EventID.HornOn) { Horn = true; break; }
                if (eventID == EventID.HornOff) { Horn = false; break; }
                if (eventID == EventID.SanderOn) { Sander = true; break; }
                if (eventID == EventID.SanderOff) { Sander = false; break; }
                if (eventID == EventID.WiperOn) { Wiper = true; break; }
                if (eventID == EventID.WiperOff) { Wiper = false; break; }
                if (eventID == EventID.HeadlightOff) { Headlight = 0; break; }
                if (eventID == EventID.HeadlightDim) { Headlight = 1; break; }
                if (eventID == EventID.HeadlightOn) {  Headlight = 2; break; }
                if (eventID == EventID.CompressorOn) { CompressorOn = true; break; }
                if (eventID == EventID.CompressorOff) { CompressorOn = false; break; }
				if (eventID == EventID.LightSwitchToggle) { break; }
			} while (false);

            base.SignalEvent(eventID );
        }

        /// <summary>
        /// Gets the Locomotive data needed by the Cav View Control
        /// Check here for Signal display
        /// </summary>
        /// <param name="cvc">The Cab View Control</param>
        /// <returns>The data converted to the requested unit</returns>
        public virtual float GetDataOf(CabViewControl cvc)
        {
            float data;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        //data = SpeedMpS;
                        data = WheelSpeedMpS;
                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else
                            data *= 2.2369f;
                        //data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.AMMETER:
                case CABViewControlTypes.LOAD_METER:
                    {
                        if (LocomotiveAxle != null)
                        {
                            if (FilteredMotiveForceN != 0)
                                data = this.FilteredMotiveForceN / MaxForceN * (float)cvc.MaxValue;
                            else
                                data = this.LocomotiveAxle.AxleForceN / MaxForceN * (float)cvc.MaxValue;
                            break;
                        }
                        data = this.MotiveForceN / MaxForceN * (float)cvc.MaxValue;
                        break;
                    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = this.MainResPressurePSI;
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                case CABViewControlTypes.EQ_RES:
                    {
                        data = this.BrakeSystem.BrakeLine1PressurePSI;
                        if (cvc.Units == CABViewControlUnits.BAR)
                            data *= 68.948e-3f;
                        else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                            data *= 6.89476f;
                        else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                            data *= 70.307e-3f;
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        AirSinglePipe asp = BrakeSystem as AirSinglePipe;
                        if (asp != null)
                        {
                            data = asp.CylPSIPressure;
                            if (cvc.Units == CABViewControlUnits.BAR)
                                data *= 68.948e-3f;
                            else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                                data *= 6.89476f;
                            else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                                data *= 70.307e-3f;
                        }
                        else
                        {
                            data = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                    //case CABViewControlTypes.CPH_DISPLAY:
                    {
                        data = ThrottlePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        data = EngineBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        data = TrainBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    {
                        data = DynamicBrakePercent;
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        data = Wiper ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HORN:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        data = Headlight;
                        break;
                    }
                //case CABViewControlTypes.WHEELSLIP:
                //    {
                //        data = WheelSlip ? 1 : 0;
                //        break;
                //    }
    
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        if (Direction == Direction.Forward)
                            data = 2;
                        else if (Direction == Direction.Reverse)
                            data = 0;
                        else
                            data = 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (Train.CABAspect)
                        {
                            case SignalHead.SIGASP.STOP:
                                {
                                    data = 0;
                                    break;
                                }
                            case SignalHead.SIGASP.STOP_AND_PROCEED:
                                {
                                    data = 1;
                                    break;
                                }
                            case SignalHead.SIGASP.RESTRICTING:
                                {
                                    data = 2;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_1:
                                {
                                    data = 3;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_2:
                                {
                                    data = 4;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_3:
                            case SignalHead.SIGASP.APPROACH_4:
                                {
                                    data = 5;
                                    break;
                                }
                            case SignalHead.SIGASP.CLEAR_1:
                            case SignalHead.SIGASP.CLEAR_2:
                            case SignalHead.SIGASP.CLEAR_3:
                            case SignalHead.SIGASP.CLEAR_4:
                                {
                                    data = 6;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                default:
                    {
                        data = 0;
                        break;
                    }
            }
            return data;
        }

    } // LocomotiveSimulator

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    public class ExtendedCVF
    {
        /// <summary>
        /// Represents a Light in the CAB.
        /// </summary>
        public class Light
        {
            /// <summary>
            /// X,Y : Position of the light, Z : Radius, W : Aspect ratio X:Y
            /// </summary>
            public Vector4 Position = new Vector4(0);
            public Color Color = Color.Black;

            /// <summary>
            /// Translate to current screen resolution
            /// </summary>
            /// <param name="displaySize">Current screen resolution</param>
            /// <returns>Translated vectors</returns>
            public Vector4 TranslatedPosition(Point displaySize)
            {
                return new Vector4(Position.X / 640 * displaySize.X, 
                    Position.Y / 480 * displaySize.Y, 
                    Position.Z / 640 * displaySize.X,
                    Position.W);
            }

            /// <summary>
            /// Used by the shader
            /// </summary>
            public Vector3 TranslatedColor
            {
                get
                {
                    return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
                }
            }
        }

        [ContentSerializer(Optional = true)]
        public Light Light1 = new Light() { Color = new Color(0xFF, 0xD8, 0xB2, 0xFF), Position = new Vector4(320, 360, 155, 2) };
        [ContentSerializer(Optional = true)]
        public Light Light2 = new Light();
    }

    ///////////////////////////////////////////////////
    ///   3D VIEW
    ///////////////////////////////////////////////////

    /// <summary>
    /// Adds animation for wipers to the basic TrainCar
    /// </summary>
    public class MSTSLocomotiveViewer : MSTSWagonViewer
    {
        MSTSLocomotive Locomotive;

        protected Dictionary<string, List<ParticleEmitterDrawer>> ParticleDrawers = new Dictionary<string, List<ParticleEmitterDrawer>>();
        List<int> WiperPartIndexes = new List<int>();

        float WiperAnimationKey = 0;

        protected MSTSLocomotive MSTSLocomotive { get { return (MSTSLocomotive)Car; } }

        private CabRenderer _CabRenderer = null;

        public MSTSLocomotiveViewer(Viewer3D viewer, MSTSLocomotive car)
            : base(viewer, car)
        {
            Locomotive = car;

            foreach (KeyValuePair<string, List<ParticleEmitterData>> pair in Locomotive.EffectData)
            {
                ParticleDrawers.Add(pair.Key, new List<ParticleEmitterDrawer>());

                foreach (ParticleEmitterData data in pair.Value)
                {
                    ParticleDrawers[pair.Key].Add(new ParticleEmitterDrawer(viewer, data));
                }                
            }

            if (car.CVFFile != null && car.CVFFile.TwoDViews.Count > 0)
                _CabRenderer = new CabRenderer(viewer, Locomotive);

            // Find the animated parts
            if (TrainCarShape.SharedShape.Animations != null)
            {
				for (int iMatrix = 0; iMatrix < TrainCarShape.SharedShape.MatrixNames.Count; ++iMatrix)
                {
                    string matrixName = TrainCarShape.SharedShape.MatrixNames[iMatrix].ToUpper();
                    switch (matrixName)
                    {
                        case "WIPERARMLEFT1":
                        case "WIPERBLADELEFT1":
                        case "WIPERARMRIGHT1":
                        case "WIPERBLADERIGHT1":
                            if (TrainCarShape.SharedShape.Animations[0].FrameCount > 1)  // ensure shape file is properly animated for wipers
                                WiperPartIndexes.Add(iMatrix);
                            break;
                        case "MIRRORARMLEFT1":
                        case "MIRRORLEFT1":
                        case "MIRRORARMRIGHT1":
                        case "MIRRORRIGHT1":
                            // TODO
                            break;
                    }
                }
            }

            string wagonFolderSlash = Path.GetDirectoryName(Locomotive.WagFilePath) + "\\";
            if (Locomotive.CabSoundFileName != null) LoadCarSound(wagonFolderSlash, Locomotive.CabSoundFileName);

        }

        /// <summary>
        /// A keyboard or mouse click has occurred. Read the UserInput
        /// structure to determine what was pressed.
        /// </summary>
        public override void HandleUserInput(ElapsedTime elapsedTime)
        {
            if (UserInput.IsPressed(UserCommands.ControlForwards)) Locomotive.SetDirection(Direction.Forward);
			if (UserInput.IsPressed(UserCommands.ControlBackwards)) Locomotive.SetDirection(Direction.Reverse);

			if (UserInput.IsPressed(UserCommands.ControlThrottleIncrease)) Locomotive.StartThrottleIncrease();
			if (UserInput.IsReleased(UserCommands.ControlThrottleIncrease)) Locomotive.StopThrottleIncrease();
			if (UserInput.IsPressed(UserCommands.ControlThrottleDecrease)) Locomotive.StartThrottleDecrease();
			if (UserInput.IsReleased(UserCommands.ControlThrottleDecrease)) Locomotive.StopThrottleDecrease();

			if (UserInput.IsPressed(UserCommands.ControlTrainBrakeIncrease)) Locomotive.StartTrainBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlTrainBrakeIncrease)) Locomotive.StopTrainBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlTrainBrakeDecrease)) Locomotive.StartTrainBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlTrainBrakeDecrease)) Locomotive.StopTrainBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlEngineBrakeIncrease)) Locomotive.StartEngineBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlEngineBrakeIncrease)) Locomotive.StopEngineBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlEngineBrakeDecrease)) Locomotive.StartEngineBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlEngineBrakeDecrease)) Locomotive.StopEngineBrakeDecrease();

			if (UserInput.IsPressed(UserCommands.ControlDynamicBrakeIncrease)) Locomotive.StartDynamicBrakeIncrease();
			if (UserInput.IsReleased(UserCommands.ControlDynamicBrakeIncrease)) Locomotive.StopDynamicBrakeIncrease();
			if (UserInput.IsPressed(UserCommands.ControlDynamicBrakeDecrease)) Locomotive.StartDynamicBrakeDecrease();
			if (UserInput.IsReleased(UserCommands.ControlDynamicBrakeDecrease)) Locomotive.StopDynamicBrakeDecrease();

			Locomotive.SetBailOff(UserInput.IsDown(UserCommands.ControlBailOff));
			if (UserInput.IsPressed(UserCommands.ControlInitializeBrakes)) Locomotive.Train.InitializeBrakes();
			if (UserInput.IsPressed(UserCommands.ControlHandbrakeNone)) Locomotive.Train.SetHandbrakePercent(0);
			if (UserInput.IsPressed(UserCommands.ControlHandbrakeFull)) Locomotive.Train.SetHandbrakePercent(100);
			if (UserInput.IsPressed(UserCommands.ControlRetainersOff)) Locomotive.Train.SetRetainers(false);
			if (UserInput.IsPressed(UserCommands.ControlRetainersOn)) Locomotive.Train.SetRetainers(true);
			if (UserInput.IsPressed(UserCommands.ControlBrakeHoseConnect)) Locomotive.Train.ConnectBrakeHoses();
			if (UserInput.IsPressed(UserCommands.ControlBrakeHoseDisconnect)) Locomotive.Train.DisconnectBrakes();
			if (UserInput.IsPressed(UserCommands.ControlEmergency)) Locomotive.SetEmergency();
			if (UserInput.IsPressed(UserCommands.ControlSander)) Locomotive.Train.SignalEvent(Locomotive.Sander ? EventID.SanderOff : EventID.SanderOn);
			if (UserInput.IsPressed(UserCommands.ControlWiper)) Locomotive.SignalEvent(Locomotive.Wiper ? EventID.WiperOff : EventID.WiperOn);
			if (UserInput.IsPressed(UserCommands.ControlHorn)) Locomotive.SignalEvent(EventID.HornOn);
			if (UserInput.IsReleased(UserCommands.ControlHorn)) Locomotive.SignalEvent(EventID.HornOff);
			if (UserInput.IsPressed(UserCommands.ControlBell)) Locomotive.SignalEvent(EventID.BellOn);
			if (UserInput.IsReleased(UserCommands.ControlBell)) Locomotive.SignalEvent(EventID.BellOff);
			if (UserInput.IsPressed(UserCommands.ControlHeadlightDecrease))
            {
                switch ((Locomotive.Headlight))
                {
                    case 1: Locomotive.Headlight = 0; break;
                    case 2: Locomotive.Headlight = 1; break;
                }
                // By GeorgeS
                if (EventID.IsMSTSBin)
                    Locomotive.SignalEvent(EventID.LightSwitchToggle);
            }
			else if (UserInput.IsPressed(UserCommands.ControlHeadlightIncrease))
            {
                switch ((Locomotive.Headlight))
                {
                    case 0: Locomotive.Headlight = 1; break;
                    case 1: Locomotive.Headlight = 2; break;
                }
                // By GeorgeS
                if (EventID.IsMSTSBin)
                    Locomotive.SignalEvent(EventID.LightSwitchToggle);
            }
			if (UserInput.IsPressed(UserCommands.DebugDispatcherExtend))
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization();
			if (UserInput.IsPressed(UserCommands.DebugDispatcherRelease))
                Program.Simulator.AI.Dispatcher.ReleasePlayerAuthorization();

            // By GeorgeS
            if (UserInput.IsPressed(UserCommands.ControlLight)) { Locomotive.CabLightOn = !Locomotive.CabLightOn; Locomotive.SignalEvent(EventID.LightSwitchToggle); }
            if (UserInput.IsPressed(UserCommands.CameraToggleShowCab)) Locomotive.ShowCab = !Locomotive.ShowCab;

            if (UserInput.RDState != null)
            {
                if (UserInput.RDState.BailOff)
                    Locomotive.SetBailOff(true);
                if (UserInput.RDState.Changed)
                {
                    Locomotive.SetThrottlePercent(UserInput.RDState.ThrottlePercent);
                    Locomotive.SetTrainBrakePercent(UserInput.RDState.TrainBrakePercent);
                    Locomotive.SetEngineBrakePercent(UserInput.RDState.EngineBrakePercent);
                    Locomotive.SetDynamicBrakePercent(UserInput.RDState.DynamicBrakePercent);
                    if (UserInput.RDState.DirectionPercent > 50)
                        Locomotive.SetDirection(Direction.Forward);
                    else if (UserInput.RDState.DirectionPercent < -50)
                        Locomotive.SetDirection(Direction.Reverse);
                    if (UserInput.RDState.Emergency)
                        Locomotive.SetEmergency();
                    if (UserInput.RDState.Wipers == 1 && Locomotive.Wiper)
                        Locomotive.SignalEvent(EventID.WiperOff);
                    if (UserInput.RDState.Wipers != 1 && !Locomotive.Wiper)
                        Locomotive.SignalEvent(EventID.WiperOn);
                    // changing Headlight more than one step at a time doesn't work for some reason
                    if (Locomotive.Headlight < UserInput.RDState.Lights - 1)
                        Locomotive.Headlight++;
                    if (Locomotive.Headlight > UserInput.RDState.Lights - 1)
                        Locomotive.Headlight--;
                }
            }

			base.HandleUserInput(elapsedTime);
        }

        /// <summary>
        /// We are about to display a video frame.  Calculate positions for 
        /// animated objects, and add their primitives to the RenderFrame list.
        /// </summary>
        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
        {
            float elapsedClockSeconds = elapsedTime.ClockSeconds;

            foreach (List<ParticleEmitterDrawer> drawers in ParticleDrawers.Values)
            {
                foreach (ParticleEmitterDrawer drawer in drawers)
                {
                    drawer.WorldPosition = Locomotive.WorldPosition;
                    drawer.PrepareFrame(frame, elapsedTime);
                }
            }

            // Wiper animation
            if (WiperPartIndexes.Count > 0)  // skip this if there are no wipers
            {
                if (Locomotive.Wiper) // on
                {
                    // Wiper Animation
                    // Compute the animation key based on framerate etc
                    // ie, with 8 frames of animation, the key will advance from 0 to 8 at the specified speed.
                    WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 10f) * elapsedClockSeconds;
                    while (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey -= TrainCarShape.SharedShape.Animations[0].FrameCount;
                    while (WiperAnimationKey < -0.00001) WiperAnimationKey += TrainCarShape.SharedShape.Animations[0].FrameCount;
                    foreach (int iMatrix in WiperPartIndexes)
                        TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                }
                else // off
                {
                    if (WiperAnimationKey > 0.001)  // park the blades
                    {
                        WiperAnimationKey += ((float)TrainCarShape.SharedShape.Animations[0].FrameRate / 10f) * elapsedClockSeconds;
                        if (WiperAnimationKey >= TrainCarShape.SharedShape.Animations[0].FrameCount) WiperAnimationKey = 0;
                        foreach (int iMatrix in WiperPartIndexes)
                            TrainCarShape.AnimateMatrix(iMatrix, WiperAnimationKey);
                    }
                }
            }

            // Draw 2D CAB View - by GeorgeS
            if (Viewer.Camera.AttachedCar == this.MSTSWagon &&
                Viewer.Camera.Style == Camera.Styles.Cab &&
                _CabRenderer != null)
                _CabRenderer.PrepareFrame(frame);
            
            base.PrepareFrame( frame, elapsedTime );
        }


        /// <summary>
        /// This doesn't function yet.
        /// </summary>
        public override void Unload()
        {
            base.Unload();
        }

    } // Class LocomotiveViewer

    // By GeorgeS
    /// <summary>
    /// Manages all CAB View textures - light conditions and texture parts
    /// </summary>
    public static class CABTextureManager
    {
        private static Dictionary<string, Texture2D> DayTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> NightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> LightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D[]> PDayTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PNightTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PLightTextures = new Dictionary<string, Texture2D[]>();

        /// <summary>
        /// Loads a texture, day night and cablight
        /// </summary>
        /// <param name="viewer">Viver3D</param>
        /// <param name="FileName">Name of the Texture</param>
        public static void LoadTextures(Viewer3D viewer, string FileName)
        {
            if (string.IsNullOrEmpty(FileName))
                return;

            if (DayTextures.Keys.Contains(FileName))
                return;

            Texture2D tex;

            if (File.Exists(FileName))
            {
                tex = SharedTextureManager.Get(viewer.GraphicsDevice, FileName);
                DayTextures.Add(FileName, tex);
            }
            else
                DayTextures.Add(FileName, Materials.MissingTexture);

            string nightpath = FileName.Substring(0, FileName.LastIndexOf('\\')) + "\\night" + FileName.Substring(FileName.LastIndexOf('\\'));
            if (File.Exists(nightpath))
            {
                tex = SharedTextureManager.Get(viewer.GraphicsDevice, nightpath);
                NightTextures.Add(FileName, tex);
            }
            else
                NightTextures.Add(FileName, Materials.MissingTexture);

            string lightpath = FileName.Substring(0, FileName.LastIndexOf('\\')) + "\\cablight" + FileName.Substring(FileName.LastIndexOf('\\'));
            if (File.Exists(lightpath))
            {
                tex = SharedTextureManager.Get(viewer.GraphicsDevice, lightpath);
                LightTextures.Add(FileName, tex);
            }
            else
                LightTextures.Add(FileName, Materials.MissingTexture);
        }

        /// <summary>
        /// Disassembles a compund Texture into parts
        /// </summary>
        /// <param name="graphicsDevice">The GraphicsDevice</param>
        /// <param name="tex">Texture to be disassembled</param>
        /// <param name="width">Width of the Cab View Control</param>
        /// <param name="height">Height of the Cab View Control</param>
        /// <param name="FramesCount">Number of frames read from CVF</param>
        /// <param name="FileName">Name of the control ACE file</param>
        /// <returns>Array with Textures disassembled</returns>
        private static Texture2D[] Disassemble(GraphicsDevice graphicsDevice, Texture2D tex, int width, int height, int FramesCount, string FileName)
        {
            Texture2D dtex;
            Color[] arr = new Color[width * height];
            Texture2D[] dest;

            // Problem with texture sizes, could not disassemble
            if (width == 0 || height == 0 || tex.Width / width == 0 || tex.Height / height == 0)
            {
                Trace.TraceWarning(string.Format("Could not disassemble texture {0}. Texture width is {1}, height is {2}; Control width is {3}, height is {4}",
                    FileName, tex.Width, tex.Height, width, height));

                dest = new Texture2D[FramesCount];
                for (int i = 0; i < FramesCount; i++)
                    dest[i] = Materials.MissingTexture;
            }
            else
            {
                int wcou = tex.Width / width;
                int hcou = tex.Height / height;
                int texcou = FramesCount;

                // Problem with texture size, disassemble and later fill with missing the rest
                if (hcou * wcou != FramesCount)
                {
                    if (hcou * wcou > FramesCount)
                        texcou = hcou * wcou;

                    Trace.TraceWarning(string.Format("Frames count mismatch in {0}. Specified frames: {1}, texture frames: {2}. Using frames number {3}.",
                        FileName, FramesCount, hcou * wcou, texcou));
                }

                dest = new Texture2D[texcou];
                int indx = 0;

                for (int j = 0; j < hcou; j++)
                {
                    for (int i = 0; i < wcou; i++)
                    {
                        tex.GetData<Color>(0, new Rectangle(i * width, j * height, width, height),
                            arr, 0, width * height);

                        dtex = new Texture2D(graphicsDevice, width, height);
                        dtex.SetData<Color>(arr);
                        dest[indx] = dtex;
                        indx++;
                    }
                }

                // Fill missing the rest if has any
                while (indx < FramesCount)
                {
                    dest[indx] = Materials.MissingTexture;
                    indx++;
                }
            }
            return dest;
        }
        
        /// <summary>
        /// Disassembles all compund textures into parts
        /// </summary>
        /// <param name="graphicsDevice">The GraphicsDevice</param>
        /// <param name="FileName">Name of the Texture to be disassembled</param>
        /// <param name="width">Width of the Cab View Control</param>
        /// <param name="height">Height of the Cab View Control</param>
        /// <param name="FramesCount">Number of frames, read from CVF</param>
        public static void DisassembleTexture(GraphicsDevice graphicsDevice, string FileName, int width, int height, int FramesCount)
        {
            PDayTextures[FileName] = null;
            if (DayTextures.ContainsKey(FileName))
            {
                var tex = DayTextures[FileName];
                if (tex != Materials.MissingTexture)
                {
                    PDayTextures[FileName] = Disassemble(graphicsDevice, tex, width, height, FramesCount, FileName + ":day");
                }
            }

            PNightTextures[FileName] = null;
            if (NightTextures.ContainsKey(FileName))
            {
                var tex = NightTextures[FileName];
                if (tex != Materials.MissingTexture)
                {
                    PNightTextures[FileName] = Disassemble(graphicsDevice, tex, width, height, FramesCount, FileName + ":night");
                }
            }

            PLightTextures[FileName] = null;
            if (LightTextures.ContainsKey(FileName))
            {
                var tex = LightTextures[FileName];
                if (tex != Materials.MissingTexture)
                {
                    PLightTextures[FileName] = Disassemble(graphicsDevice, tex, width, height, FramesCount, FileName + ":light");
                }
            }
        }

        /// <summary>
        /// Gets a Texture from the given array
        /// </summary>
        /// <param name="arr">Texture array</param>
        /// <param name="indx">Index</param>
        /// <param name="FileName">Name of the file to report</param>
        /// <returns>The given Texture</returns>
        private static Texture2D SafeGetAt(Texture2D[] arr, int indx, string FileName)
        {
            if (arr == null)
            {
                Trace.TraceWarning(string.Format("Passed null Texture[] for accessing: {0}", FileName));
                return Materials.MissingTexture;
            }
            
            if (arr.Length < 1)
            {
                Trace.TraceWarning(string.Format("Disassembled texture invalid for: {0}", FileName));
                return Materials.MissingTexture;
            }
            
            indx = (int)MathHelper.Clamp(indx, 0, arr.Length - 1);

            try
            {
                return arr[indx];
            }
            catch
            {
                Trace.TraceError(string.Format("Error accessing texture for: {0}", FileName));
                Trace.TraceWarning(string.Format("The array length is {0}, while the index is {1}.", arr.Length, indx));
                return Materials.MissingTexture;
            }
        }

        /// <summary>
        /// Returns the compound part of a Texture previously disassembled
        /// </summary>
        /// <param name="FileName">Name of the disassembled Texture</param>
        /// <param name="indx">Index of the part</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <param name="isNightTexture"></param>
        /// <returns>The Texture represented by its index</returns>
        public static Texture2D GetTextureByIndexes(string FileName, int indx, bool isDark, bool isLight, out bool isNightTexture)
        {
            Texture2D retval = Materials.MissingTexture;
            Texture2D[] tmp = null;

            isNightTexture = false;

            if (string.IsNullOrEmpty(FileName) || !PDayTextures.Keys.Contains(FileName))
                return Materials.MissingTexture;

            if (isDark)
            {
                if (isLight)
                {
                    //tmp = PLightTextures[FileName];
                    tmp = PDayTextures[FileName];
                    if (tmp != null)
                    {
                        retval = SafeGetAt(tmp, indx, FileName);
                        isNightTexture = false;
                    }
                }

                if (retval == Materials.MissingTexture)
                {
                    tmp = PNightTextures[FileName];
                    if (tmp != null)
                    {
                        retval = SafeGetAt(tmp, indx, FileName);
                        isNightTexture = true;
                    }
                }
            }

            if (retval == Materials.MissingTexture)
            {
                tmp = PDayTextures[FileName];
                if (tmp != null)
                {
                    retval = SafeGetAt(tmp, indx, FileName);
                    isNightTexture = false;
                }
            }
            return retval;
        }

        /// <summary>
        /// Returns a Texture by its name
        /// </summary>
        /// <param name="FileName">Name of the Texture</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <param name="isNightTexture"></param>
        /// <returns>The Texture</returns>
        public static Texture2D GetTexture(string FileName, bool isDark, bool isLight, out bool isNightTexture)
        {
            Texture2D retval = Materials.MissingTexture;
            isNightTexture = false;

            if (string.IsNullOrEmpty(FileName) || !DayTextures.Keys.Contains(FileName))
                return retval;

            if (isDark)
            {
                if (isLight)
                {
                    //retval = LightTextures[FileName];
                    retval = DayTextures[FileName];
                    isNightTexture = false;
                }

                if (retval == Materials.MissingTexture)
                {
                    retval = NightTextures[FileName];
                    isNightTexture = true;
                }
            }

            if (retval == Materials.MissingTexture)
            {
                retval = DayTextures[FileName];
                isNightTexture = false;
            }

            return retval;
        }
    }

    public class CabRenderer : RenderPrimitive
    {
        private Rectangle _CabRect = new Rectangle();
        private Matrix _Scale = Matrix.Identity;
        private Texture2D _CabTexture;
        private CabShader _Shader;

        private Point _PrevScreenSize;

        private CabViewControls CabViewControls;
        private List<CabViewControlRenderer> CabViewControlRenderers = new List<CabViewControlRenderer>();

        private Viewer3D _Viewer;
        private MSTSLocomotive _Locomotive;
        private int _Location;
        private bool _isNightTexture;

        public CabRenderer(Viewer3D viewer, MSTSLocomotive car)
        {
			//Sequence = RenderPrimitiveSequence.CabView;
            _Viewer = viewer;
            _Locomotive = car;

            if (_Locomotive.ExCVF != null)
            {
                _Shader = new CabShader(viewer.GraphicsDevice, viewer.RenderProcess.Content,
                    _Locomotive.ExCVF.Light1.TranslatedPosition(_Viewer.DisplaySize),
                    _Locomotive.ExCVF.Light2.TranslatedPosition(_Viewer.DisplaySize),
                    _Locomotive.ExCVF.Light1.TranslatedColor, _Locomotive.ExCVF.Light2.TranslatedColor);
            }
            _PrevScreenSize = _Viewer.DisplaySize;

            // Loading ACE files, skip displaying ERROR messages
            foreach (string cabfile in car.CVFFile.TwoDViews)
            {
                CABTextureManager.LoadTextures(viewer, cabfile);
            }

            #region Create Control renderers
            CabViewControls = car.CVFFile.CabViewControls;
            if (CabViewControls != null)
            {
                foreach (CabViewControl cvc in CabViewControls)
                {
                    CVCDial dial = cvc as CVCDial;
                    if (dial != null)
                    {
                        CabViewDialRenderer cvcr = new CabViewDialRenderer(dial, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvcr);
                        continue;
                    }
                    CVCGauge gauge = cvc as CVCGauge;
                    if (gauge != null)
                    {
                        CabViewGaugeRenderer cvgr = new CabViewGaugeRenderer(gauge, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvgr);
                        continue;
                    }
                    CVCSignal asp = cvc as CVCSignal;
                    if (asp != null)
                    {
                        CabViewDiscreteRenderer aspr = new CabViewDiscreteRenderer(asp, viewer, car, _Shader);
                        CabViewControlRenderers.Add(aspr);
                        continue;
                    }
                    CVCMultiStateDisplay multi = cvc as CVCMultiStateDisplay;
                    if (multi != null)
                    {
                        CabViewDiscreteRenderer mspr = new CabViewDiscreteRenderer(multi, viewer, car, _Shader);
                        CabViewControlRenderers.Add(mspr);
                        continue;
                    }
                    CVCDiscrete disc = cvc as CVCDiscrete;
                    if (disc != null)
                    {
                        CabViewDiscreteRenderer cvdr = new CabViewDiscreteRenderer(disc, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvdr);
                        continue;
                    }
                    CVCDigital digital = cvc as CVCDigital;
                    if (digital != null)
                    {
                        CabViewDigitalRenderer cvdr = new CabViewDigitalRenderer(digital, viewer, car, _Shader);
                        CabViewControlRenderers.Add(cvdr);
                        continue;
                    }
                }
            }
            #endregion
        }

        public void PrepareFrame(RenderFrame frame)
        {
            if (!_Locomotive.ShowCab)
                return;

            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            CabCamera cbc = _Viewer.Camera as CabCamera;
            if (cbc != null)
            {
                _Location = cbc.SideLocation;
            }
            else
            {
                _Location = 0;
            }

            _CabTexture = CABTextureManager.GetTexture(_Locomotive.CVFFile.TwoDViews[_Location], Dark, CabLight, out _isNightTexture);

            if (_CabTexture == Materials.MissingTexture)
                return;

            _CabRect.Width = _Viewer.DisplaySize.X;
            _CabRect.Height = _Viewer.DisplaySize.Y;

            if (_PrevScreenSize != _Viewer.DisplaySize && _Shader != null)
            {
                _PrevScreenSize = _Viewer.DisplaySize;
                _Shader.SetLightPositions(
                    _Locomotive.ExCVF.Light1.TranslatedPosition(_Viewer.DisplaySize),
                    _Locomotive.ExCVF.Light2.TranslatedPosition(_Viewer.DisplaySize));
            }

            frame.AddPrimitive(Materials.SpriteBatchMaterial, this, RenderPrimitiveGroup.Cab, ref _Scale);

            if (_Location == 0)
            {
                foreach (CabViewControlRenderer cvcr in CabViewControlRenderers)
                {
                    cvcr.PrepareFrame(frame);
                }
            }
        }
        
        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (_Location == 0 && _Shader != null)
            {
                _Shader.SetData(Materials.sunDirection,
                    _isNightTexture, _Locomotive.CabLightOn, _Viewer.SkyDrawer.overcast);

                _Shader.SetTexData(_CabRect.Left, _CabRect.Top, _CabRect.Width, _CabRect.Height);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }

            Materials.SpriteBatchMaterial.SpriteBatch.Draw(_CabTexture, _CabRect, Color.White);

            if (_Location == 0 && _Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }
    }

    /// <summary>
    /// Base class for rendering Cab Controls
    /// </summary>
    public class CabViewControlRenderer : RenderPrimitive
    {
        protected CabViewControl _CabViewControl;
        protected Matrix _Matrix = Matrix.Identity;
        protected Texture2D _Texture;
        protected Viewer3D _Viewer;
        protected MSTSLocomotive _Locomotive;

        protected Vector2 _Position = new Vector2();
        
        protected bool _isNightTexture;
        protected CabShader _Shader;

        public CabViewControlRenderer(CabViewControl cvc, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
        {
            _CabViewControl = cvc;
            _Shader = shader;

            CABTextureManager.LoadTextures(viewer, _CabViewControl.ACEFile);

            _Viewer = viewer;
            _Locomotive = car;
        }

        /// <summary>
        /// Gets the requested Locomotive data and translates it into percents by Min and Max values
        /// </summary>
        /// <returns>Percent of real data by Min and Max values</returns>
        public float TranslateToPercent()
        {
            float data = _Locomotive.GetDataOf(_CabViewControl);
            if (data < _CabViewControl.MinValue)
                return 0;
            if (data > _CabViewControl.MaxValue)
                return 1;

            if (_CabViewControl.MaxValue == _CabViewControl.MinValue)
                return 0;

            return (float)((data - _CabViewControl.MinValue) / (_CabViewControl.MaxValue - _CabViewControl.MinValue));
        }

        public virtual void PrepareFrame(RenderFrame frame)
        {
            frame.AddPrimitive(Materials.SpriteBatchMaterial, this, RenderPrimitiveGroup.Cab, ref _Matrix);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
        }
    }

    /// <summary>
    /// Dial Cab Control Renderer
    /// Problems with aspect ratio
    /// </summary>
    public class CabViewDialRenderer : CabViewControlRenderer
    {
        private float _Rotation = 0f;
        private float _ScaleToScreen = 1f;
        private Vector2 _Origin;
        private CVCDial _Dial;
        protected float _Scale = 1f;

        public CabViewDialRenderer(CVCDial dial, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base (dial, viewer, car, shader)
        {
            _Dial = dial;
            _Origin = new Vector2((float)(_Dial.Width / 2), _Dial.Center);

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, false, false, out _isNightTexture);
            _Scale = (float)(_Dial.Height / _Texture.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, Dark, CabLight, out _isNightTexture);

            if (_Texture == Materials.MissingTexture)
                return;

            base.PrepareFrame(frame);

			_Position.X = (float)_Viewer.DisplaySize.X / 640 * ((float)_CabViewControl.PositionX + _Origin.X);
			_Position.Y = (float)_Viewer.DisplaySize.Y / 480 * ((float)_CabViewControl.PositionY + _Origin.Y);

			_ScaleToScreen = (float)_Viewer.DisplaySize.Y / 480 * _Scale;

            float percent = TranslateToPercent();
            float range;

            if ((_Dial.FromDegree > _Dial.ToDegree && _Dial.Direction == 0) ||
                (_Dial.ToDegree > _Dial.FromDegree && _Dial.Direction != 0))
            {
                range = 360 - _Dial.FromDegree + _Dial.ToDegree;
            }
            else
            {
                range = _Dial.ToDegree - _Dial.FromDegree;
            }

            float degree = range * percent;

            if (_Dial.Direction == 0)
                degree = _Dial.FromDegree + degree;
            else
                degree = _Dial.ToDegree - degree;

            _Rotation = MathHelper.ToRadians(degree);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (_Shader != null)
            {
                _Shader.SetTexData(_Position.X, _Position.Y, _Texture.Width * _ScaleToScreen, _Texture.Height * _ScaleToScreen);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }
            Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _Position, null, Color.White, _Rotation, _Origin, _ScaleToScreen, SpriteEffects.None, 0);
            if (_Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }
    }

    /// <summary>
    /// Gauge type renderer
    /// Supports pointer, liquid, solid
    /// Supports Orientation and Direction
    /// </summary>
    public class CabViewGaugeRenderer : CabViewControlRenderer
    {
        private CVCGauge _Gauge;
        protected Rectangle _SourceRectangle = new Rectangle();
        protected Rectangle _DestRectangle = new Rectangle();

        public CabViewGaugeRenderer(CVCGauge gauge, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base(gauge, viewer, car, shader)
        {
            _Gauge = gauge;
            _SourceRectangle = _Gauge.Area;
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            _Texture = CABTextureManager.GetTexture(_CabViewControl.ACEFile, Dark, CabLight, out _isNightTexture);

            if (_Texture == Materials.MissingTexture)
                return;

            base.PrepareFrame(frame);

            float xratio = (float)_Viewer.DisplaySize.X / 640;
            float yratio = (float)_Viewer.DisplaySize.Y / 480;

            float percent = TranslateToPercent();

            float xpos;
            float ypos;

            if (_Gauge.Orientation == 0)
            {
                ypos = (int)_Gauge.Height;
                if (_Gauge.Direction == 0)
                {
                    xpos = ((float)_Gauge.Width * percent);
                }
                else
                {
                    xpos = ((float)_Gauge.Width - (float)_Gauge.Width * percent);
                }
            }
            else
            {
                xpos = (int)_Gauge.Width;
                if (_Gauge.Direction == 0)
                {
                    ypos = ((float)_Gauge.Height * percent);
                }
                else
                {
                    ypos = ((float)_Gauge.Height - (float)_Gauge.Height * percent);
                }
            }

            if (_Gauge.ControlStyle == CABViewControlStyles.SOLID || _Gauge.ControlStyle == CABViewControlStyles.LIQUID)
            {
                _DestRectangle.X = (int)(xratio * _CabViewControl.PositionX);
                _DestRectangle.Y = (int)(yratio * _CabViewControl.PositionY);
                _DestRectangle.Width = (int)(xratio * xpos);
                _DestRectangle.Height = (int)(yratio * ypos);
            }
            else
            {
                _DestRectangle.X = (int)(xratio * (_CabViewControl.PositionX + xpos));
                _DestRectangle.Y = (int)(yratio * (_CabViewControl.PositionY + ypos));
                _DestRectangle.Width = (int)(xratio * _Gauge.Area.Width);
                _DestRectangle.Height = (int)(yratio * _Gauge.Area.Height);
            }
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (_Shader != null)
            {
                _Shader.SetTexData(_DestRectangle.Left, _DestRectangle.Top, _DestRectangle.Width, _DestRectangle.Height);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }
            Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
            if (_Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }
    }

    /// <summary>
    /// Discrete renderer for Lever, Twostate, Tristate, Multistate, Signal
    /// </summary>
    public class CabViewDiscreteRenderer : CabViewControlRenderer
    {
        protected CVCWithFrames _CVCWithFrames;
        protected Rectangle _SourceRectangle;
        protected Rectangle _DestRectangle = new Rectangle();
        
        public CabViewDiscreteRenderer(CVCWithFrames cvc, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base(cvc, viewer, car, shader)
        {
            _CVCWithFrames = cvc;
            CABTextureManager.DisassembleTexture(viewer.GraphicsDevice, _CabViewControl.ACEFile,
                (int)_CabViewControl.Width, (int)_CabViewControl.Height, _CVCWithFrames.FramesCount);

            _SourceRectangle = new Rectangle(0, 0, (int)_CVCWithFrames.Width, (int)_CVCWithFrames.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            bool Dark = Materials.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            int indx = GetDrawIndex();

            indx = (int)MathHelper.Clamp(indx, 0, _CVCWithFrames.FramesCount - 1);

            _Texture = CABTextureManager.GetTextureByIndexes(_CabViewControl.ACEFile, indx, Dark, CabLight, out _isNightTexture);

            if (_Texture == Materials.MissingTexture)
                return;

            base.PrepareFrame(frame);

            float xratio = (float)_Viewer.DisplaySize.X / 640;
            float yratio = (float)_Viewer.DisplaySize.Y / 480;

            _DestRectangle.X = (int)(xratio * _CabViewControl.PositionX * 1.0001);
            _DestRectangle.Y = (int)(yratio * _CabViewControl.PositionY * 1.0001);
            _DestRectangle.Width = (int)(xratio * _CabViewControl.Width);
            _DestRectangle.Height = (int)(yratio * _CabViewControl.Height);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            //graphicsDevice.SamplerStates[0].MagFilter = TextureFilter.Linear;
            if (_Shader != null)
            {
                _Shader.SetTexData(_DestRectangle.Left, _DestRectangle.Top, _DestRectangle.Width, _DestRectangle.Height);
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }
            Materials.SpriteBatchMaterial.SpriteBatch.Draw(_Texture, _DestRectangle, _SourceRectangle, Color.White);
            if (_Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }

        /// <summary>
        /// Determines the index of the Texture to be drawn
        /// </summary>
        /// <returns>index of the Texture</returns>
        public int GetDrawIndex()
        {
            float data = _Locomotive.GetDataOf(_CabViewControl);
            int indx = 0;
            switch (_CVCWithFrames.ControlType)
            {
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                //case CABViewControlTypes.CPH_DISPLAY:
                case CABViewControlTypes.ENGINE_BRAKE:
                case CABViewControlTypes.TRAIN_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    {
                        indx = FromPercent(data);
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                case CABViewControlTypes.HORN:
                case CABViewControlTypes.BELL:
                case CABViewControlTypes.SANDERS:
                case CABViewControlTypes.FRONT_HLIGHT:
                case CABViewControlTypes.PANTOGRAPH:
                case CABViewControlTypes.PANTO_DISPLAY:
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        indx = (int)data;
                        break;
                    }
            }

            return indx;
        }

        /// <summary>
        /// Translates a percent value to a display index
        /// </summary>
        /// <param name="percent">Percent to be translated</param>
        /// <returns>The calculated display index by the Control's Values</returns>
        public int FromPercent(float percent)
        {
            int indx = 0;

            if (percent > 1) percent /= 100f;
            percent = MathHelper.Clamp(percent, (float)_CVCWithFrames.MinValue, (float)_CVCWithFrames.MaxValue);
            if (_CVCWithFrames.Values.Count > 1)
            {
                double val = _CVCWithFrames.Values.Where(v => v <= percent).Last();
                indx = _CVCWithFrames.Values.IndexOf(val);
            }
            else
            {
                if (_CVCWithFrames.MaxValue != _CVCWithFrames.MinValue)
                {
                    indx = (int)(percent / (_CVCWithFrames.MaxValue - _CVCWithFrames.MinValue) * _CVCWithFrames.FramesCount);
                }
            }

            return indx;
        }
    }

    /// <summary>
    /// Digital Cab Control renderer
    /// Uses fonts instead of graphic
    /// Does not support Justification
    /// </summary>
    public class CabViewDigitalRenderer : CabViewControlRenderer
    {
        private float _Num;
        SpriteFont _Font;
        private float _ScaleToScreen = 1f;
        private int _Digits = 1;

        public CabViewDigitalRenderer (CVCDigital digital, Viewer3D viewer, MSTSLocomotive car, CabShader shader)
            : base (digital, viewer, car, shader)
        {
            _Font = _Viewer.RenderProcess.Content.Load<SpriteFont>("Arial");
            _Digits = (int)Math.Log10(_CabViewControl.MaxValue) + 1;
            
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            float fontratio = (float)_CabViewControl.Height / 16;
            float fpos = ((float)_CabViewControl.Width) - 6 * _Digits * fontratio;

            _Position.X = (float)_Viewer.DisplaySize.X / 640 * ((float)_CabViewControl.PositionX + fpos);
            _Position.Y = (float)_Viewer.DisplaySize.Y / 480 * (float)_CabViewControl.PositionY;

            base.PrepareFrame(frame);

			_ScaleToScreen = (float)_Viewer.DisplaySize.Y / 480 * (fontratio);

            _Num = _Locomotive.GetDataOf(_CabViewControl);
        }

        //Modified by Dionis 26/05/2011 in order to display colors and number formats
        public override void Draw(GraphicsDevice graphicsDevice)
        {
            StringBuilder sbAccuracy = new StringBuilder();
            StringBuilder sbLeadingZeros = new StringBuilder();
            string displayedText = "";
            Color textColor;
            try
            {
                if (((CVCDigital)_CabViewControl).OldValue != 0 && ((CVCDigital)_CabViewControl).OldValue > _Num && ((CVCDigital)_CabViewControl).DecreaseColor.A != 0)
                {
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).Accuracy; i++)
                    {
                        sbAccuracy.Append("0");
                    }
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).LeadingZeros; i++)
                    {
                        sbLeadingZeros.Append("0");
                    }
                    displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", Math.Abs(_Num));
                    textColor = new Color { A = (byte)((CVCDigital)_CabViewControl).DecreaseColor.A, B = (byte)((CVCDigital)_CabViewControl).DecreaseColor.B, G = (byte)((CVCDigital)_CabViewControl).DecreaseColor.G, R = (byte)((CVCDigital)_CabViewControl).DecreaseColor.R };

                }
                else if (_Num < 0 && ((CVCDigital)_CabViewControl).NegativeColor.A != 0)
                {
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).Accuracy; i++)
                    {
                        sbAccuracy.Append("0");
                    }
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).LeadingZeros; i++)
                    {
                        sbLeadingZeros.Append("0");
                    }
                    displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", Math.Abs(_Num));
                    textColor = new Color { A = (byte)((CVCDigital)_CabViewControl).NegativeColor.A, B = (byte)((CVCDigital)_CabViewControl).NegativeColor.B, G = (byte)((CVCDigital)_CabViewControl).NegativeColor.G, R = (byte)((CVCDigital)_CabViewControl).NegativeColor.R };

                }
                else
                {
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).Accuracy; i++)
                    {
                        sbAccuracy.Append("0");
                    }
                    for (int i = 0; i < (int)((CVCDigital)_CabViewControl).LeadingZeros; i++)
                    {
                        sbLeadingZeros.Append("0");
                    }
                    if (((CVCDigital)_CabViewControl).PositiveColor.A != 0)
                    {
                        displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", _Num);
                        textColor = new Color { A = (byte)((CVCDigital)_CabViewControl).PositiveColor.A, B = (byte)((CVCDigital)_CabViewControl).PositiveColor.B, G = (byte)((CVCDigital)_CabViewControl).PositiveColor.G, R = (byte)((CVCDigital)_CabViewControl).PositiveColor.R };

                    }
                    else
                    {
                        displayedText = String.Format("{0:0" + sbLeadingZeros.ToString() + (((CVCDigital)_CabViewControl).Accuracy > 0 ? "." + sbAccuracy.ToString() : "") + "}", _Num);
                        textColor = Color.White;

                    }
                }
                Materials.SpriteBatchMaterial.SpriteBatch.DrawString(_Font, displayedText, _Position, textColor, 0f, new Vector2(), _ScaleToScreen, SpriteEffects.None, 0);
                ((CVCDigital)_CabViewControl).OldValue = _Num;
            }
            catch (Exception ex)
            {
                Trace.WriteLine(ex);
            }
            finally
            {
                sbAccuracy = null;
                sbLeadingZeros = null;
            }
        }
    }
}
