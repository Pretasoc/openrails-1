// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* LOCOMOTIVE CLASSES
 * 
 * Used as a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  MSTSLocomotive - defines the behaviour, ie physics, motion, power generated etc
 *  MSTSLocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCar - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MSTS;
using ORTS.Popups;



namespace ORTS
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////

    public enum CabViewType {
        Front = 0,
        Rear = 1,
    }

    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public partial class MSTSLocomotive : MSTSWagon
    {
        // simulation parameters
        public bool Horn = false;
        public bool AlerterSnd = false;
        public bool VigilanceMonitor = false;
        public bool Bell = false;
        public bool Sander = false;  
        public bool Wiper = false;
        public bool BailOff = false;
        public bool DynamicBrake = false;
        public float MaxPowerW;
        public float MaxForceN;
        public float MaxSpeedMpS = 1e3f;
        public float MainResPressurePSI = 130;
        public bool CompressorOn = false;
        public float AverageForceN = 0;
        public bool PowerOn = false;
        public float PowerOnDelay = 0.0f;
        public bool CabLightOn = false;
        public bool ShowCab = true;

        bool AlerterIsActive = false;

        // wag file data
        public string CabSoundFileName = null;
        public string CVFFileName = null;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeFT3 = 10;
        public float CompressorRestartPressurePSI = 110;
        public float MainResChargingRatePSIpS = .4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = .003f;
        public float BrakeServiceTimeFactorS = 1.009f;
        public float BrakeEmergencyTimeFactorS = .1f;
        public float BrakePipeChargingRatePSIpS;
        public Interpolator2D TractiveForceCurves = null;
        public Interpolator2D DynamicBrakeForceCurves = null;
        public float DynamicBrakeSpeed1 = 3;
        public float DynamicBrakeSpeed2 = 18;
        public float DynamicBrakeSpeed3 = 23;
        public float DynamicBrakeSpeed4 = 35;
        public float MaxDynamicBrakeForceN = 0;
        public float DynamicBrakeDelayS = 0;
        public bool DynamicBrakeAutoBailOff = false;
        public bool UsingRearCab = false;

        public bool HasCombCtrl = false;
        public bool HasCombThrottleTrainBrake = false;
        public bool HasDefectiveComboDynamicBreak = false;
        public bool HasSmoothStruc = false;
        public int  ComboCtrlCrossOver = 5;

        public float MaxContinuousForceN;
        public float ContinuousForceTimeFactor = 1800;
        public float NumWheelsAdhesionFactor = 4;   // MSTS adhesion factor loosely based on the number of driven axles
        public bool AntiSlip = false;
        public float SanderSpeedEffectUpToMpS = 0.0f;
        public float SanderSpeedOfMpS = 30.0f;
        public string EngineOperatingProcedures;

        public bool EmergencyCausesPowerDown = false;
        public bool EmergencyCausesThrottleDown = false;
        public bool EmergencyEngagesHorn = false;
        public bool WheelslipCausesThrottleDown = false;
        public float CabRotationZ { get { return (UsingRearCab==true?-totalRotationZ:totalRotationZ);} }

        public Dictionary<string, List<ParticleEmitterData>> EffectData = new Dictionary<string,List<ParticleEmitterData>>();

        public List<CabView> CabViewList = new List<CabView>();

        public MSTSNotchController  ThrottleController;
        public MSTSBrakeController  TrainBrakeController;
        public MSTSBrakeController  EngineBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController  DynamicBrakeController;
        
        public Axle LocomotiveAxle;
        public IIRFilter CurrentFilter;
        public IIRFilter AdhesionFilter;
        
        public float FilteredMotiveForceN = 0.0f;

        public double CommandStartTime;
        float? trainBrakeTarget;
        float? engineBrakeTarget;
        float? dynamicBrakeTarget;
        float? throttleTarget;

        public MSTSLocomotive(Simulator simulator, string wagPath)
            : base(simulator, wagPath)
        {
			BrakePipeChargingRatePSIpS = simulator.Settings.BrakePipeChargingRate;

            LocomotiveAxle = new Axle();
            LocomotiveAxle.DriveType = AxleDriveType.ForceDriven;
            LocomotiveAxle.DampingNs = MassKG / 1000.0f;
            LocomotiveAxle.AdhesionK = AdhesionK;
            LocomotiveAxle.CurtiusKnifflerA = Curtius_KnifflerA;
            LocomotiveAxle.CurtiusKnifflerB = Curtius_KnifflerB;
            LocomotiveAxle.CurtiusKnifflerC = Curtius_KnifflerC;
            LocomotiveAxle.StabilityCorrection = true;
            CurrentFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.5f),0.001f);
            AdhesionFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.1f), 0.001f);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void InitializeFromWagFile(string wagFilePath)
        {
            TrainBrakeController = new MSTSBrakeController(Simulator);
            EngineBrakeController = new MSTSBrakeController(Simulator);
            DynamicBrakeController = new MSTSNotchController();
            base.InitializeFromWagFile(wagFilePath);

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            // Is Alerter option checked in menu
            if (Program.Simulator.Settings.Alerter)
            {
                int startTime = (int)Simulator.ClockTime;
                if (VigilanceMonitor)
                    AlerterStartUp();
            }

            // Assumes that CabViewList[0] is the front cab
            // and that CabViewList[1] is the rear cab, if present.
            // Could be extended to more than 2 cabs.
            if (CVFFileName != null)
            {
                var cabView = BuildCabView(WagFilePath, CVFFileName, CabViewType.Front);
                if (cabView != null)
                {
                    CabViewList.Add(cabView);
                    var reverseCVFFileName = Path.Combine(Path.GetDirectoryName(CVFFileName),
                        // Some CVF paths begin with "..\..\"
                        // so Path.GetDirectoryName() is needed.
                                                            Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf");
                    {
                        cabView = BuildCabView(WagFilePath, reverseCVFFileName, CabViewType.Rear);
                        if (cabView != null)
                            CabViewList.Add(cabView);
						}
					}
                else
                {
                    Trace.TraceWarning("{0} locomotive's CabView references non-existent {1}", wagFilePath, CVFFileName);
					}
                }

            IsDriveable = true;
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new MSTSBrakeController(Simulator); //create a blank one
            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    // Trace.TraceInformation("Smooth Dynamic Brake may have inaccurate display");
                    HasSmoothStruc = true;
                }
            }
            if (!DynamicBrakeController.IsValid())
                DynamicBrakeController = null;
            if (DynamicBrakeForceCurves == null && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new Interpolator2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(4);
                interp[DynamicBrakeSpeed1] = 0;
                interp[DynamicBrakeSpeed2] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        private CabView BuildCabView(string wagFilePath, string cvfFileName, CabViewType type)
        {
            var viewPointList = new List<ViewPoint>();
            var extendedCVF = new ExtendedCVF();

            var cvfBasePath = Path.Combine(Path.GetDirectoryName(wagFilePath), "CABVIEW");
            var cvfFilePath = Path.Combine(cvfBasePath, cvfFileName);
            if (!File.Exists(cvfFilePath))
                return null;

            var cvfFile = new CVFFile(cvfFilePath, cvfBasePath);
            var viewPoint = new ViewPoint();                    // Set up camera locations for the cab views
            for (int i = 0; i < cvfFile.Locations.Count; ++i)
            {
                if (i >= cvfFile.Locations.Count || i >= cvfFile.Directions.Count)
                {
                    Trace.TraceWarning("Skipped cab view camera {1} missing Position and Direction in {0}", cvfFilePath, i);
                    break;
                }
                viewPoint = new ViewPoint();
                viewPoint.Location = cvfFile.Locations[i];
                viewPoint.StartDirection = cvfFile.Directions[i];
                viewPoint.RotationLimit = new Vector3(0, 0, 0);  // cab views have a fixed head position
                viewPointList.Add(viewPoint);
            }

            var y = cvfFile.Directions[0].Y; // abbreviation
            // Most models use range -180 to 180 but Making Trains have some with 0 to 360
            var isRearFacing = (y < -90 || (y > 90 && y < 270));
            if (type == CabViewType.Front)
            {
                // Most models use range -180 to 180 but Making Trains have some with 0 to 360
                if (isRearFacing)
                    Trace.TraceWarning("Front-facing cab view is not facing forward {0}", cvfFilePath);
            }
            else
            {
                // Most models use range -180 to 180 but Making Trains have some with 0 to 360
                if (!isRearFacing)
                    Trace.TraceWarning("Rear-facing cab view is not facing rearward {0}", cvfFilePath);
            }
            if (!(this is MSTSSteamLocomotive))
            {
                InitializeFromORTSSpecific(cvfFilePath, extendedCVF);
            }
            return new CabView(cvfFile, viewPointList, extendedCVF);
        }

        protected void ParseEffects(string lowercasetoken, STFReader stf)
        {
            stf.MustMatch("(");
            string s;

            while ((s = stf.ReadItem()) != ")")
            {
                var data = new ParticleEmitterData(stf);
                if (!EffectData.ContainsKey(s))
                    EffectData.Add(s, new List<ParticleEmitterData>());
                EffectData[s].Add(data);
            }
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            if (lowercasetoken.StartsWith("engine(trainbrakescontroller"))
                TrainBrakeController.ParseBrakeValue(lowercasetoken.Substring(28), stf);
            if (lowercasetoken.StartsWith("engine(enginebrakescontroller"))
                EngineBrakeController.ParseBrakeValue(lowercasetoken.Substring(29), stf);
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabview": CVFFileName = stf.ReadStringBlock(null);
                    //ReverseCVFFileName = Path.Combine(Path.GetDirectoryName(CVFFileName), Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf");
                    break;
                case "engine(maxpower": MaxPowerW = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforce": MaxForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxvelocity": MaxSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;

                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(brake_train": TrainBrakeController.Parse(stf); break;
                case "engine(enginecontrollers(brake_engine": EngineBrakeController.Parse(stf); break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(stf); break;

                //case "engine(enginecontrollers(combined_control": HasCombCtrl = true; break;
                //case "engine(enginecontrollers(combined_control": ParseCombData(lowercasetoken, stf); break;
                case "engine(vigilancemonitor": VigilanceMonitor = true; break;
                case "engine(enginecontrollers(combined_control": HasCombCtrl = true; if (!DynamicBrakeController.IsValid()) DynamicBrakeController = new MSTSNotchController(0, 1, .05f); break;

                case "engine(airbrakesmainresvolume": MainResVolumeFT3 = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(mainreschargingrate": MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(enginebrakereleaserate": EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(enginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakepipetimefactor": BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakeservicetimefactor": BrakeServiceTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakeemergencytimefactor": BrakeEmergencyTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(brakepipechargingrate": BrakePipeChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(maxtractiveforcecurves": TractiveForceCurves = new Interpolator2D(stf); break;
                case "engine(dynamicbrakeforcecurves": DynamicBrakeForceCurves = new Interpolator2D(stf); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4 = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(dynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true); break;
                case "engine(dynamicbrakesdelaytimebeforeengaging": DynamicBrakeDelayS = stf.ReadFloatBlock(STFReader.UNITS.Any, null); break;
                case "engine(continuousforcetimefactor": ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(numwheels": NumWheelsAdhesionFactor = stf.ReadFloatBlock(STFReader.UNITS.None, 4.0f); if (NumWheelsAdhesionFactor < 1) STFException.TraceWarning(stf, "Engine:NumWheels is less than 1, parts of the simulation may not function correctly"); break;
                case "engine(antislip": AntiSlip = stf.ReadBoolBlock(false); break;
                case "engine(engineoperatingprocedures": EngineOperatingProcedures = stf.ReadStringBlock(""); break;
                case "engine(headout": HeadOutViewpoints.Add(new ViewPoint() { Location = stf.ReadVector3Block(STFReader.UNITS.None, Vector3.Zero) }); break;
                case "engine(sanding": SanderSpeedOfMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, 30.0f); break;
                case "engine(orts(sanderspeedeffectupto": SanderSpeedEffectUpToMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(orts(powerondelay": PowerOnDelay = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(orts(emergencycausespowerdown": EmergencyCausesPowerDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(emergencycausesthrottledown": EmergencyCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(emergencyengageshorn": EmergencyEngagesHorn = stf.ReadBoolBlock(false); break;
                case "engine(orts(wheelslipcausesthrottledown": WheelslipCausesThrottleDown = stf.ReadBoolBlock(false); break;

                default: base.Parse(lowercasetoken, stf); break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void InitializeFromCopy(MSTSWagon copy)
        {
            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CabViewList = locoCopy.CabViewList;

            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;
            DynamicBrakeDelayS = locoCopy.DynamicBrakeDelayS;
            NumWheelsAdhesionFactor = locoCopy.NumWheelsAdhesionFactor;
            AntiSlip = locoCopy.AntiSlip;
            EffectData = locoCopy.EffectData;
            SanderSpeedEffectUpToMpS = locoCopy.SanderSpeedEffectUpToMpS;
            SanderSpeedOfMpS = locoCopy.SanderSpeedOfMpS;
            PowerOnDelay = locoCopy.PowerOnDelay;

            EmergencyCausesPowerDown = locoCopy.EmergencyCausesPowerDown;
            EmergencyCausesThrottleDown = locoCopy.EmergencyCausesThrottleDown;
            EmergencyEngagesHorn = locoCopy.EmergencyEngagesHorn;

            WheelslipCausesThrottleDown = locoCopy.WheelslipCausesThrottleDown;

            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            TrainBrakeController = (MSTSBrakeController)locoCopy.TrainBrakeController.Clone();
            EngineBrakeController = locoCopy.EngineBrakeController != null ? (MSTSBrakeController)locoCopy.EngineBrakeController.Clone() : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;

            base.InitializeFromCopy(copy);  // each derived level initializes its own variables
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(Wiper);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorOn);
            outf.Write(AverageForceN);
            outf.Write(LocomotiveAxle.AxleSpeedMpS);
            outf.Write( CabLightOn );
            outf.Write(UsingRearCab);
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);            
            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            if (inf.ReadBoolean()) SignalEvent(Event.BellOn);
            if (inf.ReadBoolean()) SignalEvent(Event.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(Event.WiperOn);
            MainResPressurePSI = inf.ReadSingle();
            CompressorOn = inf.ReadBoolean();
            AverageForceN = inf.ReadSingle();
            LocomotiveAxle.Reset(inf.ReadSingle());
            CabLightOn = inf.ReadBoolean();
            UsingRearCab = inf.ReadBoolean();
            ThrottleController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            TrainBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            EngineBrakeController = (MSTSBrakeController)ControllerFactory.Restore(Simulator, inf);
            DynamicBrakeController = (MSTSNotchController)ControllerFactory.Restore(Simulator, inf);
            AdhesionFilter.Reset(0.5f);
            
            base.Restore(inf);
        }

        private void ParseCombData(string lowercasetoken, STFReader stf)
        {
            HasCombCtrl = true;

            stf.MustMatch("(");
            string comboBrakeType = "train";
            string s;
            int i = 0;
            float value = 0.5f;

            while ((s = stf.ReadItem()) != ")")
            {
                if (i == 1)
                {
                    value = stf.ReadFloat(STFReader.UNITS.Any, null);
                    ComboCtrlCrossOver = (int)(value * 10);
                }
                if (comboBrakeType == s)
                    HasCombThrottleTrainBrake = true;
                i++;
            }

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    // cancel smooth dynamic control, keyboard hud display only
                    //HasDefectiveComboDynamicBreak = true;
                    HasSmoothStruc = true;
                    // Trace.TraceInformation("Smooth Dynamic Brake may have inaccurate display");
                }
            }
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }


        /// <summary>
        /// Create a viewer for this locomotive.   Viewers are only attached
        /// while the locomotive is in viewing range.
        /// </summary>
        public override TrainCarViewer GetViewer(Viewer3D viewer)
        {
            return new MSTSLocomotiveViewer(viewer, this);
        }
        /// <summary>
        /// Sets controler settings from other engine for cab switch
        /// </summary>
        /// <param name="other"></param>
        public override void CopyControllerSettings(TrainCar other)
        {
            base.CopyControllerSettings(other);
            if (ThrottleController != null)
                ThrottleController.SetValue(other.ThrottlePercent / 100);
            if (DynamicBrakeController != null)
                DynamicBrakeController.SetValue(other.DynamicBrakePercent / 100);
            if (TrainBrakeController != null)
                TrainBrakeController.SetValue(((MSTSLocomotive)other).TrainBrakeController.CurrentValue);
            if (EngineBrakeController != null)
                EngineBrakeController.SetValue(0);
        }

		public bool controlUpdated = false;
		public bool notificationReceived = false;

        /// <summary>
        /// This is a periodic update to calculate physics 
        /// parameters and update the base class's MotiveForceN 
        /// and FrictionForceN values based on throttle settings
        /// etc for the locomotive.
        /// </summary>
        public override void Update(float elapsedClockSeconds)
        {
            TrainBrakeController.Update(elapsedClockSeconds);
            if (TrainBrakeController.UpdateValue > 0.0)
            {
                Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus());
            }

            if (TrainBrakeController.UpdateValue < 0.0) {
                Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus());
            }

            if (EngineBrakeController != null)
             {
                EngineBrakeController.Update(elapsedClockSeconds);
                if (EngineBrakeController.UpdateValue > 0.0) {
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
                }
                if (EngineBrakeController.UpdateValue < 0.0) {
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Decrease, GetEngineBrakeStatus());
                }
            }

            if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0))
            {
                if (!DynamicBrake)
                {
                    if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                    {
                        DynamicBrake = true; // Engage
                        if (IsLeadLocomotive())
                            Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                    }
                    else if (IsLeadLocomotive())
                        Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
                }
                else if (this.IsLeadLocomotive())
                    DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                else
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }
            else if ((DynamicBrakeController != null) && (DynamicBrakePercent < 0) && (DynamicBrake))
            {
                if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                {
                    DynamicBrake = false; // Disengage
                    if (IsLeadLocomotive())
                        Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.Off);
                }
                else if (IsLeadLocomotive())
                    Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)
            if (this.IsLeadLocomotive()) {
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
                ConfirmWheelslip();
            } else {
                ThrottleController.Update(elapsedClockSeconds);
			}
#if INDIVIDUAL_CONTROL

			//this train is remote controlled, with mine as a helper, so I need to send the controlling information, but not the force.
			if (MultiPlayer.MPManager.IsMultiPlayer() && this.Train.TrainType == Train.TRAINTYPE.REMOTE && this == Program.Simulator.PlayerLocomotive)
			{
				//cannot control train brake as it is the remote's job to do so
				if ((EngineBrakeController != null && EngineBrakeController.UpdateValue != 0.0) || (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0) || ThrottleController.UpdateValue != 0.0)
				{
					controlUpdated = true;
				}
				ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
				if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0)) DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
				return; //done, will go back and send the message to the remote train controller
			}

			if (MultiPlayer.MPManager.IsMultiPlayer() && this.notificationReceived == true)
			{
				ThrottlePercent = ThrottleController.CurrentValue * 100.0f;
				this.notificationReceived = false;
			}
#endif
            // TODO  this is a wild simplification for electric and diesel electric
            float t = ThrottlePercent / 100f;
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float currentWheelSpeedMpS = Math.Abs(WheelSpeedMpS);
            //Only if a power is "ON" - pantograph up or diesel is running
            if (PowerOn)
            {
                if (TractiveForceCurves == null)
                {
                    float maxForceN = MaxForceN * t;
                    float maxPowerW = MaxPowerW * t * t;
                    if (!this.Simulator.UseAdvancedAdhesion)
                        currentWheelSpeedMpS = currentSpeedMpS;
                    if (maxForceN * currentWheelSpeedMpS > maxPowerW)
                        maxForceN = maxPowerW / currentWheelSpeedMpS;
                    //if (currentSpeedMpS > MaxSpeedMpS)
                    //    maxForceN = 0;
                    if (currentSpeedMpS > MaxSpeedMpS -0.05f)
                        maxForceN = 20 * (MaxSpeedMpS - currentSpeedMpS) * maxForceN;
                    if (currentSpeedMpS > (MaxSpeedMpS))
                        maxForceN = 0;
                    MotiveForceN = maxForceN;
                }
                else
                {
                    MotiveForceN = TractiveForceCurves.Get(t, currentWheelSpeedMpS);
                    if (MotiveForceN < 0)
                        MotiveForceN = 0;
                }
            }


            if (MaxForceN > 0 && MaxContinuousForceN > 0)
            {
                MotiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN;
                float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * MotiveForceN;
            }

#if !NEW_SIGNALLING
            if (this.IsLeadLocomotive())
            {
                switch (Direction)
                {
                    case Direction.Forward:
                        //MotiveForceN *= 1;     //Not necessary
                        break;
                    case Direction.Reverse:
                        MotiveForceN *= -1;
                        break;
                    case Direction.N:
                    default:
                        MotiveForceN *= 0;
                        break;
                }
            }
            else
            {
                int carCount = 0;
                int controlEngine = -1;

                // When not LeadLocomotive; check if lead is in Neutral
                // if so this loco will have no motive force
                var LeadLocomotive = Program.Simulator.PlayerLocomotive.Train;

                foreach (TrainCar car in LeadLocomotive.Cars)
                {
                    if (car.IsDriveable)
                        if (controlEngine == -1)
                        {
                            controlEngine = carCount;
                            if (car.Direction == Direction.N)
                                MotiveForceN *= 0;
                            else
                            {
                                switch (Direction)
                                {
                                    case Direction.Forward:
                                        MotiveForceN *= 1;     //Not necessary
                                        break;
                                    case Direction.Reverse:
                                        MotiveForceN *= -1;
                                        break;
                                    case Direction.N:
                                    default:
                                        MotiveForceN *= 0;
                                        break;
                                }
                            }
                        }
                    break;
                } // foreach
            } // end when not lead loco
#else
            if (Train.TrainType == Train.TRAINTYPE.PLAYER) // for player locomotives
            {

                if (this.IsLeadLocomotive())
                {
                    switch (Direction)
                    {
                        case Direction.Forward:
                            //MotiveForceN *= 1;     //Not necessary
                            break;
                        case Direction.Reverse:
                            MotiveForceN *= -1;
                            break;
                        case Direction.N:
                        default:
                            MotiveForceN *= 0;
                            break;
                    }
                }
                else
                {
                    // When not LeadLocomotive; check if lead is in Neutral
                    // if so this loco will have no motive force

                    var LeadLocomotive = Program.Simulator.PlayerLocomotive;

                    if (LeadLocomotive == null) { }
                    else if (LeadLocomotive.Direction == Direction.N)
                        MotiveForceN *= 0;
                    else
                    {
                        switch (Direction)
                        {
                            case Direction.Forward:
                                MotiveForceN *= 1;     //Not necessary
                                break;
                            case Direction.Reverse:
                                MotiveForceN *= -1;
                                break;
                            case Direction.N:
                            default:
                                MotiveForceN *= 0;
                                break;
                        }
                    }


                } // end when not lead loco
            }// end Player locomotive

            else // for AI locomotives
            {
                switch (Direction)
                {
                    case Direction.Reverse:
                        MotiveForceN *= -1;
                        break;
                    default:
                        break;
                }
            }// end AI locomotive
#endif

            // Variable1 is wheel rotation in m/sec for steam locomotives
            //Variable2 = Math.Abs(MotiveForceN) / MaxForceN;   // force generated
            Variable1 = ThrottlePercent / 100f;   // throttle setting
            //Variable2 = Math.Abs(WheelSpeedMpS);
            //Variable3 = DynamicBrakePercent / 100f;

            if (DynamicBrakePercent > 0 && DynamicBrakeForceCurves != null)
            {
                float f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, currentSpeedMpS);
                if (f > 0)
                    MotiveForceN -= (SpeedMpS > 0 ? 1 : -1) * f;
            }


            switch (this.Train.TrainType)
            {
                case Train.TRAINTYPE.AI:
                    if (!PowerOn)
                    {
                        PowerOn = true;
                        Pan = true;
                        Pan1Up = true;
                    }
                    //LimitMotiveForce(elapsedClockSeconds);    //calls the advanced physics
                    LimitMotiveForce();                         //let's call the basic physics instead for now
                    WheelSpeedMpS = Flipped ? -currentSpeedMpS : currentSpeedMpS;            //make the wheels go round
                    break;
                case Train.TRAINTYPE.STATIC:
                    break;
                case Train.TRAINTYPE.PLAYER:
                case Train.TRAINTYPE.REMOTE:
                    // For notched throttle controls (e.g. Dash 9 found on Marias Pass) UpdateValue is always 0.0
                    if (ThrottleController.UpdateValue != 0.0)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                            ThrottleController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            ThrottleController.CurrentValue * 100);
                    }
                    if (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0 && DynamicBrake)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            CabControl.DynamicBrake,
                            DynamicBrakeController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            DynamicBrakeController.CurrentValue * 100);
                    }

                    LimitMotiveForce(elapsedClockSeconds);

                    if (WheelslipCausesThrottleDown && WheelSlip)
                        ThrottleController.SetValue(0.0f);
                    //Force to display
                    FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    break;
                default:
                    break;
                
            }
            if ((MainResPressurePSI < CompressorRestartPressurePSI) && (!CompressorOn) && (PowerOn))
                SignalEvent(Event.CompressorOn);
            else if (MainResPressurePSI > MaxMainResPressurePSI && CompressorOn)
                SignalEvent(Event.CompressorOff);
            if (CompressorOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;


            base.Update(elapsedClockSeconds);
        } // End Method Update

        enum Wheelslip {
            None,
            Warning,
            Occurring
        };

        Wheelslip WheelslipState = Wheelslip.None;

        public void ConfirmWheelslip() {
            if (Simulator.UseAdvancedAdhesion)
            {
                // Wheelslip
                if (LocomotiveAxle.IsWheelSlip)
                {
                    if (WheelslipState != Wheelslip.Occurring)
                    {
                        WheelslipState = Wheelslip.Occurring;
                        Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                    }
                }
                else
                {
                    if (LocomotiveAxle.IsWheelSlipWarning)
                    {
                        if (WheelslipState != Wheelslip.Warning)
                        {
                            WheelslipState = Wheelslip.Warning;
                            Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Warn1);
                        }
                    }
                    else
                    {
                        if (WheelslipState != Wheelslip.None)
                        {
                            WheelslipState = Wheelslip.None;
                            Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                        }
                    }
                }
            }
            else
            {
                if (WheelSlip && (WheelslipState != Wheelslip.Occurring))
                {
                    WheelslipState = Wheelslip.Occurring;
                    Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                }
                if ((!WheelSlip)&&(WheelslipState != Wheelslip.None))
                {
                    WheelslipState = Wheelslip.None;
                    Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                }
            }
        }

        /// <summary>
        /// Calls the Update method in the parent class MSTSWagon.
        /// </summary>
        /// <param name="elapsedClockSeconds"></param>
        protected void UpdateParent(float elapsedClockSeconds)
        {
            base.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public void LimitMotiveForce(float elapsedClockSeconds)
        {
            float currentSpeedMpS = Math.Abs(SpeedMpS);

            if (NumWheelsAdhesionFactor <= 0)
            {
                WheelSpeedMpS = currentSpeedMpS;
                return;
            }

            //Curtius-Kniffler computation for the basic model
            float max0 = 1.0f;  //Adhesion conditions [N]
            float max1 = MassKG * 9.81f * Adhesion2;

            if ((Simulator.UseAdvancedAdhesion)&&(!Simulator.Paused)&&(!AntiSlip))
            {
                //Set the weather coeff
                if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
                {
                    if (Train.SlipperySpotDistanceM < 0)
                    {
                        Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                        Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                    }
                    if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                        max0 = .8f;
                    if (Program.Simulator.Weather == WeatherType.Rain)
                        max0 = 0.6f;
                    else
                        max0 = 0.4f;
                }
                else
                    max0 = 1.0f;
                //add sander
                if (Math.Abs(SpeedMpS) < SanderSpeedOfMpS)
                {
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (Math.Abs(SpeedMpS) < SanderSpeedEffectUpToMpS))
                        {
                            switch (Program.Simulator.Weather)
                            {
                                case WeatherType.Clear:     max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.2f; break;
                                case WeatherType.Rain:      max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.8f; break;
                                case WeatherType.Snow:      max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 2.5f; break;
                            }
                        }
                    }
                    else
                        if (Sander)
                        {
                            switch (Program.Simulator.Weather)
                            {
                                case WeatherType.Clear:     max0 *= 1.2f; break;
                                case WeatherType.Rain:      max0 *= 1.8f; break;
                                case WeatherType.Snow:      max0 *= 2.5f; break;
                            }
                        }
                }

                //Set adhesion coeff to the model
                    //Pure condition
                    //LocomotiveAxle.AdhesionConditions = max0;
                    //Filtered condition
                    //LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0, elapsedClockSeconds);
                //Filtered random condition
                LocomotiveAxle.AdhesionConditions = AdhesionFilter.Filter(max0 + (float)(0.2*Program.Random.NextDouble()),elapsedClockSeconds);
                //LocomotiveAxle.AdhesionConditions = max0;
                //Set axle inertia (this should be placed within the ENG parser)
                // but make sure the value is sufficietn
                //if (MaxPowerW < 200000.0f)
                //{
                //    if (NumWheelsAdhesionFactor > 4.0f)
                //        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheelsAdhesionFactor * 4000.0f;
                //    else
                //        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                //}
                //else
                //{
                //    if (NumWheelsAdhesionFactor > 4.0f)
                //        LocomotiveAxle.InertiaKgm2 = 2.0f * NumWheelsAdhesionFactor * MaxPowerW / 500.0f;
                //    else
                //        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                //}

                //Compute axle inertia from parameters if possible
                if (AxleInertiaKgm2 > 10000.0f)
                {
                    LocomotiveAxle.InertiaKgm2 = AxleInertiaKgm2;
                }
                else
                {
                    if (WheelAxles.Count > 0 && DriverWheelRadiusM > 0)
                    {
                    float upperLimit = 2.0f * WheelAxles.Count * (15000.0f * DriverWheelRadiusM - 2900.0f);
                        upperLimit = upperLimit < 100.0f ? 100.0f : upperLimit;

                        float lowerLimit = WheelAxles.Count * (9000.0f * DriverWheelRadiusM - 1750.0f);
                        lowerLimit = lowerLimit < 100.0f ? 100.0f : lowerLimit;

                        LocomotiveAxle.InertiaKgm2 = (upperLimit - lowerLimit) / (5000000.0f) * MaxPowerW + lowerLimit;
                    }
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }
                //Limit the inertia to 40000 kgm2
                LocomotiveAxle.InertiaKgm2 = LocomotiveAxle.InertiaKgm2 > 40000.0f ? 40000.0f : LocomotiveAxle.InertiaKgm2;

                LocomotiveAxle.AxleRevolutionsInt.MinStep = LocomotiveAxle.InertiaKgm2 / MaxPowerW / 5.0f;
                

                //Set axle model parameters
                
                //LocomotiveAxle.BrakeForceN = FrictionForceN;
                LocomotiveAxle.BrakeForceN = BrakeForceN;
                LocomotiveAxle.AxleWeightN = 9.81f * MassKG;        //will be computed each time considering the tilting
                LocomotiveAxle.DriveForceN = MotiveForceN;           //Developed force
                LocomotiveAxle.TrainSpeedMpS = SpeedMpS;            //Set the train speed of the axle model

                LocomotiveAxle.Update(elapsedClockSeconds);         //Main updater of the axle model
                
                MotiveForceN = LocomotiveAxle.AxleForceN;           //Get the Axle force and use it for the motion
                WheelSlip = LocomotiveAxle.IsWheelSlip;             //Get the wheelslip indicator
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;
            }
            else
            {
                LimitMotiveForce();
            }
        }

        public void LimitMotiveForce()
        {
            if (NumWheelsAdhesionFactor <= 0)
                return;
            //float max0 = MassKG * 9.8f * Adhesion3 / NumWheelsAdhesionFactor;   //Not used

            //Curtius-Kniffler computation
            float currentSpeedMpS = Math.Abs(SpeedMpS);
            float uMax = (7.5f / (currentSpeedMpS * 3.6f + 44.0f) + 0.161f); // Curtius - Kniffler equation
            float adhesionUtil = 0.95f;   //Adhesion utilization

            float max0 = MassKG * 9.81f * adhesionUtil * uMax;  //Ahesion limit in [N]
            float max1;

            if (Program.Simulator.Weather == WeatherType.Rain || Program.Simulator.Weather == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Program.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Program.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= .8f;
                if (Program.Simulator.Weather == WeatherType.Rain)
                    max0 *= .8f;
                else
                    max0 *= .7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = MaxForceN;
            //add sander
            if (Math.Abs(SpeedMpS) < SanderSpeedOfMpS)
            {
                if (SanderSpeedEffectUpToMpS > 0.0f)
                {
                    if ((Sander) && (Math.Abs(SpeedMpS) < SanderSpeedEffectUpToMpS))
                    {
                        switch (Program.Simulator.Weather)
                        {
                            case WeatherType.Clear: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.2f; break;
                            case WeatherType.Rain: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 1.8f; break;
                            case WeatherType.Snow: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * Math.Abs(SpeedMpS)) * 2.5f; break;
                        }
                    }
                }
                else
                    if (Sander)
                    {
                        switch (Program.Simulator.Weather)
                        {
                            case WeatherType.Clear: max0 *= 1.2f; break;
                            case WeatherType.Rain: max0 *= 1.8f; break;
                            case WeatherType.Snow: max0 *= 2.5f; break;
                        }
                    }
            }

            max1 = max0;

            WheelSlip = false;

            // always set AntiSlip for AI trains
            if (Train.TrainType == Train.TRAINTYPE.AI)
            {
                AntiSlip = true;
            }

            if (MotiveForceN > max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }

            //This doesn't help at all, the force is already limited!!! The "AntiSlip = true;" statement is much better.
            // overrule wheelslip for AI trains
            if (Train.TrainType == Train.TRAINTYPE.AI)
            {
                WheelSlip = false;
            }
        }

        public override bool GetSanderOn()
        {
            return Sander;
        }

        public void SetDirection( Direction direction )
        {
            // Direction Control
            if ( Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                SignalEvent(Event.ReverserChange);
                if (direction == Direction.Forward)
                    Train.MUReverserPercent = 100;
                else
                    Train.MUReverserPercent = -100;
            }

#if !NEW_SIGNALLING
            if (direction == Direction.N)
            {
                Program.Simulator.AI.Dispatcher.ReleasePlayerAuthorization();
            }
            else
            {
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization(false);
            }
#endif
        }

        public virtual void StartReverseIncrease( float? target )
        {
            AlerterReset();
            if (this.IsLeadLocomotive())
            {
                {
                    switch( Direction ) {
                        case Direction.Reverse: SetDirection( Direction.N ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Neutral ); break;
                        case Direction.N: SetDirection( Direction.Forward ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.On ); break;
                        case Direction.Forward: SetDirection( Direction.Forward ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.On ); break;
                    }
                }
            }
        }

        public virtual void StartReverseDecrease( float? target )
        {
            AlerterReset();
            if (this.IsLeadLocomotive())
            {
                {
                    switch( Direction )
                    {
                        case Direction.Reverse: SetDirection( Direction.Reverse ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Off ); break;
                        case Direction.N: SetDirection( Direction.Reverse ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Off ); break;
                        case Direction.Forward: SetDirection( Direction.N ); Simulator.Confirmer.Confirm( CabControl.Reverser, CabSetting.Neutral ); break;
                    }
                }
            }
        }
        
        public void StartThrottleIncrease( float? target ) {
            AlerterReset();
            ThrottleController.StartIncrease( target );
            //Not needed, Update() handles it:
            // Simulator.Confirmer.ConfirmWithPerCent( CabControl.Regulator, CabSetting.Increase, ThrottleController.CurrentValue * 100 );
            SignalEvent(Event.ThrottleChange);
        }
        
        public bool StartThrottleIncrease()
        {
            bool notchedThrottleCommandNeeded = false;
            AlerterReset();
            
            CommandStartTime = Simulator.ClockTime;

            if (!HasCombCtrl && DynamicBrakePercent >= 0
                || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake))
                // signal sound
                return notchedThrottleCommandNeeded;

            float? smoothMax = ThrottleController.SmoothMax();

            if (HasCombCtrl && !HasCombThrottleTrainBrake && DynamicBrake)
            {
                StartDynamicBrakeDecrease( null );
                if (!HasSmoothStruc)
                    StopDynamicBrakeDecrease();
            }
            else if (smoothMax == null)
            {
                notchedThrottleCommandNeeded = true;
                SignalEvent(Event.ThrottleChange);
            }
            else
            {
                StartThrottleIncrease(smoothMax);
            }
            return notchedThrottleCommandNeeded;
        }

        public bool StopThrottleIncrease()
        {
            bool continuousThrottleCommandNeeded = false;

            AlerterReset();
            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return continuousThrottleCommandNeeded;
            ThrottleController.StopIncrease();
            
            if (ThrottleController.SmoothMax() != null)
            {
                continuousThrottleCommandNeeded = true;
            }
            
            if (HasCombCtrl  && !HasCombThrottleTrainBrake)
            {
                if (ThrottlePercent == 0)
                    StopDynamicBrakeDecrease();
            }
            return continuousThrottleCommandNeeded;
        }

        public void StartThrottleDecrease( float? target ) {
            AlerterReset();
            CommandStartTime = Simulator.ClockTime;
            ThrottleController.StartDecrease( target );
            //Not needed, Update() handles it:
            //Simulator.Confirmer.ConfirmWithPerCent( CabControl.Regulator, CabSetting.Decrease, ThrottleController.CurrentValue * 100 );
            SignalEvent(Event.ThrottleChange);
        }

        public bool StartThrottleDecrease()
        {
            bool notchedThrottleCommandNeeded = false;
            AlerterReset();
            
            CommandStartTime = Simulator.ClockTime;

            if (!HasCombCtrl && DynamicBrakePercent >= 0
                || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake))
                // signal sound
                return notchedThrottleCommandNeeded;

            float? smoothMin = ThrottleController.SmoothMin();

            if (HasCombCtrl && !HasCombThrottleTrainBrake && ThrottlePercent <= 0)
            {
                StartDynamicBrakeIncrease( null );
                if (!HasSmoothStruc)
                    StopDynamicBrakeIncrease();
            }
            else if (smoothMin == null)
            {
                notchedThrottleCommandNeeded = true;
                SignalEvent(Event.ThrottleChange);
            }
            else
            {
                StartThrottleDecrease(smoothMin);
            }
            return notchedThrottleCommandNeeded;
        }

        public bool StopThrottleDecrease()
        {
            bool continuousThrottleCommandNeeded = false;
            AlerterReset();

            if (!HasCombCtrl && DynamicBrakePercent >= 0)
                // signal sound
                return continuousThrottleCommandNeeded;

            ThrottleController.StopDecrease();
            
            if (ThrottleController.SmoothMin() != null)
            {
                continuousThrottleCommandNeeded = true;
            }

            if (HasCombCtrl  && !HasCombThrottleTrainBrake)
            {
                if (ThrottlePercent == 0)
                    StopDynamicBrakeIncrease();
            }
            return continuousThrottleCommandNeeded;
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void ThrottleChangeTo( bool increase, float? target ) {
            throttleTarget = target;
            if( increase ) {
                if( target > ThrottleController.CurrentValue ) {
                    StartThrottleIncrease( target );
                }
            } else {
                if( target < ThrottleController.CurrentValue ) {
                    StartThrottleDecrease( target );
                }
            }
        }

        /// <summary>
        /// Used by commands to make a single adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void AdjustNotchedThrottle( bool increase ) {
            if( increase ) {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
            } else {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
            }
            Simulator.Confirmer.ConfirmWithPerCent( CabControl.Throttle, ThrottleController.CurrentValue * 100 );
        }

        public void SetThrottlePercent(float percent)
        {
            ThrottlePercent = ThrottleController.SetRDPercent(percent);
        }

        public void StartTrainBrakeIncrease( float? target ) {
            AlerterReset();
            TrainBrakeController.StartIncrease( target );
            Simulator.Confirmer.Confirm( CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatus() );
                SignalEvent(Event.TrainBrakeChange);
        }

        public void StopTrainBrakeIncrease()
        {
            AlerterReset();
            TrainBrakeController.StopIncrease();
        }

        public void StartTrainBrakeDecrease( float? target ) {
            AlerterReset();
            TrainBrakeController.StartDecrease( target );
            Simulator.Confirmer.Confirm( CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatus() );
            SignalEvent(Event.TrainBrakeChange);
        }

        public void StopTrainBrakeDecrease()
        {
            AlerterReset();
            TrainBrakeController.StopDecrease();
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void TrainBrakeChangeTo( bool increase, float? target ) {  // Need a better way to express brake as a single number?
            trainBrakeTarget = target;
            if( increase ) {
                if( target > TrainBrakeController.CurrentValue ) {
                    StartTrainBrakeIncrease( target );
                }
            } else {
                if( target < TrainBrakeController.CurrentValue ) {
                    StartTrainBrakeDecrease( target );
                }
            }
        }

        public void EngineBrakeChangeTo( bool increase, float? target ) {  // Need a better way to express brake as a single number.
            engineBrakeTarget = target;
            if( increase ) {
                if( target > EngineBrakeController.CurrentValue ) {
                    StartEngineBrakeIncrease( target );
                }
            } else {
                if( target < EngineBrakeController.CurrentValue ) {
                    StartEngineBrakeDecrease( target );
                }
            }
        }

        public void DynamicBrakeChangeTo( bool increase, float? target ) {  // Need a better way to express brake as a single number.
            dynamicBrakeTarget = target;
            if( increase ) {
                if( target > DynamicBrakeController.CurrentValue ) {
                    StartDynamicBrakeIncrease( target );
                }
            } else {
                if( target < DynamicBrakeController.CurrentValue ) {
                    StartDynamicBrakeDecrease( target );
                }
            }
        }

        public void SetTrainBrakePercent(float percent)
        {
            TrainBrakeController.SetRDPercent(percent);
        }

        public void SetEmergency()
        {
            if (this.Train != null && this.Train.TrainType == Train.TRAINTYPE.REMOTE) return; //not apply emergency for remote trains.
            if (TrainBrakeController.GetIsEmergency())
                return;
            if(EmergencyCausesThrottleDown) ThrottleController.SetValue(0.0f);
            if (EmergencyCausesPowerDown) { SignalEvent(Event.Pantograph1Down); SignalEvent(Event.Pantograph2Down); }
            if (EmergencyEngagesHorn) SignalEvent(Event.HornOn);
            TrainBrakeController.SetEmergency();
            SignalEvent(Event.TrainBrakePressureDecrease);
            Simulator.Confirmer.Confirm( CabControl.EmergencyBrake, CabSetting.On );
        }

        public override string GetTrainBrakeStatus()
        {            
            string s = TrainBrakeController.GetStatus();
            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetFullStatus(lastCar.BrakeSystem);
            return s;
        }

        public void StartEngineBrakeIncrease( float? target ) {
            AlerterReset();
            if (EngineBrakeController == null)
                return;
            
            EngineBrakeController.StartIncrease( target );
            Simulator.Confirmer.Confirm( CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus() );
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        /// <returns>true if action is completed</returns>
        public bool StopEngineBrakeIncrease()
        {
            bool engineBrakeCommandNeeded = false;

            AlerterReset();
            if( EngineBrakeController != null ) {
                EngineBrakeController.StopIncrease();
                engineBrakeCommandNeeded = true;
            }
            return engineBrakeCommandNeeded;
        }

        public void StartEngineBrakeDecrease( float? target ) {
            AlerterReset();
            if (EngineBrakeController == null)
                return;
            
            EngineBrakeController.StartDecrease( target );
            EngineBrakeController.CommandStartTime = Simulator.ClockTime; // Remember when the command was issued
            Simulator.Confirmer.Confirm( CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus() );
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        /// <returns>true if action is completed</returns>
        public bool StopEngineBrakeDecrease()
        {
            bool engineBrakeCommandNeeded = false;

            AlerterReset();
            if( EngineBrakeController != null ) {
                EngineBrakeController.StopDecrease();
                engineBrakeCommandNeeded = true;
            }
            return engineBrakeCommandNeeded;
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetRDPercent(percent);
        }
  
        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");
        }

        public void SetBailOff(bool bailOff)
        {
            BailOff = bailOff;
            Simulator.Confirmer.Confirm( CabControl.BailOff, bailOff ? CabSetting.On : CabSetting.Off );
        }

        private bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null
                && ThrottlePercent == 0 && !HasDefectiveComboDynamicBreak);
        }

        public void StartDynamicBrakeIncrease( float? target ) {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0 && !DynamicBrake) // Activate
            {
                DynamicBrakePercent = 0;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
            else if (DynamicBrakePercent >= 0 && DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartIncrease( target );
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeIncrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public bool StopDynamicBrakeIncrease()
        {
            bool dynamicBrakeCommandNeeded = false;
            
            AlerterReset();
            if( CanUseDynamicBrake() ) {
                DynamicBrakeController.StopIncrease();
                dynamicBrakeCommandNeeded = true;
            }
            return dynamicBrakeCommandNeeded;
        }

        public void StartDynamicBrakeDecrease( float? target )
        {
            AlerterReset();
            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0 && DynamicBrake) // Deactivate
            {
                SignalEvent(Event.DynamicBrakeOff);
                DynamicBrakePercent = -1;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeDecrease();
            }
            else if (DynamicBrakePercent >= 0 && DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartDecrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeDecrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public bool StopDynamicBrakeDecrease()
        {
            bool dynamicBrakeCommandNeeded = false;

            AlerterReset();
            if( CanUseDynamicBrake() ) {
                DynamicBrakeController.StopDecrease();
                dynamicBrakeCommandNeeded = true;
            }
            return dynamicBrakeCommandNeeded;
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakePercent = DynamicBrakeController.SetRDPercent(percent);
            if (percent < 0)
                DynamicBrakePercent = percent;
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            if (DynamicBrakePercent < 0)
                return string.Empty;
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }

        public void SetTrainHandbrake( bool apply ) {
            if( apply ) {
                Train.SetHandbrakePercent( 100 );
                Simulator.Confirmer.Confirm( CabControl.Handbrake, CabSetting.On );
            } else {
                Train.SetHandbrakePercent( 0 );
                Simulator.Confirmer.Confirm( CabControl.Handbrake, CabSetting.Off );
            }
        }

        public void SetTrainRetainers( bool apply ) {
            Train.SetRetainers( apply );
            Simulator.Confirmer.ConfirmWithPerCent( CabControl.Retainers, CabSetting.Increase, Train.RetainerPercent, (int)CabSetting.Range1 + (int)Train.RetainerSetting );
        }

        public void BrakeHoseConnect( bool apply ) {
            if( apply ) {
                Train.ConnectBrakeHoses();
                Simulator.Confirmer.Confirm( CabControl.BrakeHose, CabSetting.On );
            } else {
                Train.DisconnectBrakes();
                Simulator.Confirmer.Confirm( CabControl.BrakeHose, CabSetting.Off );
            }
        }

        public void ToggleCabLight() {
            CabLightOn = !CabLightOn;
            SignalEvent(Event.LightSwitchToggle);
            Simulator.Confirmer.Confirm( CabControl.CabLight, CabLightOn ? CabSetting.On : CabSetting.Off );
        }

        public void ToggleWipers() {
            SignalEvent(Wiper ? Event.WiperOff : Event.WiperOn);
        }

#if NEW_SIGNALLING
        public override bool GetCabFlipped()
        {
            return UsingRearCab;
        }
#endif

        public class Alerter
        {
            int AlerterStartTime;
            int AlerterAlarmTime;
            public bool AlerterIsEnabled = false;
            public bool AlerterResetReceived = false;

            public void AlerterEnableSetup(int alarmStart, int alarmEnd)
            {
                AlerterStartTime = alarmStart;
                AlerterAlarmTime = alarmEnd;
            }

            public void AlerterEnableSet()
            {
                AlerterIsEnabled = true;
            }

            public void AlerterDisAble()
            {
                AlerterIsEnabled = false;
            }

            public void AlerterReset()
            {
                if (AlerterResetReceived)
                    AlerterResetReceived = false;
                else
                    AlerterResetReceived = true;
            }
            
            public bool AlerterTimerTrigger(int clockTime)
            {
                if (AlerterIsEnabled && clockTime >= AlerterAlarmTime)
                    return true;
                else
                    return false;
            }
        } //End Class Alerter

        Alerter timerAlerter1 = new Alerter();
        Alerter timerAlerter2 = new Alerter();
        //bool alarm1Fired = false;
        //bool alarm2Fired = false;

        public void AlerterStartUp()
        {
            AlerterEnableGetTime();
            timerAlerter1.AlerterEnableSet();
            timerAlerter2.AlerterEnableSet();
            AlerterIsActive = true;
        }

        public void AlerterEnableGetTime()
        {
            int startTime = (int)Simulator.ClockTime;
            int alterterAlarm = startTime + 30;
            int penaltyAlarm = startTime + 49;
            timerAlerter1.AlerterEnableSetup(startTime, alterterAlarm);
            timerAlerter2.AlerterEnableSetup(startTime, penaltyAlarm);
            //SignalEvent(Event.AlerterSoundOff);
        }

        public void AlerterReset()
        {
            if (AlerterIsActive)
            {
                AlerterEnableGetTime();
            }
        }

        public void AlerterResetExternal()
        {
            timerAlerter1.AlerterReset();
            timerAlerter2.AlerterReset();
            AlerterEnableGetTime();
        }

        public override void SignalEvent(Event evt)
        {
            switch (evt)
            {
                case Event.VigilanceAlarmOn: { AlerterSnd = true; Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.On); break; }
                case Event.VigilanceAlarmOff: { AlerterSnd = false; Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.Off); break; }
                case Event.BellOn: { Bell = true; if (Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Bell, CabSetting.On); break; }
                case Event.BellOff: { Bell = false; Simulator.Confirmer.Confirm(CabControl.Bell, CabSetting.Off); break; }
                case Event.HornOn:
                    {
                        Horn = true;
                        if (this != Program.Simulator.PlayerLocomotive) break;
                        if (this is MSTSSteamLocomotive)
                        {
                            Simulator.Confirmer.Confirm(CabControl.Whistle, CabSetting.On);
                        }
                        else
                        {
                            Simulator.Confirmer.Confirm(CabControl.Horn, CabSetting.On);
                        }
                        break;
                    }
                case Event.HornOff:
                    {
                        Horn = false;
                        if (this != Program.Simulator.PlayerLocomotive) break;
                        if (this is MSTSSteamLocomotive)
                        {
                            Simulator.Confirmer.Confirm(CabControl.Whistle, CabSetting.Off);
                        }
                        else
                        {
                            Simulator.Confirmer.Confirm(CabControl.Horn, CabSetting.Off);
                        }
                        break;
                    }
                case Event.SanderOn: { Sander = true; if (this.IsLeadLocomotive() && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.On); break; }
                case Event.SanderOff: { Sander = false; if (this.IsLeadLocomotive()) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.Off); break; }
                case Event.WiperOn: { Wiper = true; if (this == Program.Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.On); break; }
                case Event.WiperOff: { Wiper = false; if (this == Program.Simulator.PlayerLocomotive)  Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.Off); break; }

                // <CJComment> The "H" key doesn't call these SignalEvents yet. </CJComment>
                case Event._HeadlightOff: { Headlight = 0; break; }
                case Event._HeadlightDim: { Headlight = 1; break; }
                case Event._HeadlightOn: { Headlight = 2; break; }

                case Event.CompressorOn: { CompressorOn = true; break; }
                case Event.CompressorOff: { CompressorOn = false; break; }
                case Event._ResetWheelSlip: { LocomotiveAxle.Reset(SpeedMpS); ThrottleController.SetValue(0.0f); break; }
            }

            base.SignalEvent(evt);
        }

        /// <summary>
        /// Gets the Locomotive data needed by the Cab View Control
        /// Check here for Signal display
        /// </summary>
        /// <param name="cvc">The Cab View Control</param>
        /// <returns>The data converted to the requested unit</returns>
        public void CheckVigilance()
        {

            {
                bool alarm1Fired = false;
                bool alarm2Fired = false;

                if (timerAlerter1.AlerterIsEnabled)
                {
                    if (timerAlerter1.AlerterTimerTrigger((int)Simulator.ClockTime))
                        alarm1Fired = true;
                    //SignalEvent(Event.AlerterOn);
                }

                if (timerAlerter2.AlerterIsEnabled)
                {
                    if (timerAlerter2.AlerterTimerTrigger((int)Simulator.ClockTime))
                    {
                        alarm2Fired = true;
                        SetEmergency();
                    }
                }

                if (alarm1Fired)
                {
                    if( ! AlerterSnd ) {
                        SignalEvent(Event.VigilanceAlarmOn);
                    }
                }
                else
                {
                    if( AlerterSnd ) {
                        SignalEvent(Event.VigilanceAlarmOff);
                    }
                }
            }
        }

        public virtual float GetDataOf(CabViewControl cvc)
        {
            if( Simulator.Settings.Alerter ) CheckVigilance();
            float data = 0;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        //data = SpeedMpS;
                        if (Simulator.UseAdvancedAdhesion && (!AntiSlip))
                            data = WheelSpeedMpS;
                        else
                            data = SpeedMpS;

                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.ACCELEROMETER:
                    {
                        switch(cvc.Units)
                        {
                            case CABViewControlUnits.METRES_SEC_SEC:
                                data = this.AccelerationMpSS;
                                break;

                            case CABViewControlUnits.METRES_SEC_HOUR:
                                data = this.AccelerationMpSS * 3600.0f;
                                break;

                            case CABViewControlUnits.KM_HOUR_SEC:
                                data = this.AccelerationMpSS * 3.6f;
                                break;

                            case CABViewControlUnits.KM_HOUR_HOUR:
                                data = this.AccelerationMpSS * 3.6f * 3600.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_MIN:
                                data = this.AccelerationMpSS * 2.236936f * 60.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_HOUR:
                                // 
                                data = this.AccelerationMpSS * 2.236936f * 3600.0f;
                                break;

                            default:
                                data = this.AccelerationMpSS;
                                break;

                        }
                        break;
                    }
                case CABViewControlTypes.AMMETER: // Current not modelled yet to ammeter shows tractive effort until then.
                case CABViewControlTypes.AMMETER_ABS:
                case CABViewControlTypes.LOAD_METER:
                case CABViewControlTypes.TRACTION_BRAKING:
                    {
                        if (LocomotiveAxle != null)
                        {
                            data = 0.0f;
                            if (ThrottlePercent > 0)
                            {
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxForceN * (float)(cvc.MaxValue);
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxForceN * (float)(cvc.MaxValue);
                                data = Math.Abs(data);
                            }
                            if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                            {
                                if (FilteredMotiveForceN != 0)
                                    data = this.FilteredMotiveForceN / MaxDynamicBrakeForceN * (float)(cvc.MaxValue);
                                else
                                    data = this.LocomotiveAxle.AxleForceN / MaxDynamicBrakeForceN * (float)(cvc.MaxValue);
                                data = -Math.Abs(data);
                            }
                            break;
                        }
                        data = this.MotiveForceN / MaxForceN * (float)cvc.MaxValue;
                        break;
                    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = ConvertFromPSI(cvc, MainResPressurePSI);
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                    {
                        data = ConvertFromPSI(cvc, this.BrakeSystem.BrakeLine1PressurePSI);
                        break;
                    }
                case CABViewControlTypes.EQ_RES:
                    {
                        data = ConvertFromPSI(cvc, this.Train.BrakeLine1PressurePSI);
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetCylPressurePSI());
                        break;
                    }
                case CABViewControlTypes.RPM:
                    {
                        if (((MSTSDieselLocomotive)this).EngineRPM != null)
                            data = ((MSTSDieselLocomotive)this).EngineRPM;
                        break;
                    }
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                case CABViewControlTypes.CPH_DISPLAY:
                    {
                        data = ThrottlePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        data = (EngineBrakeController == null) ? 0.0f : EngineBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.FRICTION_BRAKING:
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        data = (TrainBrakeController == null) ? 0.0f : TrainBrakeController.CurrentValue;
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                //case CABViewControlTypes.CP_HANDLE:
                    {
                        data = DynamicBrakePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        data = Wiper ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HORN:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.RESET:
                    {
                        if (timerAlerter1.AlerterResetReceived)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
 
                case CABViewControlTypes.ALERTER_DISPLAY:
                    {
                        if( Simulator.Settings.Alerter ) {
                            bool alarm1Fired = false;
                            bool alarm2Fired = false;

                            if (timerAlerter1.AlerterIsEnabled)
                            {
                                if (timerAlerter1.AlerterTimerTrigger((int)Simulator.ClockTime))
                                    alarm1Fired = true;
                            }

                            if (timerAlerter2.AlerterIsEnabled)
                            {
                                if (timerAlerter2.AlerterTimerTrigger((int)Simulator.ClockTime))
                                {
                                    alarm2Fired = true;
                                }
                            }

                            if (alarm1Fired)
                            {
                                data = 1;
                                if( ! AlerterSnd ) {
                                    SignalEvent(Event.VigilanceAlarmOn);
                                }
                            }
                            else if (alarm2Fired)
                                data = 2;
                            else
                            {
                                data = 0;
                                if( AlerterSnd ) {
                                    SignalEvent(Event.VigilanceAlarmOff);
                                }
                            }
                        }
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                // MultStateDisplay entry in CVF file had Type SANDING. W/O the below entry and another entry at line 3625
                // the independant sanding light found in some cabs would not work.
                case CABViewControlTypes.SANDING:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.CLOCK:
                    {
                        data = 0;
                        break;
                    }

                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        data = Headlight;
                        break;
                    }
                case CABViewControlTypes.WHEELSLIP:
                    {
                        if(Simulator.UseAdvancedAdhesion)
                            data = LocomotiveAxle.IsWheelSlipWarning ? 1 : 0;
                        else
                            data = WheelSlip ? 1 : 0;
                        break;
                    }
    
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        if (Direction == Direction.Forward)
                            data = 2;
                        else if (Direction == Direction.Reverse)
                            data = 0;
                        else
                            data = 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (Train.CABAspect)
                        {
                            case SignalHead.SIGASP.STOP:
                                {
                                    data = 0;
                                    break;
                                }
                            case SignalHead.SIGASP.STOP_AND_PROCEED:
                                {
                                    data = 1;
                                    break;
                                }
                            case SignalHead.SIGASP.RESTRICTING:
                                {
                                    data = 2;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_1:
                                {
                                    data = 3;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_2:
                                {
                                    data = 4;
                                    break;
                                }
                            case SignalHead.SIGASP.APPROACH_3:
                                {
                                    data = 5;
                                    break;
                                }
                            case SignalHead.SIGASP.CLEAR_1:
								{
									data = 6;
									break;
								}
							case SignalHead.SIGASP.CLEAR_2:
                                {
                                    data = 7;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                case CABViewControlTypes.SPEEDLIM_DISPLAY:
                    {
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        if (this.Train.CABAspect == SignalHead.SIGASP.STOP ||
                                this.Train.CABAspect == SignalHead.SIGASP.STOP_AND_PROCEED)
                        {
                            data = 0;
                        }
                        else
                        {
                            data = MpS.FromMpS(this.Train.AllowedMaxSpeedMpS, metric);
                        }
                        break;
                    }
                // Steam instruments
                case CABViewControlTypes.STEAM_PR:
                    {
                        data = ConvertFromPSI(cvc, ((MSTSSteamLocomotive)this).BoilerPressurePSI);
                        break;
                    }
                default:
                    {
                        data = 0;
                        break;
                    }
            }
            return data;
        }

        private static float ConvertFromPSI(CabViewControl cvc, float data)
        {
            if (cvc.Units == CABViewControlUnits.BAR)
                data *= 68.948e-3f;
            else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                data *= 6.89476f;
            else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                data *= 70.307e-3f;
            return data;
        }

    } // End Class MSTSLocomotive

    public class CabView {
        public CVFFile CVFFile;
        public List<ViewPoint> ViewPointList;
        public ExtendedCVF ExtendedCVF;

        public CabView(CVFFile cvfFile, List<ViewPoint> viewPointList, ExtendedCVF extendedCVF)
        {
            CVFFile = cvfFile;
            ViewPointList = viewPointList;
            ExtendedCVF = extendedCVF;
        }
    }

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    [ORTSPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        [ORTSPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        public Vector4 Light1Position;

        [ORTSPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        public Color Light1Color;

        [ORTSPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        public Vector4 Light2Position;

        [ORTSPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        public Color Light2Color;

    } // End Class ExtendedCVF

    ///////////////////////////////////////////////////
    ///   3D VIEW
    ///////////////////////////////////////////////////

    /// <summary>
    /// Adds animation for wipers to the basic TrainCar
    /// </summary>
    public class MSTSLocomotiveViewer : MSTSWagonViewer
    {
        MSTSLocomotive Locomotive;

        protected Dictionary<string, List<ParticleEmitterDrawer>> ParticleDrawers = new Dictionary<string, List<ParticleEmitterDrawer>>();

        protected MSTSLocomotive MSTSLocomotive { get { return (MSTSLocomotive)Car; } }

        private bool _hasCabRenderer = false;
        private CabRenderer _CabRenderer = null;

        public MSTSLocomotiveViewer(Viewer3D viewer, MSTSLocomotive car)
            : base(viewer, car)
        {
            Locomotive = car;
            ParticleDrawers = (from effect in Locomotive.EffectData
                               select new KeyValuePair<string, List<ParticleEmitterDrawer>>(effect.Key, new List<ParticleEmitterDrawer>(from data in effect.Value
                                                                                                                                        select new ParticleEmitterDrawer(viewer, data)))).ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

            //if (car.CVFFile != null && car.CVFFile.TwoDViews.Count > 0)
            //    _CabRenderer = new CabRenderer(viewer, Locomotive);

            string wagonFolderSlash = Path.GetDirectoryName(Locomotive.WagFilePath) + "\\";
            if (Locomotive.CabSoundFileName != null) LoadCarSound(wagonFolderSlash, Locomotive.CabSoundFileName);

            SoundSources.Add(new TrackSoundSource(MSTSWagon, Viewer));
        }

        bool SwapControl()
        {
            if (Locomotive.HasCombThrottleTrainBrake)
                return true;
            else
                return false;
        }

        void StartThrottleIncrease()
        {
            if (!SwapControl()) // tests for CombThrottleTrainBreak
            {
                if( !Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0 ) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn1 );
                    return;
                } else {
                    if( Locomotive.StartThrottleIncrease() )
                        new NotchedThrottleCommand( Viewer.Log, true );
                }
            }else{
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                //if (trainBreakPercent > 0)
                if (throttlePercent == 0 && trainBreakPercent > 0)
                {
                    Locomotive.StopThrottleIncrease();
                    Locomotive.StartTrainBrakeDecrease( null );
                }
            }
        }

        void StopThrottleIncrease()
        {
            if (!SwapControl()) // tests for CombThrottleTrainBreak
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn1 );
                    return;
                } else
                    if( Locomotive.StopThrottleIncrease() )
                        new ContinuousThrottleCommand( Viewer.Log, true, Locomotive.ThrottleController.CurrentValue, Locomotive.CommandStartTime );
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                if (throttlePercent == 0 && trainBreakPercent > 0)
                {
                    Locomotive.StopTrainBrakeDecrease();
                }
                else
                {
                    Locomotive.StartThrottleIncrease();
                    Locomotive.StopThrottleIncrease();
                }
            }
        }

        void StartThrottleDecrease()
        {
            if (!SwapControl())
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn1 );
                    return;
                } else {
                    if( Locomotive.StartThrottleDecrease() )
                        new NotchedThrottleCommand( Viewer.Log, false );
                }
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                if (throttlePercent == 0 && trainBreakPercent >= 0)
                {
                    Locomotive.StopThrottleDecrease();
                    Locomotive.StartTrainBrakeIncrease( null );
                }else{
                    Locomotive.StartThrottleDecrease();
                }
            }
        }

        void StopThrottleDecrease()
        {
            if (!SwapControl()) // tests for CombThrottleTrainBrea
            {
                if (!Locomotive.HasCombCtrl && Locomotive.DynamicBrakePercent >= 0) {
                    Viewer.Simulator.Confirmer.Warning( CabControl.Throttle, CabSetting.Warn1 );
                    return;
                } else
                    if( Locomotive.StopThrottleDecrease() )
                        new ContinuousThrottleCommand( Viewer.Log, false, Locomotive.ThrottleController.CurrentValue, Locomotive.CommandStartTime );
            }
            else
            {
                float trainBreakPercent = Locomotive.TrainBrakeController.CurrentValue * 100.0f;
                float throttlePercent = Locomotive.ThrottlePercent;

                if (throttlePercent == 0 && trainBreakPercent >= 0)
                    Locomotive.StopTrainBrakeIncrease();
            }
        }

        protected virtual void ReverserControlForwards() {
            if( Locomotive.Direction != Direction.Forward
            && (Locomotive.ThrottlePercent >= 1 
            || Math.Abs(Locomotive.SpeedMpS) > 1 ) ) {
                Viewer.Simulator.Confirmer.Warning( CabControl.Reverser, CabSetting.Warn1 );
                return;
            }
            new ReverserCommand( Viewer.Log, true );    // No harm in trying to engage Forward when already engaged.
        }

        protected virtual void ReverserControlBackwards() {
            if( Locomotive.Direction != Direction.Reverse
            && (Locomotive.ThrottlePercent >= 1 
            || Math.Abs(Locomotive.SpeedMpS) > 1 ) ) {
                Viewer.Simulator.Confirmer.Warning( CabControl.Reverser, CabSetting.Warn1 );
                return;
            }
            new ReverserCommand( Viewer.Log, false );    // No harm in trying to engage Reverse when already engaged.
        }

        /// <summary>
        /// A keyboard or mouse click has occurred. Read the UserInput
        /// structure to determine what was pressed.
        /// </summary>
        public override void HandleUserInput(ElapsedTime elapsedTime)
        {
            if (UserInput.IsPressed(UserCommands.ControlForwards)) ReverserControlForwards();
            if (UserInput.IsPressed(UserCommands.ControlBackwards)) ReverserControlBackwards();

            if (UserInput.IsPressed( UserCommands.ControlThrottleIncrease)) StartThrottleIncrease();
            if (UserInput.IsReleased(UserCommands.ControlThrottleIncrease)) StopThrottleIncrease();
            if (UserInput.IsPressed( UserCommands.ControlThrottleDecrease)) StartThrottleDecrease();
            if (UserInput.IsReleased(UserCommands.ControlThrottleDecrease)) StopThrottleDecrease();

            if( UserInput.IsPressed( UserCommands.ControlTrainBrakeIncrease ) ) {
                Locomotive.StartTrainBrakeIncrease( null );
                Locomotive.TrainBrakeController.CommandStartTime = _Viewer3D.Simulator.ClockTime;
            }
            if( UserInput.IsReleased( UserCommands.ControlTrainBrakeIncrease ) ) {
                Locomotive.StopTrainBrakeIncrease();
                new TrainBrakeCommand( Viewer.Log, true, Locomotive.TrainBrakeController.CurrentValue, Locomotive.TrainBrakeController.CommandStartTime );
            }
            if( UserInput.IsPressed( UserCommands.ControlTrainBrakeDecrease ) ) {
                Locomotive.StartTrainBrakeDecrease( null );
                Locomotive.TrainBrakeController.CommandStartTime = _Viewer3D.Simulator.ClockTime;
            }
            if( UserInput.IsReleased( UserCommands.ControlTrainBrakeDecrease ) ) {
                Locomotive.StopTrainBrakeDecrease();
                new TrainBrakeCommand( Viewer.Log, false, Locomotive.TrainBrakeController.CurrentValue, Locomotive.TrainBrakeController.CommandStartTime );
            }
            if( UserInput.IsPressed( UserCommands.ControlEngineBrakeIncrease ) ) Locomotive.StartEngineBrakeIncrease( null );
            if( UserInput.IsReleased( UserCommands.ControlEngineBrakeIncrease ) ) {
                if( Locomotive.StopEngineBrakeIncrease() ) {
                    new EngineBrakeCommand( Viewer.Log, true, Locomotive.EngineBrakeController.CurrentValue, Locomotive.EngineBrakeController.CommandStartTime );
                }
            }
            if( UserInput.IsPressed( UserCommands.ControlEngineBrakeDecrease ) ) Locomotive.StartEngineBrakeDecrease( null );
            if( UserInput.IsReleased( UserCommands.ControlEngineBrakeDecrease ) ) { 
                if( Locomotive.StopEngineBrakeDecrease() ) {
                    new EngineBrakeCommand( Viewer.Log, false, Locomotive.EngineBrakeController.CurrentValue, Locomotive.EngineBrakeController.CommandStartTime );
                }
            }
            if( UserInput.IsPressed( UserCommands.ControlDynamicBrakeIncrease ) ) Locomotive.StartDynamicBrakeIncrease( null );
            if( UserInput.IsReleased( UserCommands.ControlDynamicBrakeIncrease ) ) 
                if( Locomotive.StopDynamicBrakeIncrease() )
                    new DynamicBrakeCommand( Viewer.Log, true, Locomotive.DynamicBrakeController.CurrentValue, Locomotive.DynamicBrakeController.CommandStartTime );
            if( UserInput.IsPressed( UserCommands.ControlDynamicBrakeDecrease ) ) Locomotive.StartDynamicBrakeDecrease( null );
            if( UserInput.IsReleased( UserCommands.ControlDynamicBrakeDecrease ) ) 
                if( Locomotive.StopDynamicBrakeDecrease() )
                    new DynamicBrakeCommand( Viewer.Log, false, Locomotive.DynamicBrakeController.CurrentValue, Locomotive.DynamicBrakeController.CommandStartTime );

            if( UserInput.IsPressed( UserCommands.ControlBailOff ) ) new BailOffCommand( Viewer.Log, true );
            if( UserInput.IsReleased( UserCommands.ControlBailOff ) ) new BailOffCommand( Viewer.Log, false );

            if( UserInput.IsPressed( UserCommands.ControlInitializeBrakes ) ) new InitializeBrakesCommand( Viewer.Log );
            if( UserInput.IsPressed( UserCommands.ControlHandbrakeNone ) ) new HandbrakeCommand( Viewer.Log, false );
            if( UserInput.IsPressed( UserCommands.ControlHandbrakeFull ) ) new HandbrakeCommand( Viewer.Log, true );
            if( UserInput.IsPressed( UserCommands.ControlRetainersOff ) ) new RetainersCommand( Viewer.Log, false );
            if( UserInput.IsPressed( UserCommands.ControlRetainersOn ) ) new RetainersCommand( Viewer.Log, true );
            if( UserInput.IsPressed( UserCommands.ControlBrakeHoseConnect ) ) new BrakeHoseConnectCommand( Viewer.Log, true );
            if( UserInput.IsPressed( UserCommands.ControlBrakeHoseDisconnect ) ) new BrakeHoseConnectCommand( Viewer.Log, false );
            if( UserInput.IsPressed( UserCommands.ControlEmergency ) ) new EmergencyBrakesCommand( Viewer.Log );

            // <CJComment> Some inputs calls their method directly, other via a SignalEvent. 
            // Probably because a signal can then be handled more than once, 
            // e.g. by every locomotive on the train or every car in the consist.
            // The signals are distributed through the parent class MSTSWagon:SignalEvent </CJComment>
            if( UserInput.IsPressed( UserCommands.ControlSander ) ) new SanderCommand( Viewer.Log, Locomotive.Sander );
            if( UserInput.IsPressed( UserCommands.ControlWiper ) ) new ToggleWipersCommand( Viewer.Log );
            if( UserInput.IsPressed( UserCommands.ControlHorn ) ) new HornCommand( Viewer.Log, true );
            if( UserInput.IsReleased( UserCommands.ControlHorn ) ) new HornCommand( Viewer.Log, false );
            if( UserInput.IsPressed( UserCommands.ControlBell ) ) new BellCommand( Viewer.Log, !Locomotive.Bell );
            if( UserInput.IsPressed( UserCommands.ControlAlerter ) ) new AlerterCommand( Viewer.Log );  // z

            if( UserInput.IsPressed( UserCommands.ControlHeadlightDecrease ) ) new HeadlightCommand( Viewer.Log, false );
            if( UserInput.IsPressed( UserCommands.ControlHeadlightIncrease ) ) new HeadlightCommand( Viewer.Log, true );
#if !NEW_SIGNALLING
            if (UserInput.IsPressed(UserCommands.DebugForcePlayerAuthorization))
                Program.Simulator.AI.Dispatcher.ExtendPlayerAuthorization(true);
#endif

            // By GeorgeS
            if( UserInput.IsPressed( UserCommands.ControlLight ) ) {
                if( Locomotive is MSTSSteamLocomotive ) {       // By default, the "L" key is used for injector2 on steam locos
                    // do nothing
                }else{
                    new ToggleCabLightCommand( Viewer.Log );    // and cab lights on other locos.
                }
            }
            if (UserInput.IsPressed(UserCommands.CameraToggleShowCab)) Locomotive.ShowCab = !Locomotive.ShowCab;

            // By Matej Pacha
            if (UserInput.IsPressed(UserCommands.DebugResetWheelSlip)) { Locomotive.Train.SignalEvent(Event._ResetWheelSlip); }
            if (UserInput.IsPressed(UserCommands.DebugToggleAdvancedAdhesion)) { Locomotive.Train.SignalEvent(Event._ResetWheelSlip); Locomotive.Simulator.UseAdvancedAdhesion = !Locomotive.Simulator.UseAdvancedAdhesion; }

            if (UserInput.RDState != null)
            {
                if (UserInput.RDState.BailOff) {
                    Locomotive.SetBailOff( true );
                }
                if (UserInput.RDState.Changed)
                {
                    Locomotive.SetThrottlePercent(UserInput.RDState.ThrottlePercent);
                    Locomotive.SetTrainBrakePercent(UserInput.RDState.TrainBrakePercent);
                    Locomotive.SetEngineBrakePercent(UserInput.RDState.EngineBrakePercent);
                    Locomotive.SetDynamicBrakePercent(UserInput.RDState.DynamicBrakePercent);
                    if (UserInput.RDState.DirectionPercent > 50)
                        Locomotive.SetDirection(Direction.Forward);
                    else if (UserInput.RDState.DirectionPercent < -50)
                        Locomotive.SetDirection(Direction.Reverse);
                    else
                        Locomotive.SetDirection(Direction.N);
                    if( UserInput.RDState.Emergency ) {
                        Locomotive.SetEmergency();
                    }
                    if (UserInput.RDState.Wipers == 1 && Locomotive.Wiper)
                        Locomotive.SignalEvent(Event.WiperOff);
                    if (UserInput.RDState.Wipers != 1 && !Locomotive.Wiper)
                        Locomotive.SignalEvent(Event.WiperOn);
                    // changing Headlight more than one step at a time doesn't work for some reason
                    if (Locomotive.Headlight < UserInput.RDState.Lights - 1)
                        Locomotive.Headlight++;
                    if (Locomotive.Headlight > UserInput.RDState.Lights - 1)
                        Locomotive.Headlight--;
                }
            }

			base.HandleUserInput(elapsedTime);
        }

        /// <summary>
        /// We are about to display a video frame.  Calculate positions for 
        /// animated objects, and add their primitives to the RenderFrame list.
        /// </summary>
        public override void PrepareFrame(RenderFrame frame, ElapsedTime elapsedTime)
        {
            foreach (List<ParticleEmitterDrawer> drawers in ParticleDrawers.Values)
            {
                foreach (ParticleEmitterDrawer drawer in drawers)
                {
                    drawer.WorldPosition = Locomotive.WorldPosition;
                    drawer.PrepareFrame(frame, elapsedTime);
                }
            }

            // Wiper animation
            Wipers.UpdateLoop(Locomotive.Wiper, elapsedTime);

            // Draw 2D CAB View - by GeorgeS
            if (Viewer.Camera.AttachedCar == this.MSTSWagon &&
                Viewer.Camera.Style == Camera.Styles.Cab)
            {

                if (_CabRenderer != null)
                    _CabRenderer.PrepareFrame(frame);
            }

            base.PrepareFrame( frame, elapsedTime );
        }

        internal override void LoadForPlayer()
        {
            if (!_hasCabRenderer)
            {
                if (Locomotive.CabViewList.Count > 0)
                {
                _hasCabRenderer = true;
                    if (Locomotive.CabViewList[(int)CabViewType.Front].CVFFile != null && Locomotive.CabViewList[(int)CabViewType.Front].CVFFile.TwoDViews.Count > 0)
                    _CabRenderer = new CabRenderer(Viewer, Locomotive);
            }
        }
        }

        internal override void Mark()
        {
            foreach (var pdl in ParticleDrawers.Values)
                foreach (var pd in pdl)
                    pd.Mark();
            if (_CabRenderer != null)
                _CabRenderer.Mark();
            base.Mark();
        }

        /// <summary>
        /// This doesn't function yet.
        /// </summary>
        public override void Unload()
        {
            base.Unload();
        }

    } // Class LocomotiveViewer

    // By GeorgeS
    /// <summary>
    /// Manages all CAB View textures - light conditions and texture parts
    /// </summary>
    public static class CABTextureManager
    {
        private static Dictionary<string, Texture2D> DayTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> NightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D> LightTextures = new Dictionary<string, Texture2D>();
        private static Dictionary<string, Texture2D[]> PDayTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PNightTextures = new Dictionary<string, Texture2D[]>();
        private static Dictionary<string, Texture2D[]> PLightTextures = new Dictionary<string, Texture2D[]>();

        /// <summary>
        /// Loads a texture, day night and cablight
        /// </summary>
        /// <param name="viewer">Viver3D</param>
        /// <param name="FileName">Name of the Texture</param>
        /// <summary>
        /// Loads a texture, day night and cablight
        /// </summary>
        /// <param name="viewer">Viver3D</param>
        /// <param name="FileName">Name of the Texture</param>
        public static void LoadTextures(Viewer3D viewer, string FileName)
        {
            if (string.IsNullOrEmpty(FileName))
                return;

            if (DayTextures.Keys.Contains(FileName))
                return;

            if (File.Exists(FileName))
                DayTextures.Add(FileName, viewer.TextureManager.Get(FileName));
            else
                DayTextures.Add(FileName, SharedMaterialManager.MissingTexture);

            var nightpath = Path.Combine(Path.Combine(Path.GetDirectoryName(FileName), "night"), Path.GetFileName(FileName));
            if (File.Exists(nightpath))
                NightTextures.Add(FileName, viewer.TextureManager.Get(nightpath));
            else
                NightTextures.Add(FileName, SharedMaterialManager.MissingTexture);

            var lightpath = Path.Combine(Path.Combine(Path.GetDirectoryName(FileName), "cablight"), Path.GetFileName(FileName));
            if (File.Exists(lightpath))
                LightTextures.Add(FileName, viewer.TextureManager.Get(lightpath));
            else
                LightTextures.Add(FileName, SharedMaterialManager.MissingTexture);
        }

        static Texture2D[] Disassemble(GraphicsDevice graphicsDevice, Texture2D texture, Point controlSize, int frameCount, Point frameGrid, string fileName)
        {
            if (frameGrid.X < 1 || frameGrid.Y < 1 || frameCount < 1)
            {
                Trace.TraceWarning("Cab control has invalid frame data {1}*{2}={3} (no frames will be shown) for {0}", fileName, frameGrid.X, frameGrid.Y, frameCount);
                return new Texture2D[0];
            }

            var frameSize = new Point(texture.Width / frameGrid.X, texture.Height / frameGrid.Y);
            var frames = new Texture2D[frameCount];
            var frameIndex = 0;

            if (controlSize.X < frameSize.X || controlSize.Y < frameSize.Y)
            {
                //some may mess up the dimension, will try to reverse
                if (frameGrid.X != 1 && frameGrid.Y != 1)
                {
                    Trace.TraceWarning("Cab control size {1}x{2} is smaller than frame size {3}x{4} (frames may be cut-off) for {0}\nOR will try to reverse the dimension (may not work), better to change the CVF file accordingly.", fileName, controlSize.X, controlSize.Y, frameSize.X, frameSize.Y);
                    var tmp = frameGrid.X; frameGrid.X = frameGrid.Y; frameGrid.Y = tmp;
                    frameSize = new Point(texture.Width / frameGrid.X, texture.Height / frameGrid.Y);
                }
                else Trace.TraceWarning("Cab control size {1}x{2} is smaller than frame size {3}x{4} (frames may be cut-off) for {0}.", fileName, controlSize.X, controlSize.Y, frameSize.X, frameSize.Y);

            }
            if (frameCount > frameGrid.X * frameGrid.Y)
                Trace.TraceWarning("Cab control frame count {1} is larger than the number of frames {2}*{3}={4} (some frames will be blank) for {0}", fileName, frameCount, frameGrid.X, frameGrid.Y, frameGrid.X * frameGrid.Y);

            if (texture.Format != SurfaceFormat.Color && texture.Format != SurfaceFormat.Dxt1)
            {
                Trace.TraceWarning("Cab control texture {0} has unsupported format {1}; only Color and Dxt1 are supported.", fileName, texture.Format);
            }
            else
            {
                var copySize = new Point(Math.Min(controlSize.X, frameSize.X), Math.Min(controlSize.Y, frameSize.Y));
                if (texture.Format == SurfaceFormat.Dxt1)
                {
                    controlSize.X = (int)Math.Ceiling((float)controlSize.X / 4) * 4;
                    controlSize.Y = (int)Math.Ceiling((float)controlSize.Y / 4) * 4;
                    var buffer = new byte[(int)Math.Ceiling((float)copySize.X / 4) * 4 * (int)Math.Ceiling((float)copySize.Y / 4) * 4 / 2];
                    frameIndex = DisassembleFrames(graphicsDevice, texture, frameCount, frameGrid, frames, frameSize, copySize, controlSize, buffer);
                }
                else
                {
                    var buffer = new Color[copySize.X * copySize.Y];
                    frameIndex = DisassembleFrames(graphicsDevice, texture, frameCount, frameGrid, frames, frameSize, copySize, controlSize, buffer);
                }
            }

            while (frameIndex < frameCount)
                frames[frameIndex++] = SharedMaterialManager.MissingTexture;

            return frames;
        }

        static int DisassembleFrames<T>(GraphicsDevice graphicsDevice, Texture2D texture, int frameCount, Point frameGrid, Texture2D[] frames, Point frameSize, Point copySize, Point controlSize, T[] buffer) where T : struct
        {
            //Trace.TraceInformation("Disassembling {0} {1} frames in {2}x{3}; control {4}x{5}, frame {6}x{7}, copy {8}x{9}.", texture.Format, frameCount, frameGrid.X, frameGrid.Y, controlSize.X, controlSize.Y, frameSize.X, frameSize.Y, copySize.X, copySize.Y);
            var frameIndex = 0;
            for (var y = 0; y < frameGrid.Y; y++)
            {
                for (var x = 0; x < frameGrid.X; x++)
                {
                    if (frameIndex < frameCount)
                    {
                        texture.GetData(0, new Rectangle(x * frameSize.X, y * frameSize.Y, copySize.X, copySize.Y), buffer, 0, buffer.Length);
                        var frame = frames[frameIndex++] = new Texture2D(graphicsDevice, controlSize.X, controlSize.Y, 1, TextureUsage.None, texture.Format);
                        frame.SetData(0, new Rectangle(0, 0, copySize.X, copySize.Y), buffer, 0, buffer.Length, SetDataOptions.None);
                    }
                }
            }
            return frameIndex;
        }
        
        /// <summary>
        /// Disassembles all compound textures into parts
        /// </summary>
        /// <param name="graphicsDevice">The GraphicsDevice</param>
        /// <param name="fileName">Name of the Texture to be disassembled</param>
        /// <param name="width">Width of the Cab View Control</param>
        /// <param name="height">Height of the Cab View Control</param>
        /// <param name="frameCount">Number of frames</param>
        /// <param name="framesX">Number of frames in the X dimension</param>
        /// <param name="framesY">Number of frames in the Y direction</param>
        public static void DisassembleTexture(GraphicsDevice graphicsDevice, string fileName, int width, int height, int frameCount, int framesX, int framesY)
        {
            var controlSize = new Point(width, height);
            var frameGrid = new Point(framesX, framesY);

            PDayTextures[fileName] = null;
            if (DayTextures.ContainsKey(fileName))
            {
                var texture = DayTextures[fileName];
                if (texture != SharedMaterialManager.MissingTexture)
                {
                    PDayTextures[fileName] = Disassemble(graphicsDevice, texture, controlSize, frameCount, frameGrid, fileName + ":day");
                }
            }

            PNightTextures[fileName] = null;
            if (NightTextures.ContainsKey(fileName))
            {
                var texture = NightTextures[fileName];
                if (texture != SharedMaterialManager.MissingTexture)
                {
                    PNightTextures[fileName] = Disassemble(graphicsDevice, texture, controlSize, frameCount, frameGrid, fileName + ":night");
                }
            }

            PLightTextures[fileName] = null;
            if (LightTextures.ContainsKey(fileName))
            {
                var texture = LightTextures[fileName];
                if (texture != SharedMaterialManager.MissingTexture)
                {
                    PLightTextures[fileName] = Disassemble(graphicsDevice, texture, controlSize, frameCount, frameGrid, fileName + ":light");
                }
            }
        }

        /// <summary>
        /// Gets a Texture from the given array
        /// </summary>
        /// <param name="arr">Texture array</param>
        /// <param name="indx">Index</param>
        /// <param name="FileName">Name of the file to report</param>
        /// <returns>The given Texture</returns>
        private static Texture2D SafeGetAt(Texture2D[] arr, int indx, string FileName)
        {
            if (arr == null)
            {
                Trace.TraceWarning("Passed null Texture[] for accessing {0}", FileName);
                return SharedMaterialManager.MissingTexture;
            }
            
            if (arr.Length < 1)
            {
                Trace.TraceWarning("Disassembled texture invalid for {0}", FileName);
                return SharedMaterialManager.MissingTexture;
            }
            
            indx = (int)MathHelper.Clamp(indx, 0, arr.Length - 1);

            try
            {
                return arr[indx];
            }
            catch (IndexOutOfRangeException)
            {
                Trace.TraceWarning("Index {1} out of range for array length {2} while accessing texture for {0}", FileName, indx, arr.Length);
                return SharedMaterialManager.MissingTexture;
            }
        }

        /// <summary>
        /// Returns the compound part of a Texture previously disassembled
        /// </summary>
        /// <param name="FileName">Name of the disassembled Texture</param>
        /// <param name="indx">Index of the part</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <param name="isNightTexture"></param>
        /// <returns>The Texture represented by its index</returns>
        public static Texture2D GetTextureByIndexes(string FileName, int indx, bool isDark, bool isLight, out bool isNightTexture)
        {
            Texture2D retval = SharedMaterialManager.MissingTexture;
            Texture2D[] tmp = null;

            isNightTexture = false;

            if (string.IsNullOrEmpty(FileName) || !PDayTextures.Keys.Contains(FileName))
                return SharedMaterialManager.MissingTexture;

            if (isDark)
            {
                if (isLight)
                {
                    //tmp = PLightTextures[FileName];
                    tmp = PDayTextures[FileName];
                    if (tmp != null)
                    {
                        retval = SafeGetAt(tmp, indx, FileName);
                        isNightTexture = false;
                    }
                }

                if (retval == SharedMaterialManager.MissingTexture)
                {
                    tmp = PNightTextures[FileName];
                    if (tmp != null)
                    {
                        retval = SafeGetAt(tmp, indx, FileName);
                        isNightTexture = true;
                    }
                }
            }

            if (retval == SharedMaterialManager.MissingTexture)
            {
                tmp = PDayTextures[FileName];
                if (tmp != null)
                {
                    retval = SafeGetAt(tmp, indx, FileName);
                    isNightTexture = false;
                }
            }
            return retval;
        }

        /// <summary>
        /// Returns a Texture by its name
        /// </summary>
        /// <param name="FileName">Name of the Texture</param>
        /// <param name="isDark">Is dark out there?</param>
        /// <param name="isLight">Is Cab Light on?</param>
        /// <param name="isNightTexture"></param>
        /// <returns>The Texture</returns>
        public static Texture2D GetTexture(string FileName, bool isDark, bool isLight, out bool isNightTexture)
        {
            Texture2D retval = SharedMaterialManager.MissingTexture;
            isNightTexture = false;

            if (string.IsNullOrEmpty(FileName) || !DayTextures.Keys.Contains(FileName))
                return retval;

            if (isDark)
            {
                if (isLight)
                {
                    //retval = LightTextures[FileName];
                    retval = DayTextures[FileName];
                    isNightTexture = false;
                }

                if (retval == SharedMaterialManager.MissingTexture)
                {
                    retval = NightTextures[FileName];
                    isNightTexture = true;
                }
            }

            if (retval == SharedMaterialManager.MissingTexture)
            {
                retval = DayTextures[FileName];
                isNightTexture = false;
            }

            return retval;
        }

        [CallOnThread("Loader")]
        public static void Mark(Viewer3D viewer)
        {
            foreach (var texture in DayTextures.Values)
                viewer.TextureManager.Mark(texture);
            foreach (var texture in NightTextures.Values)
                viewer.TextureManager.Mark(texture);
            foreach (var texture in LightTextures.Values)
                viewer.TextureManager.Mark(texture);
            foreach (var textureList in PDayTextures.Values)
                if (textureList != null)
                    foreach (var texture in textureList)
                        viewer.TextureManager.Mark(texture);
            foreach (var textureList in PNightTextures.Values)
                if (textureList != null)
                    foreach (var texture in textureList)
                        viewer.TextureManager.Mark(texture);
            foreach (var textureList in PLightTextures.Values)
                if (textureList != null)
                    foreach (var texture in textureList)
                        viewer.TextureManager.Mark(texture);
        }
    }

    public class CabRenderer : RenderPrimitive
    {
        private SpriteBatchMaterial _Sprite2DCabView; 
        private Rectangle _CabRect = new Rectangle();
        private Matrix _Scale = Matrix.Identity;
        private Texture2D _CabTexture;
        private CabShader _Shader;

        private Point _PrevScreenSize;

        //private List<CabViewControls> CabViewControlsList = new List<CabViewControls>();
        private List<List<CabViewControlRenderer>> CabViewControlRenderersList = new List<List<CabViewControlRenderer>>();
        private Viewer3D _Viewer;
        private MSTSLocomotive _Locomotive;
        private int _Location;
        private bool _isNightTexture;

        [CallOnThread("Loader")]
        public CabRenderer(Viewer3D viewer, MSTSLocomotive car)
        {
			//Sequence = RenderPrimitiveSequence.CabView;
            _Sprite2DCabView = (SpriteBatchMaterial)viewer.MaterialManager.Load("SpriteBatch");
            _Viewer = viewer;
            _Locomotive = car;

            // _Viewer.DisplaySize intercepted to adjust cab view height
            Point DisplaySize = _Viewer.DisplaySize;
            DisplaySize.Y = _Viewer.CabHeightPixels;

            // Use same shader for both front-facing and rear-facing cabs.
            if (_Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF != null)
            {
                _Shader = new CabShader( viewer.GraphicsDevice, viewer.RenderProcess.Content,
                    _Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.TranslatedPosition(_Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.Light1Position, DisplaySize),
                    _Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.TranslatedPosition(_Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.Light2Position, DisplaySize),
                    _Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.TranslatedColor(_Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.Light1Color),
                    _Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.TranslatedColor(_Locomotive.CabViewList[(int)CabViewType.Front].ExtendedCVF.Light2Color));
            }
    
            _PrevScreenSize = DisplaySize;

            #region Create Control renderers
            var i = 0;
            foreach (var cabView in car.CabViewList)
            {
                if (cabView.CVFFile != null)
                {
                    // Loading ACE files, skip displaying ERROR messages
                    foreach (var cabfile in cabView.CVFFile.TwoDViews)
                    {
                        CABTextureManager.LoadTextures(viewer, cabfile);
                    }

                    var controlSortIndex = 1;  // Controls are drawn atop the cabview and in order they appear in the CVF file.
                    // This allows the segments of moving-scale meters to be hidden by covers (e.g. TGV-A)
                    CabViewControlRenderersList.Add(new List<CabViewControlRenderer>());
                    foreach (CabViewControl cvc in cabView.CVFFile.CabViewControls)
                    {
                        controlSortIndex++;
                        CVCDial dial = cvc as CVCDial;
                        if (dial != null)
                        {
                            CabViewDialRenderer cvcr = new CabViewDialRenderer(viewer, car, dial, _Shader);
                            cvcr.SortIndex = controlSortIndex;
                            CabViewControlRenderersList[i].Add(cvcr);
                            continue;
                        }
                        CVCGauge gauge = cvc as CVCGauge;
                        if (gauge != null)
                        {
                            CabViewGaugeRenderer cvgr = new CabViewGaugeRenderer(viewer, car, gauge, _Shader);
                            cvgr.SortIndex = controlSortIndex;
                            CabViewControlRenderersList[i].Add(cvgr);
                            continue;
                        }
                        CVCSignal asp = cvc as CVCSignal;
                        if (asp != null)
                        {
                            CabViewDiscreteRenderer aspr = new CabViewDiscreteRenderer(viewer, car, asp, _Shader);
                            aspr.SortIndex = controlSortIndex;
                            CabViewControlRenderersList[i].Add(aspr);
                            continue;
                        }
                        CVCMultiStateDisplay multi = cvc as CVCMultiStateDisplay;
                        if (multi != null)
                        {
                            CabViewDiscreteRenderer mspr = new CabViewDiscreteRenderer(viewer, car, multi, _Shader);
                            mspr.SortIndex = controlSortIndex;
                            CabViewControlRenderersList[i].Add(mspr);
                            continue;
                        }
                        CVCDiscrete disc = cvc as CVCDiscrete;
                        if (disc != null)
                        {
                            CabViewDiscreteRenderer cvdr = new CabViewDiscreteRenderer(viewer, car, disc, _Shader);
                            cvdr.SortIndex = controlSortIndex;
                            CabViewControlRenderersList[i].Add(cvdr);
                            continue;
                        }
                        CVCDigital digital = cvc as CVCDigital;
                        if (digital != null)
                        {
                            CabViewDigitalRenderer cvdr = new CabViewDigitalRenderer(viewer, car, digital, _Shader);
                            cvdr.SortIndex = controlSortIndex;
                            CabViewControlRenderersList[i].Add(cvdr);
                            continue;
                        }
                    }
                }
                i++;
            }
            #endregion
        }

        public void PrepareFrame(RenderFrame frame)
        {
            if (!_Locomotive.ShowCab)
                return;

            bool Dark = _Viewer.MaterialManager.sunDirection.Y <= 0f || _Viewer.Camera.IsUnderground;
            bool CabLight = _Locomotive.CabLightOn;

            CabCamera cbc = _Viewer.Camera as CabCamera;
            if (cbc != null)
            {
                _Location = cbc.SideLocation;
            }
            else
            {
                _Location = 0;
            }

            var i = (_Locomotive.UsingRearCab) ? 1 : 0;
            _CabTexture = CABTextureManager.GetTexture(_Locomotive.CabViewList[i].CVFFile.TwoDViews[_Location], Dark, CabLight, out _isNightTexture);
            if (_CabTexture == SharedMaterialManager.MissingTexture)
                return;

            // Cab view height adjusted to allow for clip or stretch
            _CabRect.Width = _Viewer.DisplaySize.X;
            _CabRect.Height = _Viewer.CabHeightPixels;

            if (_PrevScreenSize != _Viewer.DisplaySize && _Shader != null)
            {
                _PrevScreenSize = _Viewer.DisplaySize;
                _Shader.SetLightPositions(
                    _Locomotive.CabViewList[i].ExtendedCVF.TranslatedPosition(_Locomotive.CabViewList[i].ExtendedCVF.Light1Position, _Viewer.DisplaySize),
                    _Locomotive.CabViewList[i].ExtendedCVF.TranslatedPosition(_Locomotive.CabViewList[i].ExtendedCVF.Light2Position, _Viewer.DisplaySize));
            }

            frame.AddPrimitive(_Sprite2DCabView, this, RenderPrimitiveGroup.Cab, ref _Scale);
            //frame.AddPrimitive(Materials.SpriteBatchMaterial, this, RenderPrimitiveGroup.Cab, ref _Scale);

            if (_Location == 0)
                foreach (var cvcr in CabViewControlRenderersList[i])
                    cvcr.PrepareFrame(frame);
                }
        
        public override void Draw(GraphicsDevice graphicsDevice)
        {
            // Cab view vertical position adjusted to allow for clip or stretch.
            Rectangle stretchedCab;
            if (_Viewer.Simulator.CarVibrating > 0 || _Viewer.Simulator.UseSuperElevation > 0 || _Locomotive.Train.tilted)
            {
                if (_CabTexture != null)
                    stretchedCab = new Rectangle(-50, -40, _CabTexture.Width + 100, _CabTexture.Height + 80);
                else stretchedCab = new Rectangle(_CabRect.Left, _CabRect.Top + _Viewer.CabYOffsetPixels, _CabRect.Width, _CabRect.Height);
            }
            else
                stretchedCab = new Rectangle(_CabRect.Left, _CabRect.Top + _Viewer.CabYOffsetPixels, _CabRect.Width, _CabRect.Height);
            
            if( _Location == 0 && _Shader != null )
            {
                _Shader.SetData(_Viewer.MaterialManager.sunDirection,
                    _isNightTexture, _Locomotive.CabLightOn, _Viewer.World.Sky.overcast);

                _Shader.SetTextureData( stretchedCab.Left, stretchedCab.Top, stretchedCab.Width, stretchedCab.Height );
                _Shader.Begin();
                _Shader.CurrentTechnique.Passes[0].Begin();
            }

            if (_CabTexture != null)
            {
                if (this._Viewer.Simulator.UseSuperElevation > 0 || _Viewer.Simulator.CarVibrating > 0 || _Locomotive.Train.tilted)
                {
                    var scale = new Vector2((float)_CabRect.Width / _CabTexture.Width, (float)_CabRect.Height / _CabTexture.Height);
                    var place = new Vector2(_CabRect.Width / 2 - 50 * scale.X, _CabRect.Height / 2 + _Viewer.CabYOffsetPixels - 40 * scale.Y);
                    var place2 = new Vector2(_CabTexture.Width / 2, _CabTexture.Height / 2);
                    _Sprite2DCabView.SpriteBatch.Draw(_CabTexture, place, stretchedCab, Color.White, _Locomotive.CabRotationZ, place2, scale, SpriteEffects.None, 0f);
                }
                else
                {
                    _Sprite2DCabView.SpriteBatch.Draw(_CabTexture, stretchedCab, Color.White);
                }
            }
                //Materials.SpriteBatchMaterial.SpriteBatch.Draw(_CabTexture, _CabRect, Color.White);

            if (_Location == 0 && _Shader != null)
            {
                _Shader.CurrentTechnique.Passes[0].End();
                _Shader.End();
            }
        }

        internal void Mark()
        {
            _Viewer.TextureManager.Mark(_CabTexture);

            var i = (_Locomotive.UsingRearCab) ? 1 : 0;
            foreach (var cvcr in CabViewControlRenderersList[i])
                cvcr.Mark();
        }
    }

    /// <summary>
    /// Base class for rendering Cab Controls
    /// </summary>
    public abstract class CabViewControlRenderer : RenderPrimitive
    {
        protected readonly Viewer3D Viewer;
        protected readonly MSTSLocomotive Locomotive;
        protected readonly CabViewControl Control;
        protected readonly CabShader Shader;
        protected readonly SpriteBatchMaterial ControlView;

        protected Vector2 Position;
        protected Texture2D Texture;
        protected bool IsNightTexture;

        Matrix Matrix = Matrix.Identity;

        public CabViewControlRenderer(Viewer3D viewer, MSTSLocomotive locomotive, CabViewControl control, CabShader shader)
        {
            Viewer = viewer;
            Locomotive = locomotive;
            Control = control;
            Shader = shader;

            ControlView = (SpriteBatchMaterial)viewer.MaterialManager.Load("SpriteBatch");

            CABTextureManager.LoadTextures(Viewer, Control.ACEFile);
        }

        /// <summary>
        /// Gets the requested Locomotive data and returns it as a fraction (from 0 to 1) of the range between Min and Max values.
        /// </summary>
        /// <returns>Data value as fraction (from 0 to 1) of the range between Min and Max values</returns>
        protected float GetRangeFraction()
        {
            var data = Locomotive.GetDataOf(Control);
            if (data < Control.MinValue)
                return 0;
            if (data > Control.MaxValue)
                return 1;

            if (Control.MaxValue == Control.MinValue)
                return 0;

            return (float)((data - Control.MinValue) / (Control.MaxValue - Control.MinValue));
        }

        protected float GetRangeFractionLoadMeter()
        {
            var minValuePos = 0;
            var data = Locomotive.GetDataOf(Control);
            if (data >= 0)
            {
                if (data < minValuePos)
                    return 0;
                if (data > Control.MaxValue)
                    return 1;

                return (float)((data - minValuePos) / (Control.MaxValue - minValuePos));
            }
            else    // Dynamic Break
            {
                if (data > minValuePos)
                    return 0;
                if (data < Control.MinValue)
                    return -1;

                return -(float)((Math.Abs(data) - minValuePos) / (Math.Abs(Control.MinValue) - minValuePos));
            }
        }

        [CallOnThread("Updater")]
        public virtual void PrepareFrame(RenderFrame frame)
        {
            frame.AddPrimitive(ControlView, this, RenderPrimitiveGroup.Cab, ref Matrix);
        }

        internal void Mark()
        {
            Viewer.TextureManager.Mark(Texture);
        }
    }

    /// <summary>
    /// Dial Cab Control Renderer
    /// Problems with aspect ratio
    /// </summary>
    public class CabViewDialRenderer : CabViewControlRenderer
    {
        readonly CVCDial ControlDial;
        readonly Vector2 Origin;
        readonly float Scale = 1;

        float Rotation = 0;   // 0' is 12 o'clock, 90' is 3 0'clock
        float ScaleToScreen = 1;

        public CabViewDialRenderer(Viewer3D viewer, MSTSLocomotive locomotive, CVCDial control, CabShader shader)
            : base(viewer, locomotive, control, shader)
        {
            ControlDial = control;
            Origin = new Vector2((float)ControlDial.Width / 2, ControlDial.Center);

            Texture = CABTextureManager.GetTexture(Control.ACEFile, false, false, out IsNightTexture);
            Scale = (float)(ControlDial.Height / Texture.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            var dark = Viewer.MaterialManager.sunDirection.Y <= 0f || Viewer.Camera.IsUnderground;

            Texture = CABTextureManager.GetTexture(Control.ACEFile, dark, Locomotive.CabLightOn, out IsNightTexture);
            if (Texture == SharedMaterialManager.MissingTexture)
                return;

            base.PrepareFrame(frame);

            // Cab view height and vertical position adjusted to allow for clip or stretch.
            Position.X = (float)Viewer.DisplaySize.X / 640 * ((float)Control.PositionX + Origin.X);
            Position.Y = (float)Viewer.CabHeightPixels / 480 * ((float)Control.PositionY + Origin.Y) + Viewer.CabYOffsetPixels;
            ScaleToScreen = (float)Viewer.DisplaySize.X / 640 * Scale;

            var rangeFraction = GetRangeFraction();
            var direction = ControlDial.Direction == 0 ? 1 : -1;
            var rangeDegrees = direction * (ControlDial.ToDegree - ControlDial.FromDegree);
            while (rangeDegrees < 0)
                rangeDegrees += 360;
            Rotation = MathHelper.WrapAngle(MathHelper.ToRadians(ControlDial.FromDegree + direction * rangeDegrees * rangeFraction));
            if (Viewer.Simulator.UseSuperElevation > 0 || Viewer.Simulator.CarVibrating > 0 || Locomotive.Train.tilted)
            {
                Position.X -= Viewer.DisplaySize.X / 2; Position.Y -= (Viewer.CabHeightPixels / 2 + Viewer.CabYOffsetPixels);
                Position = Vector2.Transform(Position, Matrix.CreateRotationZ(Locomotive.CabRotationZ));
                Position.X += Viewer.DisplaySize.X / 2; Position.Y += (Viewer.CabHeightPixels / 2 + Viewer.CabYOffsetPixels);
            }
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (Shader != null)
            {
                Shader.SetTextureData(Position.X, Position.Y, Texture.Width * ScaleToScreen, Texture.Height * ScaleToScreen);
                Shader.Begin();
                Shader.CurrentTechnique.Passes[0].Begin();
            }
            if (Viewer.Simulator.UseSuperElevation > 0 || Viewer.Simulator.CarVibrating > 0 || Locomotive.Train.tilted)
                ControlView.SpriteBatch.Draw(Texture, Position, null, Color.White, Rotation + Locomotive.CabRotationZ, Origin, ScaleToScreen, SpriteEffects.None, 0);
            else
                ControlView.SpriteBatch.Draw(Texture, Position, null, Color.White, Rotation, Origin, ScaleToScreen, SpriteEffects.None, 0);
            if (Shader != null)
            {
                Shader.CurrentTechnique.Passes[0].End();
                Shader.End();
            }
        }
    }

    /// <summary>
    /// Gauge type renderer
    /// Supports pointer, liquid, solid
    /// Supports Orientation and Direction
    /// </summary>
    public class CabViewGaugeRenderer : CabViewControlRenderer
    {
        readonly CVCGauge Gauge;
        readonly Rectangle SourceRectangle;

        Rectangle DestinationRectangle = new Rectangle();
        bool LoadMeterPositive = true;
        Color DrawColor;

        public CabViewGaugeRenderer(Viewer3D viewer, MSTSLocomotive locomotive, CVCGauge control, CabShader shader)
            : base(viewer, locomotive, control, shader)
        {
            Gauge = control;
            //SourceRectangle = Gauge.Area;
            if ((Control.ControlType == CABViewControlTypes.REVERSER_PLATE) || (Gauge.ControlStyle == CABViewControlStyles.POINTER))
            {
                DrawColor = Color.White;
                Texture = CABTextureManager.GetTexture(Control.ACEFile, false, Locomotive.CabLightOn, out IsNightTexture);
                SourceRectangle.Width = (int)Texture.Width;
                SourceRectangle.Height = (int)Texture.Height;
            }
            else
            {
                DrawColor = new Color(Gauge.PositiveColor.R, Gauge.PositiveColor.G, Gauge.PositiveColor.B);
                SourceRectangle = Gauge.Area;
            }
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            var dark = Viewer.MaterialManager.sunDirection.Y <= 0f || Viewer.Camera.IsUnderground;

            Texture = CABTextureManager.GetTexture(Control.ACEFile, dark, Locomotive.CabLightOn, out IsNightTexture);
            if (Texture == SharedMaterialManager.MissingTexture)
                return;

            base.PrepareFrame(frame);

            // Cab view height adjusted to allow for clip or stretch.
            var xratio = (float)Viewer.DisplaySize.X / 640;
            var yratio = (float)Viewer.CabHeightPixels / 480;

            float percent, xpos, ypos;
            if (Control.MinValue < 0)
            {
                percent = GetRangeFractionLoadMeter();
                LoadMeterPositive = percent >= 0;
                Gauge.Direction = LoadMeterPositive ? 0 : 1;
                percent = Math.Abs(percent);
            }
            else
            {
                percent = GetRangeFraction();
            }

            if (Gauge.Orientation == 0)  // gauge horizontal
            {
                ypos = (float)Gauge.Height;
                var adjustGaugeWidth = (float)Gauge.Width * (float)Control.MaxValue / (float)(Control.MaxValue - Control.MinValue);
                if (Gauge.Direction == 0)  // bar grows from left
                {
                    if ((Control.MinValue < 0) && LoadMeterPositive)
                        xpos = adjustGaugeWidth * percent;
                    else
                        xpos = (float)Gauge.Width * percent;
                }
                else  // bar grows from right
                {
                    if ((Control.MinValue < 0) && !LoadMeterPositive)
                        xpos = (adjustGaugeWidth - 1) * percent;
                    else
                        xpos = (float)Gauge.Width * percent;
                }
            }
            else  // gauge vertical
            {
                xpos = (float)Gauge.Width;
                var adjustGaugeHeight = (float)Gauge.Height * (float)Control.MaxValue / (float)(Control.MaxValue - Control.MinValue);
                if (Gauge.Direction == 0)  // bar grows from top
                {
                    if ((Control.MinValue < 0) && LoadMeterPositive)
                        ypos = adjustGaugeHeight * percent;
                    else
                        ypos = (float)Gauge.Height * percent;
                }
                else  // bar grows from bottom
                {
                    if ((Control.MinValue < 0) && !LoadMeterPositive)
                        ypos = (adjustGaugeHeight - 1) * percent;
                    else
                        ypos = (float)Gauge.Height * percent;
                }
            }

            if (Gauge.ControlStyle == CABViewControlStyles.SOLID || Gauge.ControlStyle == CABViewControlStyles.LIQUID)
            {
                if (Control.MinValue < 0)
                {
                    if (LoadMeterPositive)  // left hand start position
                    {
                        // gauge width - area  offset to center
                        DestinationRectangle.X = (int)(xratio * (Control.PositionX + (float)Gauge.Width * (float)Control.MinValue / (float)(Control.MinValue - Control.MaxValue)));
                    }
                    else
                    {
                        var centDrec = (int)(xratio * (Control.PositionX + (float)Gauge.Width * (float)Control.MinValue / (float)(Control.MinValue - Control.MaxValue)));
                        DestinationRectangle.X = centDrec - (int)(xratio * xpos);
                    }
                    // Cab view vertical position adjusted to allow for clip or stretch.
                    DestinationRectangle.Y = (int)(yratio * Control.PositionY) + Viewer.CabYOffsetPixels;
                    DestinationRectangle.Width = (int)(xratio * xpos);
                    DestinationRectangle.Height = (int)(yratio * ypos);
                }
                else
                {
                    DestinationRectangle.X = (int)(xratio * Control.PositionX);
                    var topY = Control.PositionY;  // top of visible column. +ve Y is downwards
                    if (Gauge.Direction != 0)  // column grows from bottom or from right
                    {
                        DestinationRectangle.X = (int)(xratio * (Control.PositionX + Gauge.Width - xpos));
                        topY += Gauge.Height * (1 - percent);
                    }
                    // Cab view vertical position adjusted to allow for clip or stretch.
                    DestinationRectangle.Y = (int)(yratio * topY) + Viewer.CabYOffsetPixels;
                    DestinationRectangle.Width = (int)(xratio * xpos);
                    DestinationRectangle.Height = (int)(yratio * ypos);
                }
            }
            else // pointer gauge using texture
            {
                var topY = Control.PositionY;  // top of visible column. +ve Y is downwards
                if (Gauge.Orientation == 0) // gauge horizontal
                {
                    DestinationRectangle.X = (int)(xratio * (Control.PositionX - 0.5 * Gauge.Area.Width + xpos));
                    if (Gauge.Direction != 0)  // column grows from right
                        DestinationRectangle.X = (int)(xratio * (Control.PositionX + Gauge.Width - 0.5 * Gauge.Area.Width - xpos));
                }
                else // gauge vertical
                {
                    topY += ypos - 0.5 * Gauge.Area.Height;
                    DestinationRectangle.X = (int)(xratio * Control.PositionX);
                    if (Gauge.Direction != 0)  // column grows from bottom
                        topY += Gauge.Height - 2 * ypos;
                }
                // Cab view vertical position adjusted to allow for clip or stretch.
                DestinationRectangle.Y = (int)(yratio * topY) + Viewer.CabYOffsetPixels;
                DestinationRectangle.Width = (int)(xratio * Gauge.Area.Width);
                DestinationRectangle.Height = (int)(yratio * Gauge.Area.Height);
            }
            if (Viewer.Simulator.UseSuperElevation > 0 || Viewer.Simulator.CarVibrating > 0 || Locomotive.Train.tilted)
            {
                var Position = new Vector2(DestinationRectangle.X-Viewer.DisplaySize.X / 2, DestinationRectangle.Y - Viewer.CabYOffsetPixels-Viewer.CabHeightPixels / 2);
                Position = Vector2.Transform(Position, Matrix.CreateRotationZ(Locomotive.CabRotationZ));
                Position.X += Viewer.DisplaySize.X / 2; Position.Y += (Viewer.CabHeightPixels / 2 + Viewer.CabYOffsetPixels);
                DestinationRectangle.X = (int)(Position.X + 0.5f); DestinationRectangle.Y = (int)(Position.Y + 0.5f);
            }
            if (Control.MinValue < 0)
                DrawColor = LoadMeterPositive ? new Color(Gauge.PositiveColor.R, Gauge.PositiveColor.G, Gauge.PositiveColor.B) : new Color(Gauge.NegativeColor.R, Gauge.NegativeColor.G, Gauge.NegativeColor.B);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (Shader != null)
            {
                Shader.SetTextureData(DestinationRectangle.Left, DestinationRectangle.Top, DestinationRectangle.Width, DestinationRectangle.Height);
                Shader.Begin();
                Shader.CurrentTechnique.Passes[0].Begin();
            }
            if (Viewer.Simulator.UseSuperElevation > 0 || Viewer.Simulator.CarVibrating > 0 || Locomotive.Train.tilted)
            {
                ControlView.SpriteBatch.Draw(Texture, DestinationRectangle, SourceRectangle, DrawColor, Locomotive.CabRotationZ, Vector2.Zero, SpriteEffects.None, 0f);
            }
            else
                ControlView.SpriteBatch.Draw(Texture, DestinationRectangle, SourceRectangle, DrawColor);
            if (Shader != null)
            {
                Shader.CurrentTechnique.Passes[0].End();
                Shader.End();
            }
        }
    }

    /// <summary>
    /// Discrete renderer for Lever, Twostate, Tristate, Multistate, Signal
    /// </summary>
    public class CabViewDiscreteRenderer : CabViewControlRenderer
    {
        readonly CVCWithFrames ControlDiscrete;
        readonly Rectangle SourceRectangle;
        Vector2 DrawPosition = new Vector2();
        Rectangle DestinationRectangle = new Rectangle();

        public CabViewDiscreteRenderer(Viewer3D viewer, MSTSLocomotive locomotive, CVCWithFrames control, CabShader shader)
            : base(viewer, locomotive, control, shader)
        {
            ControlDiscrete = control;
            CABTextureManager.DisassembleTexture(viewer.GraphicsDevice, Control.ACEFile, (int)Control.Width, (int)Control.Height, ControlDiscrete.FramesCount, ControlDiscrete.FramesX, ControlDiscrete.FramesY);
            SourceRectangle = new Rectangle(0, 0, (int)ControlDiscrete.Width, (int)ControlDiscrete.Height);
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            var dark = Viewer.MaterialManager.sunDirection.Y <= 0f || Viewer.Camera.IsUnderground;

            Texture = CABTextureManager.GetTextureByIndexes(Control.ACEFile, GetDrawIndex(), dark, Locomotive.CabLightOn, out IsNightTexture);
            if (Texture == SharedMaterialManager.MissingTexture)
                return;

            base.PrepareFrame(frame);

            // Cab view height and vertical position adjusted to allow for clip or stretch.
            var xratio = (float)Viewer.DisplaySize.X / 640;
            var yratio = (float)Viewer.CabHeightPixels / 480;

            if (Viewer.Simulator.UseSuperElevation > 0 || Viewer.Simulator.CarVibrating > 0 || Locomotive.Train.tilted)
            {
                DestinationRectangle.X = (int)(xratio * Control.PositionX * 1.0001);
                DestinationRectangle.Y = (int)(yratio * Control.PositionY * 1.0001) + Viewer.CabYOffsetPixels;
                DestinationRectangle.Width = (int)(xratio * Control.Width);
                DestinationRectangle.Height = (int)(yratio * Control.Height);
                var Position = new Vector2(DestinationRectangle.X - Viewer.DisplaySize.X / 2, DestinationRectangle.Y - Viewer.CabHeightPixels / 2 - Viewer.CabYOffsetPixels);

                Position = Vector2.Transform(Position, Matrix.CreateRotationZ(Locomotive.CabRotationZ));
                Position.X += Viewer.DisplaySize.X / 2 + 0.5f; Position.Y += Viewer.CabHeightPixels / 2 + Viewer.CabYOffsetPixels + 0.5f;
                DestinationRectangle.X = (int)Position.X; DestinationRectangle.Y = (int)Position.Y;
                DrawPosition.X = Position.X; DrawPosition.Y = Position.Y;
            }
            else
            {
                DestinationRectangle.X = (int)(xratio * Control.PositionX * 1.0001);
                DestinationRectangle.Y = (int)(yratio * Control.PositionY * 1.0001) + Viewer.CabYOffsetPixels;
                DestinationRectangle.Width = (int)(xratio * Control.Width);
                DestinationRectangle.Height = (int)(yratio * Control.Height);
            }
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (Shader != null)
            {
                Shader.SetTextureData(DestinationRectangle.Left, DestinationRectangle.Top, DestinationRectangle.Width, DestinationRectangle.Height);
                Shader.Begin();
                Shader.CurrentTechnique.Passes[0].Begin();
            }
            if (Viewer.Simulator.UseSuperElevation > 0 || Viewer.Simulator.CarVibrating > 0 || Locomotive.Train.tilted)
                ControlView.SpriteBatch.Draw(Texture, DrawPosition, SourceRectangle, Color.White, Locomotive.CabRotationZ, Vector2.Zero, new Vector2((float)Viewer.DisplaySize.X / 640,
                    (float)Viewer.CabHeightPixels / 480), SpriteEffects.None, 0f);
            else
                ControlView.SpriteBatch.Draw(Texture, DestinationRectangle, SourceRectangle, Color.White);
            if (Shader != null)
            {
                Shader.CurrentTechnique.Passes[0].End();
                Shader.End();
            }
        }

        /// <summary>
        /// Determines the index of the Texture to be drawn
        /// </summary>
        /// <returns>index of the Texture</returns>
        int GetDrawIndex()
        {
            var data = Locomotive.GetDataOf(Control);
            var currentDynamicNotch = Locomotive.DynamicBrakeController != null ? Locomotive.DynamicBrakeController.CurrentNotch : 0;
            var dynamicNotchCount = Locomotive.DynamicBrakeController != null ? Locomotive.DynamicBrakeController.NotchCount() : 0;
            var dynamicBrakePercent = Locomotive.Train.MUDynamicBrakePercent;

            var index = 0;
            switch (ControlDiscrete.ControlType)
            {
                case CABViewControlTypes.ENGINE_BRAKE:
                case CABViewControlTypes.TRAIN_BRAKE:
                    index = PercentToIndex(data);
                    break;
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                    if (Locomotive.ThrottleController.SmoothMax() == null)
                        index = Locomotive.ThrottleController.CurrentNotch;
                    else
                        index = PercentToIndex(data);
                    break;
                case CABViewControlTypes.FRICTION_BRAKING:
                    index = data > 0 ? 1 : 0;
                    break;
                case CABViewControlTypes.DYNAMIC_BRAKE:
                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    if (Locomotive.DynamicBrakeController != null)
                    {
                        if (dynamicBrakePercent == -1)
                            break;
                        if (!Locomotive.HasSmoothStruc)
                            index = currentDynamicNotch;
                        else
                            index = PercentToIndex(dynamicBrakePercent);
                    }
                    else
                    {
                        index = PercentToIndex(dynamicBrakePercent);
                    }
                    break;
                case CABViewControlTypes.CPH_DISPLAY:
                case CABViewControlTypes.CP_HANDLE:
                    var currentThrottleNotch = Locomotive.ThrottleController.CurrentNotch;
                    var throttleNotchCount = Locomotive.ThrottleController.NotchCount();
                    if (dynamicBrakePercent < 0)
                    {
                        if (currentThrottleNotch == 0)
                            index = throttleNotchCount - 1;
                        else
                            index = (throttleNotchCount - 1) - currentThrottleNotch;
                    }
                    else // dynamic break enabled
                    {
                        if (!Locomotive.HasSmoothStruc)
                        {
                            index = (dynamicNotchCount - 1) + currentDynamicNotch;
                        }
                        else
                        {
                            // This section for dispaly is based on 3DTS smooth controls
                            // The # of discreet positons for the display is based on how
                            // MSTS displayed them, so a dummy emulation is supplied here.
                            index = DummyDynamicToIndex(dynamicBrakePercent) + 9;
                        }
                    } // End Dynamic != null
                    break;
                case CABViewControlTypes.ALERTER_DISPLAY:
                case CABViewControlTypes.RESET:
                case CABViewControlTypes.WIPERS:
                case CABViewControlTypes.HORN:
                case CABViewControlTypes.BELL:
                case CABViewControlTypes.SANDERS:
                case CABViewControlTypes.SANDING:
                case CABViewControlTypes.WHEELSLIP:
                case CABViewControlTypes.FRONT_HLIGHT:
                case CABViewControlTypes.PANTOGRAPH:
                case CABViewControlTypes.PANTO_DISPLAY:
                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                case CABViewControlTypes.ASPECT_DISPLAY:
                    index = (int)data;
                    break;
            }

            if (index >= ControlDiscrete.FramesCount) index = ControlDiscrete.FramesCount - 1;
            if (index < 0) index = 0;
            return index;
        }

        /// <summary>
        /// Translates a percent value to a display index
        /// </summary>
        /// <param name="percent">Percent to be translated</param>
        /// <returns>The calculated display index by the Control's Values</returns>
        int PercentToIndex(float percent)
        {
            var index = 0;

            if (percent > 1)
                percent /= 100f;

            percent = MathHelper.Clamp(percent, (float)ControlDiscrete.MinValue, (float)ControlDiscrete.MaxValue);

            if (ControlDiscrete.Values.Count > 1)
            {
                var val = ControlDiscrete.Values.Where(v => v <= percent).Last();
                index = ControlDiscrete.Values.IndexOf(val);
            }
            else if (ControlDiscrete.MaxValue != ControlDiscrete.MinValue)
            {
                index = (int)(percent / (ControlDiscrete.MaxValue - ControlDiscrete.MinValue) * ControlDiscrete.FramesCount);
            }

            return index;
        }

        static readonly float[] IndexToPercent = new float[]
        {
            0.0f,
            .1111f,
            .2222f,
            .3333f,
            .4444f,
            .5555f,
            .6666f,
            .7777f,
            .8888f,
            1.0f
        };

        int DummyDynamicToIndex(float percent)
        {
            var index = 0;

            if (percent > 1)
                percent /= 100f;

            for (var i = 0; i < 10; i++)
            {
                var value = IndexToPercent[i];
                if (percent >= value)
                {
                    index = i;
                    continue;
                }
                if (percent <= value)
                    break;
            }

            return index;
        }
    }

    /// <summary>
    /// Digital Cab Control renderer
    /// Uses fonts instead of graphic
    /// </summary>
    public class CabViewDigitalRenderer : CabViewControlRenderer
    {
        const float FontScale = 10f / 480;
        readonly LabelAlignment Alignment;
        string Format = "{0}";
        readonly string Format1 = "{0}";
        readonly string Format2 = "{0}";

        float Num;
        WindowTextFont DrawFont;
        Rectangle DrawPosition;
        string DrawText;
        Color DrawColor;

        [CallOnThread("Loader")]
        public CabViewDigitalRenderer(Viewer3D viewer, MSTSLocomotive car, CVCDigital digital, CabShader shader)
            : base(viewer, car, digital, shader)
        {
            Position.X = (float)Control.PositionX;
            Position.Y = (float)Control.PositionY;

            // Clock defaults to centered.
            if (Control.ControlType == CABViewControlTypes.CLOCK)
                Alignment = LabelAlignment.Center;
            Alignment = digital.Justification == 1 ? LabelAlignment.Center : digital.Justification == 2 ? LabelAlignment.Left : digital.Justification == 3 ? LabelAlignment.Right : Alignment;

            Format1 = "{0:0" + new String('0', digital.LeadingZeros) + (digital.Accuracy > 0 ? "." + new String('0', (int)digital.Accuracy) : "") + "}";
            Format2 = "{0:0" + new String('0', digital.LeadingZeros) + (digital.AccuracySwitch > 0 ? "." + new String('0', (int)(digital.Accuracy + 1)) : "") + "}";
        }

        public override void PrepareFrame(RenderFrame frame)
        {
            var digital = Control as CVCDigital;

            Num = Locomotive.GetDataOf(Control);
            if (Math.Abs(Num) < digital.AccuracySwitch)
                Format = Format2;
            else
                Format = Format1;
            DrawFont = Viewer.WindowManager.TextManager.Get("Courier New", Viewer.CabHeightPixels * FontScale, System.Drawing.FontStyle.Regular);
            DrawPosition.X = (int)(Position.X * Viewer.DisplaySize.X / 640);
            DrawPosition.Y = (int)((Position.Y + Control.Height / 2) * Viewer.CabHeightPixels / 480) - DrawFont.Height / 2 + Viewer.CabYOffsetPixels;
            DrawPosition.Width = (int)(Control.Width * Viewer.DisplaySize.X / 640);
            DrawPosition.Height = (int)(Control.Height * Viewer.DisplaySize.Y / 480);

            if (Viewer.Simulator.CarVibrating > 0 || Viewer.Simulator.UseSuperElevation > 0 || Locomotive.Train.tilted)
            {
                var position = new Vector2(DrawPosition.X - Viewer.DisplaySize.X / 2, DrawPosition.Y - Viewer.CabHeightPixels / 2 - Viewer.CabYOffsetPixels);
                position = Vector2.Transform(position, Matrix.CreateRotationZ(Locomotive.CabRotationZ));
                DrawPosition.X = (int)Math.Round(position.X + Viewer.DisplaySize.X / 2);
                DrawPosition.Y = (int)Math.Round(position.Y + Viewer.CabHeightPixels / 2 + Viewer.CabYOffsetPixels);
            }

            if (Control.ControlType == CABViewControlTypes.CLOCK)
            {
                // Clock is drawn specially.
                var clockSeconds = Locomotive.Simulator.ClockTime;
                var hour = (int)(clockSeconds / 3600) % 24;
                var minute = (int)(clockSeconds / 60) % 60;
                var seconds = (int)clockSeconds % 60;

                if (hour < 0)
                    hour += 24;
                if (minute < 0)
                    minute += 60;
                if (seconds < 0)
                    seconds += 60;

                if (digital.ControlStyle == CABViewControlStyles._12HOUR)
                {
                    hour %= 12;
                    if (hour == 0)
                        hour = 12;
                }
                DrawText = String.Format(digital.Accuracy > 0 ? "{0:D2}:{1:D2}:{2:D2}" : "{0:D2}:{1:D2}", hour, minute, seconds);
                DrawColor = new Color(digital.PositiveColor.R, digital.PositiveColor.G, digital.PositiveColor.B);
            }
            else if (digital.OldValue != 0 && digital.OldValue > Num && digital.DecreaseColor.A != 0)
            {
                DrawText = String.Format(Format, Math.Abs(Num));
                DrawColor = new Color(digital.DecreaseColor.R, digital.DecreaseColor.G, digital.DecreaseColor.B, digital.DecreaseColor.A);
            }
            else if (Num < 0 && digital.NegativeColor.A != 0)
            {
                DrawText = String.Format(Format, Math.Abs(Num));
                DrawColor = new Color(digital.NegativeColor.R, digital.NegativeColor.G, digital.NegativeColor.B, digital.NegativeColor.A);
            }
            else if (digital.PositiveColor.A != 0)
            {
                DrawText = String.Format(Format, Num);
                DrawColor = new Color(digital.PositiveColor.R, digital.PositiveColor.G, digital.PositiveColor.B, digital.PositiveColor.A);
            }
            else
            {
                DrawText = String.Format(Format, Num);
                DrawColor = Color.White;
            }

            if (Control.ControlType == CABViewControlTypes.SPEEDOMETER)
            {
                // Speedometer is colored specially.
                DrawColor = new Color(digital.PositiveColor.R, digital.PositiveColor.G, digital.PositiveColor.B);
                if (Locomotive.Train != null && Locomotive.GetDataOf(Control) > MpS.FromMpS(Locomotive.Train.AllowedMaxSpeedMpS, Control.Units == CABViewControlUnits.KM_PER_HOUR))
                    DrawColor = Color.Yellow;
            }

            base.PrepareFrame(frame);
        }

        public override void Draw(GraphicsDevice graphicsDevice)
        {
            if (Viewer.Simulator.CarVibrating > 0 || Viewer.Simulator.UseSuperElevation > 0 || Locomotive.Train.tilted)
                DrawFont.Draw(ControlView.SpriteBatch, DrawPosition, Point.Zero, DrawText, Alignment, DrawColor, Locomotive.CabRotationZ);
            else
                DrawFont.Draw(ControlView.SpriteBatch, DrawPosition, Point.Zero, DrawText, Alignment, DrawColor);
        }
    }
}
