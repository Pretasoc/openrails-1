// COPYRIGHT 2009, 2010, 2011 by the Open Rails project.
// This code is provided to help you understand what Open Rails does and does
// not do. Suggestions and contributions to improve Open Rails are always
// welcome. Use of the code for any other purpose or distribution of the code
// to anyone else is prohibited without specific written permission from
// admin@openrails.org.
//
// This file is the responsibility of the 3D & Environment Team. 

/// ORTS SOUND SYSTEM
/// 
/// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
/// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
/// SoundSource objects
///  - have a physical location in the world, 
///  - assume the listener is located at the same location as the 3D viewer
///  - may be attached to a railcar in which case it moves with the car
///  - railcar-attached sounds can poll control variables in the simulator
///  - have one or more SoundStreams
///  SoundStreams
///  - can play only one sound at a time
///  - the sound played is controlled by the various triggers
///  SoundTriggers
///  - defined in the SMS file
///  - triggered by various events
///  - when triggered, executes a SoundCommand
///  SoundCommands
///  - used by triggers to control the SoundStream
///  - ie play a sound, stop a sound etc
#define PLAYSOUNDS
#define PLAYENVSOUNDS
//#define DEBUGSCR
#define STEREOCAB
#define DOPPLER
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.Xna.Framework;


namespace ORTS
{

/////////////////////////////////////////////////////////
/// SOUND SOURCE
/////////////////////////////////////////////////////////

    
    public class SoundSource 
    {
        private const int CUTOFFDISTANCE = 40000;
        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer3D viewer, MSTSWagon car, string smsFilePath)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific loaction - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer3D viewer, string smsFilePath)
        {
            Initialize(viewer, null, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer3D viewer, WorldLocation worldLocation, string smsFilePath)
        {
            IsEnvSound = true;
            Initialize(viewer, worldLocation, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="isSlowRolloff"></param>
        public SoundSource(Viewer3D viewer, WorldLocation worldLocation, string smsFilePath, bool isSlowRolloff)
        {
            IsEnvSound = true;
            _isSlowRolloff = isSlowRolloff;
            Initialize(viewer, worldLocation, smsFilePath);
        }

        /// <summary>
        /// No need to play the sounds, stop them
        /// </summary>
        public void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
                ss.Stop();
        }
        
        public WorldLocation WorldLocation;   // current location for the sound source
        public Viewer3D Viewer;                 // the listener is connected to this viewer
        public MSTSWagon Car = null;          // the sound may be from a train car

        public string SMSFolder;              // the wave files will be relative to this folder
        public string SMSFileName;
        public bool Active = true;
        private MSTS.Activation ActivationConditions;
        private MSTS.Deactivation DeactivationConditions;
        public bool IsEnvSound = false;
        public bool IsExternal = true;

        private float _distanceSquared;
        private bool _wasOutOfDistance = true;
        private bool _isSlowRolloff = false;

        List<SoundStream> SoundStreams = new List<SoundStream>();

        public void Initialize(Viewer3D viewer, WorldLocation worldLocation, string smsFilePath)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;
            SMSFolder = Path.GetDirectoryName(smsFilePath);
            SMSFileName = Path.GetFileName(smsFilePath);
            MSTS.SMSFile smsFile = MSTS.SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int iSG = 0;
            while ( iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count)
                {
            
                if (smsFile.Tr_SMS.ScalabiltyGroups[iSG].DetailLevel <= Viewer.Settings.SoundDetailLevel)
                {
                    break;
                }

                ++iSG;
            }
            if (iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count && smsFile.Tr_SMS.ScalabiltyGroups[iSG].Streams != null)  // else we want less sound so don't provide any
            {
                MSTS.ScalabiltyGroup mstsScalabiltyGroup = smsFile.Tr_SMS.ScalabiltyGroups[iSG];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;

                if (ActivationConditions.ExternalCam)
                    IsExternal = true;
                else
                    IsExternal = false;
                
                int cou = 1;
                foreach (MSTS.SMSStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams.Add(new SoundStream(mstsStream, this, cou++, _isSlowRolloff, ActivationConditions.Distance));
                }
            }
        }

        public void HandleEvent(EventID eventID)
        {
            foreach (SoundStream ss in SoundStreams)
            {
                foreach (ORTSTrigger trg in ss.Triggers)
                {
                    ORTSDiscreteTrigger dt = trg as ORTSDiscreteTrigger;
                    if (dt != null)
                        dt.HandleCarEvent(eventID);
                }
            }
        }

        public bool IsCABSound
        {
            get
            {
                return ActivationConditions.CabCam && !ActivationConditions.ExternalCam;
            }
        }

        public bool IsPassengerSound
        {
            get
            {
                return ActivationConditions.PassengerCam && !ActivationConditions.ExternalCam;
            }
        }

        public void InitInitials()
        {
            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            if (isOutOfDistance())
            {

                if (!_wasOutOfDistance)
                {
                    _wasOutOfDistance = true;
                    foreach (SoundStream stream in SoundStreams)
                        stream.HardDeactivate();
                }
            }
            else
            {
                if (_wasOutOfDistance)
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.HardActivate();
                }
            }

            _wasOutOfDistance = false;

            // run the initial triggers
            foreach (SoundStream stream in SoundStreams)
                foreach (ORTSTrigger trigger in stream.Triggers)
                    trigger.Initialize();
        }
        
        public void Update()
        {
            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            if (isOutOfDistance())
            {

                if (!_wasOutOfDistance)
                {
                    _wasOutOfDistance = true;
                    foreach (SoundStream stream in SoundStreams)
                        stream.HardDeactivate();
                }

                return;
            }
            else
            {
                if (_wasOutOfDistance)
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.HardActivate();
                }
            }

            _wasOutOfDistance = false;

            if (!Active)
            {
                if (Activate())
                {
                    Active = true;

                    // restore any looping sounds
                    foreach(SoundStream stream in SoundStreams)
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            // Must start and stop by triggers - by GeorgeS
            //if (Active)
            if (WorldLocation != null)
            {
                // update the sound position relative to the listener
                Vector3 RelativePosition = WorldLocation.Location;
                RelativePosition.X += 2048 * (WorldLocation.TileX - Viewer.Camera.TileX);
                RelativePosition.Z += 2048 * (WorldLocation.TileZ - Viewer.Camera.TileZ);

                Vector3 XNARelativePosition = new Vector3(RelativePosition.X, RelativePosition.Y, -RelativePosition.Z);
                XNARelativePosition = Vector3.Transform(XNARelativePosition, Viewer.Camera.XNAView);
                
                float spx = 0;
                float spy = 0;
                float spz = 0;

#if DOPPLER
                do
                {
                    // Stationary or otherwise invalid Car
                    if (Car == null || Car.Train == null)
                        break;

                    // For sure we have a Camera
                    if (Viewer == null || Viewer.Camera == null)
                        break;

                    // Check for the Train or Car equality
                    if (Viewer.Camera.AttachedCar != null && Viewer.Camera.AttachedCar.Train != null)
                    {
                        // If the same train, no doppler
                        if (Car.Train == Viewer.Camera.AttachedCar.Train && !(Viewer.Camera is TracksideCamera) && !(Viewer.Camera is FreeRoamCamera))
                            break;
                    }
                    else
                    {
                        // If no train but the same Car, no doppler
                        if (Car == Viewer.Camera.AttachedCar && !(Viewer.Camera is TracksideCamera) && !(Viewer.Camera is FreeRoamCamera))
                            break;
                    }

                    TDBTraveller tdb = new TDBTraveller(Car.Train.FrontTDBTraveller);
                    float speed = Car.SpeedMpS;
                    if (Car.Flipped)
                        speed *= -1;

                    Vector3 tp = -Vector3.Transform(Viewer.Camera.XNALocation(tdb.WorldLocation), Viewer.Camera.XNAView);

                    tdb.Move(speed);

                    tp += Vector3.Transform(Viewer.Camera.XNALocation(tdb.WorldLocation), Viewer.Camera.XNAView);

                    spx = tp.X;
                    spy = tp.Y;
                    spz = tp.Z;

                } while (false);
#endif
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(XNARelativePosition.X , XNARelativePosition.Y , XNARelativePosition.Z, spx, spy, spz );
                }
            }
            else
            {
                // Car is null, no doppler
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(0, 0, 0);
                }
            }
        } // Update

        public bool isOutOfDistance()
        {
            if (WorldLocation == null)
            {
                _distanceSquared = 0;
                return false;
            }

            if (float.IsNaN(WorldLocation.Location.X) ||
                float.IsNaN(WorldLocation.Location.X) ||
                float.IsNaN(WorldLocation.Location.X))
            {
                _distanceSquared = CUTOFFDISTANCE + 1;
                return true;
            }
            
            _distanceSquared = WorldLocation.DistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);

            if (IsEnvSound)
                return false;

            return _distanceSquared > CUTOFFDISTANCE;
        }

        /// <summary>
        /// Return true if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns></returns>
        public bool Activate()
        {
            if (ActivationConditions == null)
                return false;

            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != null)
                {
                    //float distanceSquared = WorldLocation.DistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);
                    if (_distanceSquared < ActivationConditions.Distance * ActivationConditions.Distance &&
                        _distanceSquared < CUTOFFDISTANCE)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Return true if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns></returns>
        public bool DeActivate()
        {
            if (DeactivationConditions == null)
                return false;
            
            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != null)
            {
                //float distanceSquared = WorldLocation.DistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);
                if (_distanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance ||
                    _distanceSquared > CUTOFFDISTANCE)
                    return true;
            }

            return false;
        }

        public bool IsntThisCabView
        {
            get
            {
                return (Viewer.Camera.Style == Camera.Styles.Cab) && (Viewer.Camera.AttachedCar != Car);
            }
        }

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(MSTS.Activation conditions)
        {
            if (conditions == null)
                return false;

            Camera.Styles viewpoint = Viewer.Camera.Style;

            if (!IsEnvSound && IsntThisCabView)
            {
                viewpoint = Camera.Styles.External;
            }

            if (conditions.CabCam && viewpoint == Camera.Styles.Cab)
                return true;
            if (conditions.PassengerCam && viewpoint == Camera.Styles.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == Camera.Styles.External)
                return true;

            return false;
        }
    }

/////////////////////////////////////////////////////////
/// SOUND STREAM
/////////////////////////////////////////////////////////
        
    public class SoundStream
    {
        public SoundSource SoundSource;
        public int Index = 0;
        public float Volume
        {
            get { return volume / MSTSStream.Volume; }
            set { volume = value * MSTSStream.Volume;  if (ALSoundSource != null) ALSoundSource.Volume = volume; }
        }
        private float volume = 1;

        public List<ORTSTrigger> Triggers = new List<ORTSTrigger>();

        public ALSoundSource ALSoundSource { get; private set; }
        
        private int DiscreteTriggers = 0;
        private int VariableTriggers = 0;
        private bool DiscreteVariableTrigger = false;

        protected MSTS.SMSStream MSTSStream;

        private ORTSInitialTrigger _InitialTrigger = null;
        
        public SoundStream( MSTS.SMSStream mstsStream, SoundSource soundSource, int index, bool isSlowRolloff, float factor )
        {
            float Threshold = float.NaN;
            Index = index;
            SoundSource = soundSource;
            MSTSStream = mstsStream;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, isSlowRolloff, factor);

            if (mstsStream.Triggers != null) 
                foreach( MSTS.Trigger trigger in mstsStream.Triggers )
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                    }
                    else if (trigger.GetType() == typeof(MSTS.Dist_Travelled_Trigger) && soundSource.Car != null )
                    {
                        Triggers.Add(new ORTSDistanceTravelledTrigger(this, (MSTS.Dist_Travelled_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Initial_Trigger))
                    {
                        _InitialTrigger = new ORTSInitialTrigger(this, (MSTS.Initial_Trigger)trigger);
                        Triggers.Add(_InitialTrigger);
                    }
                    else if (trigger.GetType() == typeof(MSTS.Random_Trigger))
                    {
                        Triggers.Add(new ORTSRandomTrigger(this, (MSTS.Random_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Variable_Trigger) && soundSource.Car != null )
                    {
                        MSTS.Variable_Trigger vt = (MSTS.Variable_Trigger)trigger;
                        Triggers.Add(new ORTSVariableTrigger(this, vt));
                        VariableTriggers++;
                        if (float.IsNaN(Threshold))
                        {
                            Threshold = vt.Threshold;
                            DiscreteVariableTrigger = true;
                        }
                        else
                        {
                            DiscreteVariableTrigger &= Threshold == vt.Threshold;
                            Threshold = vt.Threshold;
                        }
                    }
                    else if (trigger.GetType() == typeof(MSTS.Variable_Trigger) && soundSource.IsEnvSound)
                    {
                        Triggers.Add (new ORTSDistanceTrigger (this, (MSTS.Variable_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Discrete_Trigger) && soundSource.Car != null)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, (MSTS.Discrete_Trigger)trigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                        SoundSource.Car.EventHandlers.Add(ortsTrigger);  // tell the simulator to call us when the event occurs
                    }
                    else if (trigger.GetType() == typeof(MSTS.Discrete_Trigger))
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, (MSTS.Discrete_Trigger)trigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                        DiscreteTriggers++;
                    }
                }  // for each mstsStream.Trigger
        }

        public void Update(float x, float y, float z, float spx, float spy, float spz)
        {
            ALSoundSource.SetVelocity(spx, spy, spz);
            Update(x, y, z);
        }

        /// <summary>
        /// Update frequency and volume relative to curves
        /// Position is in Sound space relative to listener
        /// </summary>
        public void Update(float x, float y, float z)
        {
            if (ALSoundSource == null)
            {
                return;
            }

            ALSoundSource.SetPosition(x, y, z);

            foreach (ORTSTrigger trigger in Triggers)
                trigger.TryTrigger();
            
            // Run Initial if no other is Signaled
            var qt = from t in Triggers
                     where t.Signaled &&
                     (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)
                     select t;

            // If exists an InitialTrigger at all
            if (_InitialTrigger != null)
            {
                int stc = qt.Count();
                // If no triggers active, Initialize the Initial
                if (!ALSoundSource.isPlaying)
                {
                    var vtq = (from t in Triggers
                               where t is ORTSVariableTrigger
                               select t).ToList();

                    if (vtq.Count > 0)
                    {
                        var vtqb = from ORTSVariableTrigger t in vtq
                                   where t.IsBellow
                                   select t;
                        if (vtqb.Count() == vtq.Count)
                        {
#if DEBUGSCR
                            if (!string.IsNullOrEmpty(_InitialTrigger.SoundCommand.FileName))
                                Console.WriteLine("({0})InitialTrigger: {1}", Index, _InitialTrigger.SoundCommand.FileName);
#endif
                            _InitialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else if (stc > 1 && _InitialTrigger.Signaled)
                {
                    _InitialTrigger.Signaled = false;
                }
            }

            SetFreqAndVolume();

            ALSoundSource.Update();
        }

        /// <summary>
        /// Separated Frequency and Volume calculations to prevent glitches - by GeorgeS
        /// </summary>
        private void SetFreqAndVolume()
        {
            MSTSWagon car = SoundSource.Car;
            if (car != null && ALSoundSource != null)
            {
                if (MSTSStream.FrequencyCurve != null)
                {
                    float x = ReadValue(MSTSStream.FrequencyCurve.Control, car);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve);

                    ALSoundSource.PlaybackSpeed = y / ALSoundSource.SampleRate;
                    if (y > 16000)
                    {
                        Console.Write("");
                    }
                }
                if (MSTSStream.VolumeCurve != null)
                {
                    float x = ReadValue(MSTSStream.VolumeCurve.Control, car);
                    float y = Interpolate(x, MSTSStream.VolumeCurve);

                    if (SoundSource.IsntThisCabView)
                        y *= .75f;
                    Volume = y;
                }

                // By GeorgeS
                // No volume curve, set Volume to 1, it will set volume
                // This is for a sound which was initially deactivated
                else
                {
                    if (SoundSource.IsntThisCabView)
                        Volume = .75f;
                    else
                        Volume = 1;
                }
            }
            else if (ALSoundSource != null && SoundSource.IsEnvSound)
            {
                if (MSTSStream.VolumeCurve != null)
                {
                    float x = WorldLocation.DistanceSquared(SoundSource.WorldLocation, SoundSource.Viewer.Camera.CameraWorldLocation) / 500;
                    float y = Interpolate(x, MSTSStream.VolumeCurve);
                    Volume = y;
                }
            }
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="Curve"></param>
        /// <returns></returns>
        private float Interpolate(float x, MSTS.VolumeCurve Curve)
        {
            MSTS.CurvePoint[] curvePoints = Curve.CurvePoints;

            if (Curve.Granularity == 0)
            {
                if (x < curvePoints[0].X)
                    return curvePoints[0].Y;
                if (x > curvePoints[curvePoints.Length - 1].X)
                    return curvePoints[curvePoints.Length - 1].Y;
            }

            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x) ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the car data in the simulator.
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(MSTS.VolumeCurve.Controls control, MSTSWagon car)
        {
            switch (control)
            {
                case MSTS.VolumeCurve.Controls.DistanceControlled: return car.DistanceM;
                case MSTS.VolumeCurve.Controls.SpeedControlled: return Math.Abs(car.SpeedMpS);
                case MSTS.VolumeCurve.Controls.Variable1Controlled: return car.Variable1;
                case MSTS.VolumeCurve.Controls.Variable2Controlled: return car.Variable2 * 100F;
                case MSTS.VolumeCurve.Controls.Variable3Controlled: return car.Variable3;
                default: return 0;
            }
        }

        public void Stop()
        {
            if (ALSoundSource != null)
            {
#if DEBUGSCR
                Console.WriteLine("Stopping: " + _playingSound.Name.Substring(_playingSound.Name.LastIndexOf('\\')));
#endif
                ALSoundSource.Stop();
            }
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ALSoundSource != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ALSoundSource.Active = true;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Active = false;
            }
        }

        public void HardActivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardActive = true;
            }
        }

        public void HardDeactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardActive = false;
            }
        }

    } // class ORTSStream

/////////////////////////////////////////////////////////
/// SOUND TRIGGERS
/////////////////////////////////////////////////////////

    public class ORTSTrigger
    {
        public bool Enabled = true;  // set by the DisableTrigger, EnableTrigger sound commands
        public bool Signaled = false;

        // SoundCommand moved here from all descendants in order to support loops - by GeorgeS
        public ORTSSoundCommand SoundCommand;

        public virtual void TryTrigger() { }

        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger: ORTSTrigger, CarEventHandler
    {
        public EventID TriggerID;
        // Added in order to check the activeness of the SoundSource - by GeorgeS
        private SoundStream _soundStream;

        public ORTSDiscreteTrigger(SoundStream soundStream, MSTS.Discrete_Trigger smsData)
        {
            TriggerID = (EventID)smsData.TriggerID;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            // Save SoundStream - by GeorgeS
            _soundStream = soundStream;
        }

        public void HandleCarEvent(EventID eventID)
        {
            if (Enabled && eventID == TriggerID)
            {
                SoundCommand.Run();
#if DEBUGSCR
                Console.WriteLine("({0})DiscreteTrigger: {1}:{2}", _soundStream.Index, (int)eventID, SoundCommand.FileName);
#endif
                // Added in order to check the activeness of the SoundSource - by GeorgeS
                if (!_soundStream.SoundSource.Active)
                {
                    // If the SoundSource is not active, should deactivate the SoundStream also
                    //   preventing the hearing when not should be audible
                    _soundStream.Deactivate();
                }
            }
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public class ORTSDistanceTravelledTrigger: ORTSTrigger
    {
        MSTS.Dist_Travelled_Trigger SMS;
        float triggerDistance;
        TrainCar car;
        SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, MSTS.Dist_Travelled_Trigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream );
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceM > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundCommand.Run();
                    float volume = (float)Program.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                }
                UpdateTriggerDistance();
#if DEBUGSCR
                Console.WriteLine("({0})DistanceTravelledTrigger: Current:{1}, Next:{2}", SoundStream.Index, car.DistanceM, triggerDistance);
#endif

            }
            else
            {
                Signaled = false;
            }
        }

        private void UpdateTriggerDistance()
        {
            if (SMS.Dist_Max != SMS.Dist_Min)
            {
                triggerDistance = car.DistanceM + ((float)Program.Random.NextDouble() * (SMS.Dist_Max - SMS.Dist_Min) + SMS.Dist_Min);
            }
            else
            {
                triggerDistance = car.DistanceM + ((float)Program.Random.NextDouble() * (SMS.Dist_Min) + SMS.Dist_Min);
            }
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active
    /// </summary>
    public class ORTSInitialTrigger: ORTSTrigger
    {
        public ORTSInitialTrigger(SoundStream soundStream, MSTS.Initial_Trigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
        }

        public override void Initialize()
        {
            if( Enabled )
                SoundCommand.Run();

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public class ORTSRandomTrigger: ORTSTrigger
    {
        Simulator Simulator;
        MSTS.Random_Trigger SMS;
        double StartSeconds = 0.0;
        double triggerAtSeconds;
        SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, MSTS.Random_Trigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            Simulator = soundStream.SoundSource.Viewer.Simulator;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            StartSeconds = Simulator.ClockTime;
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundCommand.Run();
                    float volume = (float)Program.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        private void UpdateTriggerAtSeconds()
        {
            double interval = Program.Random.NextDouble() * (SMS.Delay_Max - SMS.Delay_Min) + SMS.Delay_Min;
            triggerAtSeconds = Simulator.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public class ORTSDistanceTrigger : ORTSTrigger
    {
        MSTS.Variable_Trigger SMS;
        SoundStream _SoundStream;

        float StartValue;

        public ORTSDistanceTrigger(SoundStream soundStream, MSTS.Variable_Trigger smsData)
        {
            SMS = smsData;
            _SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            StartValue = 100000;
        }

        public override void TryTrigger()
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                    if (newValue < SMS.Threshold
                        && StartValue >= SMS.Threshold)
                        triggered = true;
                    if (newValue < SMS.Threshold)
                        Signaled = true;
                    break;
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                    if (newValue > SMS.Threshold
                        && StartValue <= SMS.Threshold)
                        triggered = true;
                    if (newValue > SMS.Threshold)
                        Signaled = true;
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            if (triggered && Enabled)
            {
                SoundCommand.Run();
            }
        } // TryTrigger

        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                    return WorldLocation.DistanceSquared(_SoundStream.SoundSource.WorldLocation, _SoundStream.SoundSource.Viewer.Camera.CameraWorldLocation) / 500;
                default:
                    return 100000;
            }
        }

    }  // class DistanceTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public class ORTSVariableTrigger: ORTSTrigger
    {
        MSTS.Variable_Trigger SMS;
        MSTSWagon car;
        SoundStream _SoundStream;

        float StartValue;
        public bool IsBellow = false;

        public ORTSVariableTrigger(SoundStream soundStream, MSTS.Variable_Trigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car;
            _SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
 	        StartValue = 0;
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger( )
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Variable_Trigger.Events.Speed_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable1_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable2_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable3_Dec_Past:
                    if (newValue < SMS.Threshold
                        && StartValue >= SMS.Threshold)
                        triggered = true;
                    if (newValue < SMS.Threshold)
                        Signaled = true;
                    break;
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                case MSTS.Variable_Trigger.Events.Speed_Inc_Past:
                case MSTS.Variable_Trigger.Events.Variable1_Inc_Past:
                case MSTS.Variable_Trigger.Events.Variable2_Inc_Past:
                case MSTS.Variable_Trigger.Events.Variable3_Inc_Past:
                    if (newValue > SMS.Threshold
                        && StartValue <= SMS.Threshold)
                        triggered = true;
                    if (newValue > SMS.Threshold)
                        Signaled = true;
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = StartValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundCommand.Run();

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Console.WriteLine("({0})StartLoop ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.FileName);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Console.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.FileName);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Console.WriteLine("({0})ReleaseLoopRelease ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), rlr.FileName);
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Console.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), rlrwj.FileName);
                }
#endif
            }
        } // TryTrigger

        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                    return car.DistanceM;
                case MSTS.Variable_Trigger.Events.Speed_Dec_Past:
                case MSTS.Variable_Trigger.Events.Speed_Inc_Past:
                    return Math.Abs(car.SpeedMpS);
                case MSTS.Variable_Trigger.Events.Variable1_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable1_Inc_Past:
                    return car.Variable1;
                case MSTS.Variable_Trigger.Events.Variable2_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable2_Inc_Past:
                    return car.Variable2;
                case MSTS.Variable_Trigger.Events.Variable3_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable3_Inc_Past:
                    return car.Variable3;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


/////////////////////////////////////////////////////////
/// SOUND COMMANDS
/////////////////////////////////////////////////////////
    

    /// <summary>
    /// Play a sound file once.
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, MSTS.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        public override void Run()
        {
            string p = GetNextFile();
            if (p != "")
            {
                ORTSStream.ALSoundSource.Queue(p, PlayMode.OneShot, ORTSStream.SoundSource.IsExternal);
            }
        }
    } 

    /// <summary>
    /// Start a repeating sound
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        SoundStream _SoundStream;
        public ORTSStartLoop( SoundStream ortsStream, MSTS.SoundPlayCommand mstsSoundPlayCommand )
            : base( ortsStream, mstsSoundPlayCommand )
        {
            _SoundStream = ortsStream;
        }
        public override void  Run( )
        {
            // Support for Loop functions - by GeorgeS
            string p = GetNextFile();
            if (p != "")
            {
                ORTSStream.ALSoundSource.Queue(p, PlayMode.Loop, ORTSStream.SoundSource.IsExternal);
            }
        }
    } 

    /// <summary>
    /// Stop a repeating sound.
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public override string FileName { get;  set; }

        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }
        
        public override void Run()
        {
            ORTSStream.ALSoundSource.Queue("", PlayMode.Release, ORTSStream.SoundSource.IsExternal);
        }
    }

    /// <summary>
    /// Start a looping sound that uses repeat markers
    /// TODO - until we implement markers, this will start the sound as a simple one shot
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        SoundStream _SoundStream;

        public ORTSStartLoopRelease(SoundStream ortsStream, MSTS.PlayOneShot mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
            _SoundStream = ortsStream;
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            string p = GetNextFile();
            if (p != "")
            {
                ORTSStream.ALSoundSource.Queue(p, PlayMode.LoopRelease, ORTSStream.SoundSource.IsExternal);
            }
        }
    }

    /// <summary>
    /// Jump to the exit portion of a looping sound with repeat markers   
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public override string FileName { get; set; }
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            ORTSStream.ALSoundSource.Queue("", PlayMode.ReleaseWithJump, ORTSStream.SoundSource.IsExternal);
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, MSTS.DisableTrigger smsData )
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, MSTS.DisableTrigger smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if ( TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume Command
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, MSTS.SetStreamVolume smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        protected SoundStream ORTSStream;

        public ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        public virtual string FileName { get; set; }

        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(MSTS.SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.PlayOneShot))
            {
                return new ORTSPlayOneShot(soundStream, (MSTS.PlayOneShot)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.StartLoop))
            {
                return new ORTSStartLoop(soundStream, (MSTS.StartLoop)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.StartLoopRelease))
            {
                return new ORTSStartLoopRelease(soundStream, (MSTS.StartLoopRelease)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.ReleaseLoopRelease))
            {
                return new ORTSReleaseLoopRelease(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.ReleaseLoopReleaseWithJump))
            {
                return new ORTSReleaseLoopReleaseWithJump(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.SetStreamVolume))
            {
                return new ORTSSetStreamVolume(soundStream, (MSTS.SetStreamVolume) mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.DisableTrigger))
            {
                return new ORTSDisableTrigger(soundStream, (MSTS.DisableTrigger)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.EnableTrigger))
            {
                return new ORTSEnableTrigger(soundStream, (MSTS.EnableTrigger)mstsSoundCommand);
            }
			throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, "mstsSoundCommand");
        }

    }// ORTSSoundCommand

    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        protected String[] Files;
        protected MSTS.SoundCommand.SelectionMethods SelectionMethod;
        protected int iFile = 0;

        public ORTSSoundPlayCommand(SoundStream ortsStream, MSTS.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand.Files;
            SelectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        protected string GetNextFile()
        {
            if (SelectionMethod == MSTS.SoundCommand.SelectionMethods.SequentialSelection)
            {
                ++iFile;
                if (iFile >= Files.Length)
                    iFile = 0;
            }
            else if (SelectionMethod == MSTS.SoundCommand.SelectionMethods.RandomSelection)
            {
                iFile = Program.Random.Next(Files.Length);
            }

#if PLAYSOUNDS
            string filePath = ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile];
            if (!File.Exists(filePath))
            {
                filePath = Program.Simulator.RoutePath + @"\Sound\" + Files[iFile];
                if (!File.Exists(filePath))
                {
                    filePath = Program.Simulator.BasePath + @"\Sound\" + Files[iFile];
                }
            }
            if (File.Exists(filePath))
            {
                return filePath;
            }
            else
            {
                return "";
            }
#endif
        }

        public override string FileName
        {
            get
            {
                return Files[iFile];
            }
        }
    } // ORTSSoundPlayCommand 

    public class WorldSounds
    {
        List<WSFile> Files = new List<WSFile>();
        Dictionary<string, List<SoundSource>> Sounds = new Dictionary<string, List<SoundSource>>();
        private Viewer3D Viewer;

        public WorldSounds(Viewer3D viewer)
        {
            Viewer = viewer;
        }

        public void Update(ElapsedTime elapsedTime)
        {
            return;
        }

        public void AddByTile(int TileX, int TileZ)
        {
            string name = WorldFileNameFromTileCoordinates(TileX, TileZ);
            string soundfolder = Program.Simulator.RoutePath + "\\sound\\";
#if PLAYENVSOUNDS
            lock (Sounds)
            {
                if (!Sounds.ContainsKey(name))
                {
                    WSFile wf = new WSFile(name);
                    List<SoundSource> ls = new List<SoundSource>();
                    if (wf.TR_WorldSoundFile != null)
                    {
                        foreach (WorldSoundSource fss in wf.TR_WorldSoundFile.SoundSources)
                        {
                            WorldLocation wl = new WorldLocation(TileX, TileZ, fss.X, fss.Y, fss.Z);
                            SoundSource ss = null;
                            if (File.Exists(soundfolder + fss.SoundSourceFileName))
                                ss = new SoundSource(Viewer, wl, soundfolder + fss.SoundSourceFileName, true);
                            if (ss != null)
                                ls.Add(ss);
                        }
                    }
                    Viewer.SoundProcess.AddSoundSource(name, ls);
                }
            }
#endif
        }

        public void RemoveByTile(int TileX, int TileZ)
        {
            string name = WorldFileNameFromTileCoordinates(TileX, TileZ);
            lock (Sounds)
            {
                if (Sounds.ContainsKey(name))
                {
                    Viewer.SoundProcess.RemoveSoundSource(name);
                }
            }
        }

        /// <summary>
        /// Build a w filename from tile X and Z coordinates.
        /// Returns a string eg "w-011283+014482.w"
        /// </summary>
        private string WorldFileNameFromTileCoordinates(int tileX, int tileZ)
        {
            string filename = Viewer.Simulator.RoutePath + @"\WORLD\";
            filename += "w" + FormatTileCoordinate(tileX) + FormatTileCoordinate(tileZ) + ".ws";
            return filename;
        }

        /// <summary>
        /// For building a filename from tile X and Z coordinates.
        /// Returns the string representation of a coordinate
        /// eg "+014482"
        /// </summary>
        private string FormatTileCoordinate(int tileCoord)
        {
            string sign = "+";
            if (tileCoord < 0)
            {
                sign = "-";
                tileCoord *= -1;
            }
            return sign + tileCoord.ToString("000000");
        }
    }

}

