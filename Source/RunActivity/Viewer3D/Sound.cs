/// ORTS SOUND SYSTEM
/// 
/// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
/// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
/// SoundSource objects
///  - have a physical location in the world, 
///  - assume the listener is located at the same location as the 3D viewer
///  - may be attached to a railcar in which case it moves with the car
///  - railcar-attached sounds can poll control variables in the simulator
///  - have one or more SoundStreams
///  SoundStreams
///  - can play only one sound at a time
///  - the sound played is controlled by the various triggers
///  SoundTriggers
///  - defined in the SMS file
///  - triggered by various events
///  - when triggered, executes a SoundCommand
///  SoundCommands
///  - used by triggers to control the SoundStream
///  - ie play a sound, stop a sound etc
///  
/// COPYRIGHT 2009 by the Open Rails project.
/// This code is provided to enable you to contribute improvements to the open rails program.  
/// Use of the code for any other purpose or distribution of the code to anyone else
/// is prohibited without specific written permission from admin@openrails.org.
#define PLAYSOUNDS
#define PLAYENVSOUNDS
//#define DEBUGSCR
#define STEREOCAB
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using IrrKlang;
using Microsoft.Xna.Framework;


namespace ORTS
{

/////////////////////////////////////////////////////////
/// SOUND SOURCE
/////////////////////////////////////////////////////////

    
    public class SoundSource 
    {
        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer3D viewer, MSTSWagon car, string smsFilePath)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific loaction - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer3D viewer, string smsFilePath)
        {
            Initialize(viewer, null, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer3D viewer, WorldLocation worldLocation, string smsFilePath)
        {
            IsEnvSound = true;
            Initialize(viewer, worldLocation, smsFilePath);
        }

        /// <summary>
        /// No need to play the sounds, stop them
        /// </summary>
        public void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
                ss.Stop();
        }
        
        public WorldLocation WorldLocation;   // current location for the sound source
        public Viewer3D Viewer;                 // the listener is connected to this viewer
        public MSTSWagon Car = null;          // the sound may be from a train car

        public string SMSFolder;              // the wave files will be relative to this folder
        public bool Active = false;
        public bool setDeactivate = true;     // For initially mute sounds - by GeorgeS
        private MSTS.Activation ActivationConditions;
        private MSTS.Deactivation DeactivationConditions;
        public bool IsEnvSound = false;

        private double LastUpdate = 0;

        List<SoundStream> SoundStreams = new List<SoundStream>();

        public void Initialize(Viewer3D viewer, WorldLocation worldLocation, string smsFilePath)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;
            SMSFolder = Path.GetDirectoryName(smsFilePath);
            MSTS.SMSFile smsFile = MSTS.SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int iSG = 0;
            while ( iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count)
                {
            
                if (smsFile.Tr_SMS.ScalabiltyGroups[iSG].DetailLevel <= Viewer.SettingsInt[(int)IntSettings.SoundDetailLevel])
                {
                    break;
                }

                ++iSG;
            }
            if (iSG < smsFile.Tr_SMS.ScalabiltyGroups.Count && smsFile.Tr_SMS.ScalabiltyGroups[iSG].Streams != null)  // else we want less sound so don't provide any
            {
                MSTS.ScalabiltyGroup mstsScalabiltyGroup = smsFile.Tr_SMS.ScalabiltyGroups[iSG];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;

                int cou = 1;
                foreach (MSTS.SMSStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams.Add(new SoundStream(mstsStream, this, cou++));
                }
            }
        }

        public void HandleEvent(EventID eventID)
        {
            foreach (SoundStream ss in SoundStreams)
            {
                foreach (ORTSTrigger trg in ss.Triggers)
                {
                    ORTSDiscreteTrigger dt = trg as ORTSDiscreteTrigger;
                    if (dt != null)
                        dt.HandleCarEvent(eventID);
                }
            }
        }

        public bool IsCABSound
        {
            get
            {
                return ActivationConditions.CabCam && !ActivationConditions.ExternalCam;
            }
        }

        public bool IsPassengerSound
        {
            get
            {
                return ActivationConditions.PassengerCam && !ActivationConditions.ExternalCam;
            }
        }

        public void Update(ElapsedTime elapsedTime)
        {
            if (Program.RealTime < LastUpdate + .2)
                return;

            LastUpdate = Program.RealTime;
            
            if (!Active)
            {
                if (Activate())
                {
                    Active = true;
                    setDeactivate = false;

                    // run the initial triggers
                    foreach( SoundStream stream in SoundStreams )
                        foreach (ORTSTrigger trigger in stream.Triggers)
                            trigger.Initialize();

                    // restore any looping sounds
                    foreach( SoundStream stream in SoundStreams )
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    setDeactivate = true;

                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            // Must start and stop by triggers - by GeorgeS
            //if (Active)
            if (WorldLocation != null)
            {
                // update the sound position relative to the listener
                Vector3 RelativePosition = WorldLocation.Location;
                RelativePosition.X += 2048 * (WorldLocation.TileX - Viewer.Camera.TileX);
                RelativePosition.Z += 2048 * (WorldLocation.TileZ - Viewer.Camera.TileZ);

                Vector3 XNARelativePosition = new Vector3(RelativePosition.X, RelativePosition.Y, -RelativePosition.Z);
                XNARelativePosition = Vector3.Transform(XNARelativePosition, Viewer.Camera.XNAView);

                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(new Vector3D(XNARelativePosition.X / 10, XNARelativePosition.Y / 10, XNARelativePosition.Z / 10));
                    // If initially not active, Deactivate it - by GeorgeS
                    if (setDeactivate)
                        stream.Deactivate();
                }
            }
            else
            {
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(new Vector3D(0, 0, 0));
                    // If initially not active, Deactivate it - by GeorgeS
                    if (setDeactivate)
                        stream.Deactivate();
                }
            }
        } // Update

        /// <summary>
        /// Return true if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns></returns>
        public bool Activate()
        {
            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != null)
                {
                    float distanceSquared = WorldLocation.DistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);
                    if (distanceSquared < ActivationConditions.Distance * ActivationConditions.Distance)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Return true if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns></returns>
        public bool DeActivate()
        {
            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != null)
            {
                float distanceSquared = WorldLocation.DistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);
                if (distanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(MSTS.Activation conditions)
        {
            if (conditions == null)
                return false;

            Camera.Styles viewpoint = Viewer.Camera.Style;

            if ( (viewpoint == Camera.Styles.Cab) && (Viewer.Camera.AttachedCar != Car) )
            {
                viewpoint = Camera.Styles.External;
            }

            if (conditions.CabCam && viewpoint == Camera.Styles.Cab)
                return true;
            if (conditions.PassengerCam && viewpoint == Camera.Styles.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == Camera.Styles.External)
                return true;

            return false;
        }
    }

/////////////////////////////////////////////////////////
/// SOUND STREAM
/////////////////////////////////////////////////////////
        
    public class SoundStream
    {
        public SoundSource SoundSource;
        public int Index = 0;
        public float Volume
        {
            get { return volume / MSTSStream.Volume; }
            set { volume = value * MSTSStream.Volume;  if (ISound != null) ISound.Volume = volume; }
        }
        private float volume = 1;

        public List<ORTSTrigger> Triggers = new List<ORTSTrigger>();
        public bool IsPlaying = false;

        private Queue<KeyValuePair<ISoundSource, bool>> _qPlay = new Queue<KeyValuePair<ISoundSource, bool>>();
        public ISoundSource _playingSound = null;
        private double _stoppedAt = 0;
        private int DiscreteTriggers = 0;
        private int VariableTriggers = 0;
        private bool DiscreteVariableTrigger = false;

        protected MSTS.SMSStream MSTSStream;

        private ORTSInitialTrigger _InitialTrigger = null;
        private ISound ISound = null;
        private float SampleRate; // ie 11025 - set by play command
        private  ISoundSource RepeatingSound = null; // allows us to reactivate
        
        public SoundStream( MSTS.SMSStream mstsStream, SoundSource soundSource, int index )
        {
            float Threshold = float.NaN;
            Index = index;
            SoundSource = soundSource;
            MSTSStream = mstsStream;

            if (mstsStream.Triggers != null) 
                foreach( MSTS.Trigger trigger in mstsStream.Triggers )
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                    }
                    else if (trigger.GetType() == typeof(MSTS.Dist_Travelled_Trigger) && soundSource.Car != null )
                    {
                        Triggers.Add(new ORTSDistanceTravelledTrigger(this, (MSTS.Dist_Travelled_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Initial_Trigger))
                    {
                        _InitialTrigger = new ORTSInitialTrigger(this, (MSTS.Initial_Trigger)trigger);
                        Triggers.Add(_InitialTrigger);
                    }
                    else if (trigger.GetType() == typeof(MSTS.Random_Trigger))
                    {
                        Triggers.Add(new ORTSRandomTrigger(this, (MSTS.Random_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Variable_Trigger) && soundSource.Car != null )
                    {
                        MSTS.Variable_Trigger vt = (MSTS.Variable_Trigger)trigger;
                        Triggers.Add(new ORTSVariableTrigger(this, vt));
                        VariableTriggers++;
                        if (float.IsNaN(Threshold))
                        {
                            Threshold = vt.Threshold;
                            DiscreteVariableTrigger = true;
                        }
                        else
                        {
                            DiscreteVariableTrigger &= Threshold == vt.Threshold;
                            Threshold = vt.Threshold;
                        }
                    }
                    else if (trigger.GetType() == typeof(MSTS.Variable_Trigger) && soundSource.IsEnvSound)
                    {
                        Triggers.Add (new ORTSDistanceTrigger (this, (MSTS.Variable_Trigger)trigger));
                    }
                    else if (trigger.GetType() == typeof(MSTS.Discrete_Trigger) && soundSource.Car != null)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, (MSTS.Discrete_Trigger)trigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                        SoundSource.Car.EventHandlers.Add(ortsTrigger);  // tell the simulator to call us when the event occurs
                    }
                    else if (trigger.GetType() == typeof(MSTS.Discrete_Trigger))
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, (MSTS.Discrete_Trigger)trigger);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                        DiscreteTriggers++;
                    }
                }  // for each mstsStream.Trigger
        }

        /// <summary>
        /// Update frequency and volume relative to curves
        /// Position is in IRRKLANG space relative to listener
        /// </summary>
        public void Update( IrrKlang.Vector3D IRRposition )
        {
            foreach (ORTSTrigger trigger in Triggers)
                trigger.TryTrigger();

            
            // Run Initial if no other is Signaled
            var qt = from t in Triggers
                     where t.Signaled &&
                     (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)
                     select t;

            // If exists an InitialTrigger at all
            if (_InitialTrigger != null)
            {
                int stc = qt.Count();
                // If no triggers active, Initialize the Initial
                if (!IsPlaying)
                {
                    var vtq = (from t in Triggers
                               where t is ORTSVariableTrigger
                               select t).ToList();

                    if (vtq.Count > 0)
                    {
                        var vtqb = from ORTSVariableTrigger t in vtq
                                   where t.IsBellow
                                   select t;
                        if (vtqb.Count() == vtq.Count)
                        {
#if DEBUGSCR
                            if (!string.IsNullOrEmpty(_InitialTrigger.SoundCommand.FileName))
                                Console.WriteLine("({0})InitialTrigger: {1}", Index, _InitialTrigger.SoundCommand.FileName);
#endif
                            _InitialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else if (stc > 1 && _InitialTrigger.Signaled)
                {
                    _InitialTrigger.Signaled = false;
                }
            }

            if (ISound != null)
            {
                ISound.Position = IRRposition;
            }

            CheckSoundQueue();

            SetFreqAndVolume();
        }

        /// <summary>
        /// Separated Frequency and Volume calculations to prevent glitches - by GeorgeS
        /// </summary>
        private void SetFreqAndVolume()
        {
            MSTSWagon car = SoundSource.Car;
            if (car != null && ISound != null)
            {
                if (MSTSStream.FrequencyCurve != null)
                {
                    float x = ReadValue(MSTSStream.FrequencyCurve.Control, car);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve.CurvePoints);
                    ISound.PlaybackSpeed = y / SampleRate;
                    if (y > 16000)
                    {
                        Console.Write("");
                    }
                }
                if (MSTSStream.VolumeCurve != null)
                {
                    float x = ReadValue(MSTSStream.VolumeCurve.Control, car);
                    float y = Interpolate(x, MSTSStream.VolumeCurve.CurvePoints);
                    Volume = y;
                }

                // By GeorgeS
                // No volume curve, set Volume to 1, it will set volume
                // This is for a sound which was initially deactivated
                else
                {
                    Volume = 1;
                }

                // By GeorgeS
                // BTW, if the sound must be deactivated, set it's volume to 0
                if (SoundSource.setDeactivate)
                {
                    Volume = 0;
                }
            }
            else if (ISound != null && SoundSource.IsEnvSound)
            {
                if (MSTSStream.VolumeCurve != null)
                {
                    float x = WorldLocation.DistanceSquared(SoundSource.WorldLocation, SoundSource.Viewer.Camera.CameraWorldLocation) / 500;
                    float y = Interpolate(x, MSTSStream.VolumeCurve.CurvePoints);
                    Volume = y;
                }
            }
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="curvePoints"></param>
        /// <returns></returns>
        private float Interpolate(float x, MSTS.CurvePoint[] curvePoints)
        {
            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x) ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the car data in the simulator.
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(MSTS.VolumeCurve.Controls control, MSTSWagon car)
        {
            switch (control)
            {
                case MSTS.VolumeCurve.Controls.DistanceControlled: return car.DistanceM;
                case MSTS.VolumeCurve.Controls.SpeedControlled: return Math.Abs(car.SpeedMpS);
                case MSTS.VolumeCurve.Controls.Variable1Controlled: return car.Variable1;
                case MSTS.VolumeCurve.Controls.Variable2Controlled: return car.Variable2 * 100F;
                case MSTS.VolumeCurve.Controls.Variable3Controlled: return car.Variable3;
                default: return 0;
            }
        }

        public void Stop()
        {
            if (ISound != null)
            {
                //Console.WriteLine("Stopping: " + _playingSound.Name.Substring(_playingSound.Name.LastIndexOf('\\')));
                ISound.Stop();
                ISound = null;
            }

            RepeatingSound = null;
            _playingSound = null;
        }

        /// <summary>
        /// Clears (already stopped) sound information - by GeorgeS
        /// </summary>
        public void StopRepeating()
        {
            RepeatingSound = null;
            _playingSound = null;
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ISound != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ISound.Volume = volume;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ISound != null)
            {
                ISound.Volume = 0;
            }
        }

        /// <summary>
        /// Check the playable sound queue. If the previous stopped and available a next sound
        /// it begins to play. Timed solution!
        /// </summary>
        public void CheckSoundQueue()
        {
            if (_playingSound != null)
            {
                if (!WAVIrrKlangFileFactory.isPlaying(_playingSound.Name))
                {
                    if (_stoppedAt == 0)
                    {
                        _stoppedAt = Program.RealTime;
                        //_stoppedAt += WAVIrrKlangFileFactory.Weigth(_playingSound.Name) * .025;

                    }
                    else if (_stoppedAt + .8 < Program.RealTime)
                    {
                        _stoppedAt = 0;
                        Stop();
                    }
                }
                else
                {
                    return;
                }
            }

            if (_qPlay.Count > 0)
            {
                KeyValuePair<ISoundSource, bool> kvp = _qPlay.Dequeue();
                Play3D(kvp.Value, kvp.Key);
            }
        }

        public bool isInQueueOrPlaying(string Name)
        {
            return (_playingSound != null && _playingSound.Name == Name) || (
                        _qPlay.Count != 0 &&
                        _qPlay.ElementAt(_qPlay.Count - 1).Key.Name == Name);
        }
        
        /// <summary>
        /// Play the specified sound 
        /// at the default volume.
        /// </summary>
        /// <param name="repeat"></param>
        /// <param name="iSoundSource"></param>
        public void Play3D( bool repeat, IrrKlang.ISoundSource iSoundSource )
        {

            // Queue instead of stopping
            if (ISound != null)
            {
                if ( (VariableTriggers > DiscreteTriggers) && !DiscreteVariableTrigger)
                {
                    Stop();
                }
                else
                {
                    // Queue only if different from current or the last
                    if (_playingSound.Name != iSoundSource.Name && (
                            _qPlay.Count == 0 ||
                            _qPlay.ElementAt(_qPlay.Count - 1).Key.Name != iSoundSource.Name))
                    {
                        _qPlay.Enqueue(new KeyValuePair<ISoundSource, bool>(iSoundSource, repeat));
                    }
                    return;
                }
            }

            Viewer3D viewer = SoundSource.Viewer;

            // position relative to camera
            WorldLocation worldLocation = SoundSource.WorldLocation;
            Vector3 location;
            if (worldLocation != null)
            {
                location = worldLocation.Location;
                location.X += 2048 * (worldLocation.TileX - viewer.Camera.TileX);
                location.Z += 2048 * (worldLocation.TileZ - viewer.Camera.TileZ);
                location.Z *= -1;
                location = Vector3.Transform(location, viewer.Camera.XNAView);
            }
            else
            {
                location = new Vector3(0, 0, 0);
            }
            SampleRate = iSoundSource.AudioFormat.SampleRate;  // ie 11025
            if (viewer.SoundEngine != null)
            {
                // Changed repeat to false, looping implemented with other method - by GeorgeS
                // Changed paused to true - to prevent volume glitches
#if PLAYSOUNDS
#if STEREOCAB
                if (SoundSource.IsCABSound || SoundSource.IsPassengerSound)
                {
                    ISound = viewer.SoundEngine.Play2D(iSoundSource, false, true, false);
                }
                else
                {
#endif
                    ISound = viewer.SoundEngine.Play3D(iSoundSource, location.X / 10, location.Y / 10, location.Z / 10, false, true, false);
#if STEREOCAB
                }
#endif
#endif
            }
            
            // If an unsupported sound found do nothing else
            if (ISound == null)
            {
                return;
            }

            if (SoundSource.IsEnvSound)
            {
                ISound.MinDistance = 50;
                ISound.MaxDistance = 200;
            }

            _playingSound = iSoundSource;

            // Prevent volume glitches - by GeorgeS
            //Volume = 1.0f;
            SetFreqAndVolume();
            // It is unnecessary - never fired.
            //ISound.setSoundStopEventReceiver(new ORTSSoundStopReceiver(), this);

            if (ISound.Paused)
            {
                ISound.Paused = false;
            }

            if (repeat)
            {
                RepeatingSound = iSoundSource;  // remember this so we can reactivate if needed
                // In order to properly stop the looping - By GeorgeS
            }
            else
                RepeatingSound = null;
        }

    } // class ORTSStream

    // In order to properly stop the looping - By GeorgeS
    class ORTSSoundStopReceiver : ISoundStopEventReceiver
    {
        public void OnSoundStopped(ISound sound, StopEventCause reason, object userData)
        {
            SoundStream ss = userData as SoundStream;
            if (ss != null)
            {
                ss.StopRepeating();
                ss.CheckSoundQueue();
                Trace.TraceInformation("Sound stopped: " + ss._playingSound.Name);
            }
        }
    }

/////////////////////////////////////////////////////////
/// SOUND TRIGGERS
/////////////////////////////////////////////////////////

    public class ORTSTrigger
    {
        public bool Enabled = true;  // set by the DisableTrigger, EnableTrigger sound commands
        public bool Signaled = false;

        // SoundCommand moved here from all descendants in order to support loops - by GeorgeS
        public ORTSSoundCommand SoundCommand;

        public virtual void TryTrigger() { }

        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger: ORTSTrigger, CarEventHandler
    {
        public EventID TriggerID;
        // Added in order to check the activeness of the SoundSource - by GeorgeS
        private SoundStream _soundStream;

        public ORTSDiscreteTrigger(SoundStream soundStream, MSTS.Discrete_Trigger smsData)
        {
            TriggerID = (EventID)smsData.TriggerID;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            // Save SoundStream - by GeorgeS
            _soundStream = soundStream;
        }

        public void HandleCarEvent(EventID eventID)
        {
            if (Enabled && eventID == TriggerID)
            {
                SoundCommand.Run();
                // Added in order to check the activeness of the SoundSource - by GeorgeS
                if (!_soundStream.SoundSource.Active)
                {
                    // If the SoundSource is not active, should deactivate the SoundStream also
                    //   preventing the hearing when not should be audible
                    _soundStream.Deactivate();
                }
            }
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public class ORTSDistanceTravelledTrigger: ORTSTrigger
    {
        MSTS.Dist_Travelled_Trigger SMS;
        float triggerDistance;
        TrainCar car;
        SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, MSTS.Dist_Travelled_Trigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream );
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceM > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundCommand.Run();
                    float volume = (float)Program.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                }
                UpdateTriggerDistance();
            }
            else
            {
                Signaled = false;
            }
        }

        private void UpdateTriggerDistance()
        {
                triggerDistance = car.DistanceM + ( (float)Program.Random.NextDouble() * (SMS.Dist_Max - SMS.Dist_Min) + SMS.Dist_Min );
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active
    /// </summary>
    public class ORTSInitialTrigger: ORTSTrigger
    {
        public ORTSInitialTrigger(SoundStream soundStream, MSTS.Initial_Trigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
        }

        public override void Initialize()
        {
            if( Enabled )
                SoundCommand.Run();

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public class ORTSRandomTrigger: ORTSTrigger
    {
        Simulator Simulator;
        MSTS.Random_Trigger SMS;
        double StartSeconds = 0.0;
        double triggerAtSeconds;
        SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, MSTS.Random_Trigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            Simulator = soundStream.SoundSource.Viewer.Simulator;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            StartSeconds = Simulator.ClockTime;
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundCommand.Run();
                    float volume = (float)Program.Random.NextDouble() * (SMS.Volume_Max - SMS.Volume_Min) + SMS.Volume_Min;
                    SoundStream.Volume = volume;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        private void UpdateTriggerAtSeconds()
        {
            double interval = Program.Random.NextDouble() * (SMS.Delay_Max - SMS.Delay_Min) + SMS.Delay_Min;
            triggerAtSeconds = Simulator.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public class ORTSDistanceTrigger : ORTSTrigger
    {
        MSTS.Variable_Trigger SMS;
        SoundStream _SoundStream;

        float StartValue;

        public ORTSDistanceTrigger(SoundStream soundStream, MSTS.Variable_Trigger smsData)
        {
            SMS = smsData;
            _SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void Initialize()
        {
            StartValue = 100000;
        }

        public override void TryTrigger()
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                    if (newValue < SMS.Threshold
                        && StartValue >= SMS.Threshold)
                        triggered = true;
                    if (newValue < SMS.Threshold)
                        Signaled = true;
                    break;
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                    if (newValue > SMS.Threshold
                        && StartValue <= SMS.Threshold)
                        triggered = true;
                    if (newValue > SMS.Threshold)
                        Signaled = true;
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            if (triggered && Enabled)
            {
                SoundCommand.Run();
            }
        } // TryTrigger

        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                    return WorldLocation.DistanceSquared(_SoundStream.SoundSource.WorldLocation, _SoundStream.SoundSource.Viewer.Camera.CameraWorldLocation) / 500;
                default:
                    return 100000;
            }
        }

    }  // class DistanceTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public class ORTSVariableTrigger: ORTSTrigger
    {
        MSTS.Variable_Trigger SMS;
        MSTSWagon car;
        SoundStream _SoundStream;

        float StartValue;
        public bool IsBellow = false;

        public ORTSVariableTrigger(SoundStream soundStream, MSTS.Variable_Trigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car;
            _SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
 	        StartValue = 0;
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger( )
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Variable_Trigger.Events.Speed_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable1_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable2_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable3_Dec_Past:
                    if (newValue < SMS.Threshold
                        && StartValue >= SMS.Threshold)
                        triggered = true;
                    if (newValue < SMS.Threshold)
                        Signaled = true;
                    break;
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                case MSTS.Variable_Trigger.Events.Speed_Inc_Past:
                case MSTS.Variable_Trigger.Events.Variable1_Inc_Past:
                case MSTS.Variable_Trigger.Events.Variable2_Inc_Past:
                case MSTS.Variable_Trigger.Events.Variable3_Inc_Past:
                    if (newValue > SMS.Threshold
                        && StartValue <= SMS.Threshold)
                        triggered = true;
                    if (newValue > SMS.Threshold)
                        Signaled = true;
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = StartValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundCommand.Run();

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Console.WriteLine("({0})StartLoop ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.FileName);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Console.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.FileName);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Console.WriteLine("({0})ReleaseLoopRelease ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), rlr.FileName);
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Console.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}): {3} ", _SoundStream.Index, SMS.Event.ToString(), SMS.Threshold.ToString(), rlrwj.FileName);
                }
#endif
            }
        } // TryTrigger

        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case MSTS.Variable_Trigger.Events.Distance_Dec_Past:
                case MSTS.Variable_Trigger.Events.Distance_Inc_Past:
                    return car.DistanceM;
                case MSTS.Variable_Trigger.Events.Speed_Dec_Past:
                case MSTS.Variable_Trigger.Events.Speed_Inc_Past:
                    return Math.Abs(car.SpeedMpS);
                case MSTS.Variable_Trigger.Events.Variable1_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable1_Inc_Past:
                    return car.Variable1;
                case MSTS.Variable_Trigger.Events.Variable2_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable2_Inc_Past:
                    return car.Variable2;
                case MSTS.Variable_Trigger.Events.Variable3_Dec_Past:
                case MSTS.Variable_Trigger.Events.Variable3_Inc_Past:
                    return car.Variable3;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


/////////////////////////////////////////////////////////
/// SOUND COMMANDS
/////////////////////////////////////////////////////////
    

    /// <summary>
    /// Play a sound file once.
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, MSTS.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        public override void Run()
        {
            Play3D(false);
        }
    } 

    /// <summary>
    /// Start a repeating sound
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        SoundStream _SoundStream;
        public ORTSStartLoop( SoundStream ortsStream, MSTS.SoundPlayCommand mstsSoundPlayCommand )
            : base( ortsStream, mstsSoundPlayCommand )
        {
            _SoundStream = ortsStream;
        }
        public override void  Run( )
        {
            // Support for Loop functions - by GeorgeS
            Play3D(true);
            IsPlaying = true;
            _SoundStream.IsPlaying = true;
            WAVIrrKlangFileFactory.StartLoop(ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile] + '*' + UID.ToString());
        }

        // Support for Loop functions - by GeorgeS
        // Must implement here because this class knows which file playing now
        public void ReleaseLoopRelease()
        {
            _SoundStream.IsPlaying = false;
            IsPlaying = false;
            WAVIrrKlangFileFactory.Release(ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile] + '*' + UID.ToString());
        }

        // Support for Loop functions - by GeorgeS
        // Must implement here because this class knows which file playing now
        public void ReleaseLoopReleaseWithJump()
        {
            _SoundStream.IsPlaying = false;
            IsPlaying = false;
            WAVIrrKlangFileFactory.ReleaseWithJump(ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile] + '*' + UID.ToString());
        }

        public override string FileName
        {
            get
            {
                return Files[iFile];
            }
        }
    } 

    /// <summary>
    /// Stop a repeating sound.
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public override string FileName { get;  set; }

        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }
        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            // StartLoopRelease trigers

            FileName = "";

            // Must find the sound triggers in order to control
            var qstl = from ORTSTrigger t in ORTSStream.Triggers
                       where t.SoundCommand is ORTSStartLoopRelease &&
                       t.SoundCommand.IsPlaying
                       select t.SoundCommand;

            // Release All
            foreach (ORTSStartLoopRelease sc in qstl)
            {
                sc.ReleaseLoopRelease();
                FileName += sc.FileName + " ";
            }

            // Not just the ReleaseLoops may be released
            var qsl = from ORTSTrigger t in ORTSStream.Triggers
                    where t.SoundCommand is ORTSStartLoop &&
                    t.SoundCommand.IsPlaying
                    select t.SoundCommand;

            // Release All
            foreach (ORTSStartLoop sc in qsl)
            {
                sc.ReleaseLoopRelease();
                FileName += sc.FileName + " ";
            }
        }
    }

    /// <summary>
    /// Start a looping sound that uses repeat markers
    /// TODO - until we implement markers, this will start the sound as a simple one shot
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        SoundStream _SoundStream;

        public ORTSStartLoopRelease(SoundStream ortsStream, MSTS.PlayOneShot mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
            _SoundStream = ortsStream;
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            _SoundStream.IsPlaying = true;
            IsPlaying = true;
            WAVIrrKlangFileFactory.StartLoopRelease(ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile] + '*' + UID.ToString());
            Play3D(true);
        }

        // Support for Loop functions - by GeorgeS
        // Must implement here because this class knows which file playing now
        public void ReleaseLoopRelease()
        {
            _SoundStream.IsPlaying = false;
            IsPlaying = false;
            WAVIrrKlangFileFactory.Release(ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile] + '*' + UID.ToString());
        }

        // Support for Loop functions - by GeorgeS
        // Must implement here because this class knows which file playing now
        public void ReleaseLoopReleaseWithJump()
        {
            _SoundStream.IsPlaying = false;
            IsPlaying = false;
            WAVIrrKlangFileFactory.ReleaseWithJump(ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile] + '*' + UID.ToString());
        }

        public override string FileName
        {
            get
            {
                return Files[iFile];
            }
        }
    }

    /// <summary>
    /// Jump to the exit portion of a looping sound with repeat markers   
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public override string FileName { get; set; }
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            // StartLoopRelease trigers

            FileName = "";

            // Must find the sound triggers in order to control
            var qstl = from ORTSTrigger t in ORTSStream.Triggers
                       where t.SoundCommand is ORTSStartLoopRelease &&
                       t.SoundCommand.IsPlaying
                       select t.SoundCommand;

            // Release All
            foreach (ORTSStartLoopRelease sc in qstl)
            {
                sc.ReleaseLoopReleaseWithJump();
                FileName = sc.FileName + " ";
            }

            // Not just the ReleaseLoops may be released
            var qsl = from ORTSTrigger t in ORTSStream.Triggers
                      where t.SoundCommand is ORTSStartLoop &&
                      t.SoundCommand.IsPlaying
                      select t.SoundCommand;

            // Release All
            foreach (ORTSStartLoop sc in qsl)
            {
                sc.ReleaseLoopReleaseWithJump();
                FileName = sc.FileName + " ";
            }
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, MSTS.DisableTrigger smsData )
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, MSTS.DisableTrigger smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerID - 1;
        }

        public override void Run()
        {
            if ( TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume Command
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, MSTS.SetStreamVolume smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        public bool IsPlaying;
        protected SoundStream ORTSStream;

        public ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        public virtual string FileName { get; set; }

        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(MSTS.SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.PlayOneShot))
            {
                return new ORTSPlayOneShot(soundStream, (MSTS.PlayOneShot)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.StartLoop))
            {
                return new ORTSStartLoop(soundStream, (MSTS.StartLoop)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.StartLoopRelease))
            {
                return new ORTSStartLoopRelease(soundStream, (MSTS.StartLoopRelease)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.ReleaseLoopRelease))
            {
                return new ORTSReleaseLoopRelease(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.ReleaseLoopReleaseWithJump))
            {
                return new ORTSReleaseLoopReleaseWithJump(soundStream);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.SetStreamVolume))
            {
                return new ORTSSetStreamVolume(soundStream, (MSTS.SetStreamVolume) mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.DisableTrigger))
            {
                return new ORTSDisableTrigger(soundStream, (MSTS.DisableTrigger)mstsSoundCommand);
            }
            else if (mstsSoundCommand.GetType() == typeof(MSTS.EnableTrigger))
            {
                return new ORTSEnableTrigger(soundStream, (MSTS.EnableTrigger)mstsSoundCommand);
            }
			throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, "mstsSoundCommand");
        }

    }// ORTSSoundCommand

    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        protected String[] Files;
        protected MSTS.SoundCommand.SelectionMethods SelectionMethod;
        protected int iFile = 0;
        // This UID identifies the SoundCommand to irrKlang - by GeorgeS
        protected Guid UID = Guid.NewGuid();

        public ORTSSoundPlayCommand(SoundStream ortsStream, MSTS.SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand.Files;
            SelectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        protected void Play3D( bool repeat)
        {
            if (SelectionMethod == MSTS.SoundCommand.SelectionMethods.SequentialSelection)
            {
                ++iFile;
                if (iFile >= Files.Length)
                    iFile = 0;
            }
            else if (SelectionMethod == MSTS.SoundCommand.SelectionMethods.RandomSelection)
            {
                iFile = Program.Random.Next(Files.Length);
            }

#if PLAYSOUNDS
            string filePath = ORTSStream.SoundSource.SMSFolder + @"\" + Files[iFile];
            if (!File.Exists(filePath))
            {
                filePath = Program.Simulator.RoutePath + @"\Sound\" + Files[iFile];
                if (!File.Exists(filePath))
                {
                    filePath = Program.Simulator.BasePath + @"\Sound\" + Files[iFile];
                }
            }
            if (File.Exists(filePath) && ORTSStream.SoundSource.Viewer.SoundEngine != null )
            {
                filePath += '*' + UID.ToString();
                if (!ORTSStream.isInQueueOrPlaying(filePath))
                {
                    IrrKlang.ISoundSource iSoundSource = ORTSStream.SoundSource.Viewer.SoundEngine.GetSoundSource(filePath, true);
                    // Loop play support - by GeorgeS
                    // Must be set to support looping and not to fail with OutOfMemory
                    if (iSoundSource != null)
                    {
                        iSoundSource.StreamMode = StreamMode.Streaming;
                        ORTSStream.Play3D(repeat, iSoundSource);
                    }
                }
            }
#endif
        }

        public override string FileName
        {
            get
            {
                return Files[iFile];
            }
        }
    } // ORTSSoundPlayCommand 

    public class WorldSounds
    {
        List<WSFile> Files = new List<WSFile>();
        Dictionary<string, List<SoundSource>> Sounds = new Dictionary<string, List<SoundSource>>();
        private Viewer3D Viewer;

        public WorldSounds(Viewer3D viewer)
        {
            Viewer = viewer;
        }

        public void Update(ElapsedTime elapsedTime)
        {
            lock (Sounds)
            {
                foreach (List<SoundSource> ls in Sounds.Values)
                {
                    foreach (SoundSource ss in ls)
                        ss.Update(elapsedTime);
                }
            }
        }

        public void AddByTile(int TileX, int TileZ)
        {
            string name = WorldFileNameFromTileCoordinates(TileX, TileZ);
            string soundfolder = Program.Simulator.RoutePath + "\\sound\\";
#if PLAYENVSOUNDS
            lock (Sounds)
            {
                if (!Sounds.ContainsKey(name))
                {
                    WSFile wf = new WSFile(name);
                    List<SoundSource> ls = new List<SoundSource>();
                    if (wf.TR_WorldSoundFile != null)
                    {
                        foreach (WorldSoundSource fss in wf.TR_WorldSoundFile.SoundSources)
                        {
                            WorldLocation wl = new WorldLocation(TileX, TileZ, fss.X, fss.Y, fss.Z);
                            SoundSource ss = null;
                            if (File.Exists(soundfolder + fss.SoundSourceFileName))
                                ss = new SoundSource(Viewer, wl, soundfolder + fss.SoundSourceFileName);
                            if (ss != null)
                                ls.Add(ss);
                        }
                    }
                    Sounds.Add(name, ls);
                }
            }
#endif
        }

        public void RemoveByTile(int TileX, int TileZ)
        {
            string name = WorldFileNameFromTileCoordinates(TileX, TileZ);
            lock (Sounds)
            {
                if (Sounds.ContainsKey(name))
                {
                    List<SoundSource> ls = Sounds[name];
                    Sounds.Remove(name);
                    foreach (SoundSource ss in ls)
                        ss.Uninitialize();
                }
            }
        }

        /// <summary>
        /// Build a w filename from tile X and Z coordinates.
        /// Returns a string eg "w-011283+014482.w"
        /// </summary>
        private string WorldFileNameFromTileCoordinates(int tileX, int tileZ)
        {
            string filename = Viewer.Simulator.RoutePath + @"\WORLD\";
            filename += "w" + FormatTileCoordinate(tileX) + FormatTileCoordinate(tileZ) + ".ws";
            return filename;
        }

        /// <summary>
        /// For building a filename from tile X and Z coordinates.
        /// Returns the string representation of a coordinate
        /// eg "+014482"
        /// </summary>
        private string FormatTileCoordinate(int tileCoord)
        {
            string sign = "+";
            if (tileCoord < 0)
            {
                sign = "-";
                tileCoord *= -1;
            }
            return sign + tileCoord.ToString("000000");
        }
    }

}

